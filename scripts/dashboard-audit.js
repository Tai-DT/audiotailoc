#!/usr/bin/env node

/**
 * Dashboard Audit Script
 * Ki·ªÉm tra v√† ƒë√°nh gi√° tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa Dashboard AudioTailoc
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class DashboardAuditor {
  constructor() {
    this.dashboardPath = path.join(__dirname, '../dashboard');
    this.reportPath = path.join(__dirname, '../DASHBOARD_AUDIT_REPORT.md');
    this.auditResults = {
      timestamp: new Date().toISOString(),
      overallScore: 0,
      categories: {},
      recommendations: [],
      issues: [],
      completedTasks: [],
      pendingTasks: []
    };
  }

  async runAudit() {
    console.log('üîç B·∫Øt ƒë·∫ßu audit Dashboard AudioTailoc...\n');
    
    try {
      await this.checkProjectStructure();
      await this.checkDependencies();
      await this.checkComponents();
      await this.checkPages();
      await this.checkConfiguration();
      await this.checkTesting();
      await this.checkDocumentation();
      await this.calculateScore();
      await this.generateReport();
      
      console.log('‚úÖ Audit ho√†n th√†nh!');
      console.log(`üìä ƒêi·ªÉm t·ªïng th·ªÉ: ${this.auditResults.overallScore}/100`);
      console.log(`üìÑ B√°o c√°o ƒë∆∞·ª£c t·∫°o t·∫°i: ${this.reportPath}`);
      
    } catch (error) {
      console.error('‚ùå L·ªói trong qu√° tr√¨nh audit:', error.message);
    }
  }

  async checkProjectStructure() {
    console.log('üìÅ Ki·ªÉm tra c·∫•u tr√∫c project...');
    
    const requiredDirs = [
      'app',
      'components',
      'lib',
      'hooks',
      'store',
      'public'
    ];

    const requiredFiles = [
      'package.json',
      'tsconfig.json',
      'next.config.js',
      'tailwind.config.js',
      'README.md'
    ];

    this.auditResults.categories.structure = {
      score: 0,
      issues: [],
      completed: [],
      missing: []
    };

    // Ki·ªÉm tra th∆∞ m·ª•c
    for (const dir of requiredDirs) {
      const dirPath = path.join(this.dashboardPath, dir);
      if (fs.existsSync(dirPath)) {
        this.auditResults.categories.structure.completed.push(`‚úÖ Th∆∞ m·ª•c ${dir} t·ªìn t·∫°i`);
      } else {
        this.auditResults.categories.structure.missing.push(`‚ùå Th∆∞ m·ª•c ${dir} thi·∫øu`);
        this.auditResults.categories.structure.issues.push(`Thi·∫øu th∆∞ m·ª•c: ${dir}`);
      }
    }

    // Ki·ªÉm tra file
    for (const file of requiredFiles) {
      const filePath = path.join(this.dashboardPath, file);
      if (fs.existsSync(filePath)) {
        this.auditResults.categories.structure.completed.push(`‚úÖ File ${file} t·ªìn t·∫°i`);
      } else {
        this.auditResults.categories.structure.missing.push(`‚ùå File ${file} thi·∫øu`);
        this.auditResults.categories.structure.issues.push(`Thi·∫øu file: ${file}`);
      }
    }

    // T√≠nh ƒëi·ªÉm
    const totalItems = requiredDirs.length + requiredFiles.length;
    const completedItems = this.auditResults.categories.structure.completed.length;
    this.auditResults.categories.structure.score = Math.round((completedItems / totalItems) * 100);
  }

  async checkDependencies() {
    console.log('üì¶ Ki·ªÉm tra dependencies...');
    
    const packageJsonPath = path.join(this.dashboardPath, 'package.json');
    
    this.auditResults.categories.dependencies = {
      score: 0,
      issues: [],
      completed: [],
      missing: []
    };

    if (!fs.existsSync(packageJsonPath)) {
      this.auditResults.categories.dependencies.issues.push('Kh√¥ng t√¨m th·∫•y package.json');
      return;
    }

    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      const requiredDeps = [
        'next',
        'react',
        'react-dom',
        'typescript',
        '@types/react',
        '@types/node'
      ];

      const recommendedDeps = [
        'tailwindcss',
        'autoprefixer',
        'postcss',
        '@headlessui/react',
        '@heroicons/react',
        'zustand',
        'axios',
        'react-query',
        'framer-motion',
        'recharts',
        'date-fns',
        'clsx',
        'class-variance-authority'
      ];

      // Ki·ªÉm tra dependencies b·∫Øt bu·ªôc
      for (const dep of requiredDeps) {
        if (packageJson.dependencies?.[dep] || packageJson.devDependencies?.[dep]) {
          this.auditResults.categories.dependencies.completed.push(`‚úÖ ${dep} ƒë√£ c√†i ƒë·∫∑t`);
        } else {
          this.auditResults.categories.dependencies.missing.push(`‚ùå ${dep} ch∆∞a c√†i ƒë·∫∑t`);
          this.auditResults.categories.dependencies.issues.push(`Thi·∫øu dependency: ${dep}`);
        }
      }

      // Ki·ªÉm tra dependencies khuy·∫øn ngh·ªã
      let recommendedCount = 0;
      for (const dep of recommendedDeps) {
        if (packageJson.dependencies?.[dep] || packageJson.devDependencies?.[dep]) {
          this.auditResults.categories.dependencies.completed.push(`‚úÖ ${dep} ƒë√£ c√†i ƒë·∫∑t`);
          recommendedCount++;
        }
      }

      // T√≠nh ƒëi·ªÉm
      const requiredScore = (this.auditResults.categories.dependencies.completed.length - recommendedCount) / requiredDeps.length * 60;
      const recommendedScore = (recommendedCount / recommendedDeps.length) * 40;
      this.auditResults.categories.dependencies.score = Math.round(requiredScore + recommendedScore);

    } catch (error) {
      this.auditResults.categories.dependencies.issues.push(`L·ªói ƒë·ªçc package.json: ${error.message}`);
    }
  }

  async checkComponents() {
    console.log('üß© Ki·ªÉm tra components...');
    
    const componentsPath = path.join(this.dashboardPath, 'components');
    
    this.auditResults.categories.components = {
      score: 0,
      issues: [],
      completed: [],
      missing: []
    };

    if (!fs.existsSync(componentsPath)) {
      this.auditResults.categories.components.issues.push('Th∆∞ m·ª•c components kh√¥ng t·ªìn t·∫°i');
      return;
    }

    const requiredComponents = [
      'ui/button.tsx',
      'ui/input.tsx',
      'ui/card.tsx',
      'ui/table.tsx',
      'ui/modal.tsx',
      'layout/header.tsx',
      'layout/sidebar.tsx',
      'layout/footer.tsx',
      'charts/line-chart.tsx',
      'charts/bar-chart.tsx',
      'forms/login-form.tsx',
      'forms/register-form.tsx'
    ];

    let componentCount = 0;
    for (const component of requiredComponents) {
      const componentPath = path.join(componentsPath, component);
      if (fs.existsSync(componentPath)) {
        this.auditResults.categories.components.completed.push(`‚úÖ ${component} t·ªìn t·∫°i`);
        componentCount++;
      } else {
        this.auditResults.categories.components.missing.push(`‚ùå ${component} thi·∫øu`);
        this.auditResults.categories.components.issues.push(`Thi·∫øu component: ${component}`);
      }
    }

    // T√≠nh ƒëi·ªÉm
    this.auditResults.categories.components.score = Math.round((componentCount / requiredComponents.length) * 100);
  }

  async checkPages() {
    console.log('üìÑ Ki·ªÉm tra pages...');
    
    const appPath = path.join(this.dashboardPath, 'app');
    
    this.auditResults.categories.pages = {
      score: 0,
      issues: [],
      completed: [],
      missing: []
    };

    if (!fs.existsSync(appPath)) {
      this.auditResults.categories.pages.issues.push('Th∆∞ m·ª•c app kh√¥ng t·ªìn t·∫°i');
      return;
    }

    const requiredPages = [
      'page.tsx',
      'layout.tsx',
      'login/page.tsx',
      'dashboard/page.tsx',
      'users/page.tsx',
      'settings/page.tsx',
      'analytics/page.tsx'
    ];

    let pageCount = 0;
    for (const page of requiredPages) {
      const pagePath = path.join(appPath, page);
      if (fs.existsSync(pagePath)) {
        this.auditResults.categories.pages.completed.push(`‚úÖ ${page} t·ªìn t·∫°i`);
        pageCount++;
      } else {
        this.auditResults.categories.pages.missing.push(`‚ùå ${page} thi·∫øu`);
        this.auditResults.categories.pages.issues.push(`Thi·∫øu page: ${page}`);
      }
    }

    // T√≠nh ƒëi·ªÉm
    this.auditResults.categories.pages.score = Math.round((pageCount / requiredPages.length) * 100);
  }

  async checkConfiguration() {
    console.log('‚öôÔ∏è Ki·ªÉm tra configuration...');
    
    this.auditResults.categories.configuration = {
      score: 0,
      issues: [],
      completed: [],
      missing: []
    };

    const configFiles = [
      'tsconfig.json',
      'tailwind.config.js',
      'next.config.js',
      'postcss.config.js',
      'eslint.config.js'
    ];

    let configCount = 0;
    for (const config of configFiles) {
      const configPath = path.join(this.dashboardPath, config);
      if (fs.existsSync(configPath)) {
        this.auditResults.categories.configuration.completed.push(`‚úÖ ${config} t·ªìn t·∫°i`);
        configCount++;
      } else {
        this.auditResults.categories.configuration.missing.push(`‚ùå ${config} thi·∫øu`);
        this.auditResults.categories.configuration.issues.push(`Thi·∫øu config: ${config}`);
      }
    }

    // T√≠nh ƒëi·ªÉm
    this.auditResults.categories.configuration.score = Math.round((configCount / configFiles.length) * 100);
  }

  async checkTesting() {
    console.log('üß™ Ki·ªÉm tra testing setup...');
    
    this.auditResults.categories.testing = {
      score: 0,
      issues: [],
      completed: [],
      missing: []
    };

    const testFiles = [
      'jest.config.js',
      'jest.setup.js',
      '__tests__/components/',
      '__tests__/pages/',
      '__tests__/utils/'
    ];

    let testCount = 0;
    for (const test of testFiles) {
      const testPath = path.join(this.dashboardPath, test);
      if (fs.existsSync(testPath)) {
        this.auditResults.categories.testing.completed.push(`‚úÖ ${test} t·ªìn t·∫°i`);
        testCount++;
      } else {
        this.auditResults.categories.testing.missing.push(`‚ùå ${test} thi·∫øu`);
        this.auditResults.categories.testing.issues.push(`Thi·∫øu test: ${test}`);
      }
    }

    // T√≠nh ƒëi·ªÉm
    this.auditResults.categories.testing.score = Math.round((testCount / testFiles.length) * 100);
  }

  async checkDocumentation() {
    console.log('üìö Ki·ªÉm tra documentation...');
    
    this.auditResults.categories.documentation = {
      score: 0,
      issues: [],
      completed: [],
      missing: []
    };

    const docFiles = [
      'README.md',
      'CONTRIBUTING.md',
      'CHANGELOG.md',
      'docs/',
      'API.md'
    ];

    let docCount = 0;
    for (const doc of docFiles) {
      const docPath = path.join(this.dashboardPath, doc);
      if (fs.existsSync(docPath)) {
        this.auditResults.categories.documentation.completed.push(`‚úÖ ${doc} t·ªìn t·∫°i`);
        docCount++;
      } else {
        this.auditResults.categories.documentation.missing.push(`‚ùå ${doc} thi·∫øu`);
        this.auditResults.categories.documentation.issues.push(`Thi·∫øu documentation: ${doc}`);
      }
    }

    // T√≠nh ƒëi·ªÉm
    this.auditResults.categories.documentation.score = Math.round((docCount / docFiles.length) * 100);
  }

  async calculateScore() {
    const categories = Object.values(this.auditResults.categories);
    const totalScore = categories.reduce((sum, category) => sum + category.score, 0);
    this.auditResults.overallScore = Math.round(totalScore / categories.length);

    // T·∫°o recommendations
    this.generateRecommendations();
  }

  generateRecommendations() {
    const recommendations = [];

    if (this.auditResults.categories.structure.score < 80) {
      recommendations.push('üîß C·∫ßn c·∫£i thi·ªán c·∫•u tr√∫c project - t·∫°o c√°c th∆∞ m·ª•c v√† file c√≤n thi·∫øu');
    }

    if (this.auditResults.categories.dependencies.score < 70) {
      recommendations.push('üì¶ C·∫ßn c√†i ƒë·∫∑t th√™m dependencies quan tr·ªçng');
    }

    if (this.auditResults.categories.components.score < 60) {
      recommendations.push('üß© C·∫ßn ph√°t tri·ªÉn th√™m c√°c components c∆° b·∫£n');
    }

    if (this.auditResults.categories.pages.score < 50) {
      recommendations.push('üìÑ C·∫ßn t·∫°o c√°c pages ch√≠nh cho dashboard');
    }

    if (this.auditResults.categories.testing.score < 40) {
      recommendations.push('üß™ C·∫ßn setup testing framework v√† vi·∫øt tests');
    }

    if (this.auditResults.categories.documentation.score < 30) {
      recommendations.push('üìö C·∫ßn c·∫£i thi·ªán documentation');
    }

    this.auditResults.recommendations = recommendations;
  }

  async generateReport() {
    const report = `# üìä DASHBOARD AUDIT REPORT
## B√°o c√°o ki·ªÉm tra Dashboard AudioTailoc

**Ng√†y audit:** ${new Date().toLocaleDateString('vi-VN')}  
**Th·ªùi gian:** ${new Date().toLocaleTimeString('vi-VN')}  
**ƒêi·ªÉm t·ªïng th·ªÉ:** ${this.auditResults.overallScore}/100

---

## üìà K·∫æT QU·∫¢ CHI TI·∫æT

### üèóÔ∏è C·∫•u tr√∫c Project: ${this.auditResults.categories.structure.score}/100

**‚úÖ ƒê√£ ho√†n th√†nh:**
${this.auditResults.categories.structure.completed.map(item => `- ${item}`).join('\n')}

**‚ùå C√≤n thi·∫øu:**
${this.auditResults.categories.structure.missing.map(item => `- ${item}`).join('\n')}

### üì¶ Dependencies: ${this.auditResults.categories.dependencies.score}/100

**‚úÖ ƒê√£ ho√†n th√†nh:**
${this.auditResults.categories.dependencies.completed.map(item => `- ${item}`).join('\n')}

**‚ùå C√≤n thi·∫øu:**
${this.auditResults.categories.dependencies.missing.map(item => `- ${item}`).join('\n')}

### üß© Components: ${this.auditResults.categories.components.score}/100

**‚úÖ ƒê√£ ho√†n th√†nh:**
${this.auditResults.categories.components.completed.map(item => `- ${item}`).join('\n')}

**‚ùå C√≤n thi·∫øu:**
${this.auditResults.categories.components.missing.map(item => `- ${item}`).join('\n')}

### üìÑ Pages: ${this.auditResults.categories.pages.score}/100

**‚úÖ ƒê√£ ho√†n th√†nh:**
${this.auditResults.categories.pages.completed.map(item => `- ${item}`).join('\n')}

**‚ùå C√≤n thi·∫øu:**
${this.auditResults.categories.pages.missing.map(item => `- ${item}`).join('\n')}

### ‚öôÔ∏è Configuration: ${this.auditResults.categories.configuration.score}/100

**‚úÖ ƒê√£ ho√†n th√†nh:**
${this.auditResults.categories.configuration.completed.map(item => `- ${item}`).join('\n')}

**‚ùå C√≤n thi·∫øu:**
${this.auditResults.categories.configuration.missing.map(item => `- ${item}`).join('\n')}

### üß™ Testing: ${this.auditResults.categories.testing.score}/100

**‚úÖ ƒê√£ ho√†n th√†nh:**
${this.auditResults.categories.testing.completed.map(item => `- ${item}`).join('\n')}

**‚ùå C√≤n thi·∫øu:**
${this.auditResults.categories.testing.missing.map(item => `- ${item}`).join('\n')}

### üìö Documentation: ${this.auditResults.categories.documentation.score}/100

**‚úÖ ƒê√£ ho√†n th√†nh:**
${this.auditResults.categories.documentation.completed.map(item => `- ${item}`).join('\n')}

**‚ùå C√≤n thi·∫øu:**
${this.auditResults.categories.documentation.missing.map(item => `- ${item}`).join('\n')}

---

## üéØ KHUY·∫æN NGH·ªä

${this.auditResults.recommendations.map(rec => `- ${rec}`).join('\n')}

---

## üìã TODO LIST ∆ØU TI√äN

### üî¥ ∆Øu ti√™n cao (Tu·∫ßn 1-2)
${this.getHighPriorityTasks()}

### üü° ∆Øu ti√™n trung b√¨nh (Tu·∫ßn 3-4)
${this.getMediumPriorityTasks()}

### üü¢ ∆Øu ti√™n th·∫•p (Tu·∫ßn 5-6)
${this.getLowPriorityTasks()}

---

## üìä TH·ªêNG K√ä

- **T·ªïng s·ªë v·∫•n ƒë·ªÅ:** ${this.getTotalIssues()}
- **T·ªïng s·ªë tasks ho√†n th√†nh:** ${this.getTotalCompleted()}
- **T·ªïng s·ªë tasks c√≤n l·∫°i:** ${this.getTotalPending()}
- **T·ª∑ l·ªá ho√†n th√†nh:** ${Math.round((this.getTotalCompleted() / (this.getTotalCompleted() + this.getTotalPending())) * 100)}%

---

## üöÄ B∆Ø·ªöC TI·∫æP THEO

1. **Tu·∫ßn 1:** T·∫≠p trung v√†o c·∫•u tr√∫c project v√† dependencies
2. **Tu·∫ßn 2:** Ph√°t tri·ªÉn components v√† pages c∆° b·∫£n
3. **Tu·∫ßn 3:** Setup testing v√† configuration
4. **Tu·∫ßn 4:** C·∫£i thi·ªán documentation v√† optimization
5. **Tu·∫ßn 5-6:** Testing to√†n di·ªán v√† deployment

---

*B√°o c√°o ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông b·ªüi Dashboard Auditor Script*  
*C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: ${new Date().toISOString()}*
`;

    fs.writeFileSync(this.reportPath, report, 'utf8');
  }

  getHighPriorityTasks() {
    const tasks = [];
    
    if (this.auditResults.categories.structure.score < 80) {
      tasks.push('- T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c c√≤n thi·∫øu');
    }
    
    if (this.auditResults.categories.dependencies.score < 70) {
      tasks.push('- C√†i ƒë·∫∑t dependencies c·∫ßn thi·∫øt');
    }
    
    if (this.auditResults.categories.components.score < 60) {
      tasks.push('- Ph√°t tri·ªÉn UI components c∆° b·∫£n');
    }
    
    return tasks.length > 0 ? tasks.join('\n') : '- Kh√¥ng c√≥ tasks ∆∞u ti√™n cao';
  }

  getMediumPriorityTasks() {
    const tasks = [];
    
    if (this.auditResults.categories.pages.score < 50) {
      tasks.push('- T·∫°o c√°c pages ch√≠nh');
    }
    
    if (this.auditResults.categories.configuration.score < 80) {
      tasks.push('- C·∫•u h√¨nh build tools');
    }
    
    return tasks.length > 0 ? tasks.join('\n') : '- Kh√¥ng c√≥ tasks ∆∞u ti√™n trung b√¨nh';
  }

  getLowPriorityTasks() {
    const tasks = [];
    
    if (this.auditResults.categories.testing.score < 40) {
      tasks.push('- Setup testing framework');
    }
    
    if (this.auditResults.categories.documentation.score < 30) {
      tasks.push('- C·∫£i thi·ªán documentation');
    }
    
    return tasks.length > 0 ? tasks.join('\n') : '- Kh√¥ng c√≥ tasks ∆∞u ti√™n th·∫•p';
  }

  getTotalIssues() {
    return Object.values(this.auditResults.categories)
      .reduce((sum, category) => sum + category.issues.length, 0);
  }

  getTotalCompleted() {
    return Object.values(this.auditResults.categories)
      .reduce((sum, category) => sum + category.completed.length, 0);
  }

  getTotalPending() {
    return Object.values(this.auditResults.categories)
      .reduce((sum, category) => sum + category.missing.length, 0);
  }
}

// Ch·∫°y audit
if (require.main === module) {
  const auditor = new DashboardAuditor();
  auditor.runAudit();
}

module.exports = DashboardAuditor;
