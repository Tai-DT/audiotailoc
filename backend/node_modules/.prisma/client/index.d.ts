
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Refund
 * 
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>
/**
 * Model ServiceType
 * 
 */
export type ServiceType = $Result.DefaultSelection<Prisma.$ServiceTypePayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model InventoryAlert
 * 
 */
export type InventoryAlert = $Result.DefaultSelection<Prisma.$InventoryAlertPayload>
/**
 * Model InventoryReport
 * 
 */
export type InventoryReport = $Result.DefaultSelection<Prisma.$InventoryReportPayload>
/**
 * Model WishlistItem
 * 
 */
export type WishlistItem = $Result.DefaultSelection<Prisma.$WishlistItemPayload>
/**
 * Model ProductReview
 * 
 */
export type ProductReview = $Result.DefaultSelection<Prisma.$ProductReviewPayload>
/**
 * Model ProductReviewVote
 * 
 */
export type ProductReviewVote = $Result.DefaultSelection<Prisma.$ProductReviewVotePayload>
/**
 * Model ProductReviewReport
 * 
 */
export type ProductReviewReport = $Result.DefaultSelection<Prisma.$ProductReviewReportPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model SearchQuery
 * 
 */
export type SearchQuery = $Result.DefaultSelection<Prisma.$SearchQueryPayload>
/**
 * Model ProductView
 * 
 */
export type ProductView = $Result.DefaultSelection<Prisma.$ProductViewPayload>
/**
 * Model ServiceView
 * 
 */
export type ServiceView = $Result.DefaultSelection<Prisma.$ServiceViewPayload>
/**
 * Model CustomerQuestion
 * 
 */
export type CustomerQuestion = $Result.DefaultSelection<Prisma.$CustomerQuestionPayload>
/**
 * Model Technician
 * 
 */
export type Technician = $Result.DefaultSelection<Prisma.$TechnicianPayload>
/**
 * Model ServiceItem
 * 
 */
export type ServiceItem = $Result.DefaultSelection<Prisma.$ServiceItemPayload>
/**
 * Model ServiceBooking
 * 
 */
export type ServiceBooking = $Result.DefaultSelection<Prisma.$ServiceBookingPayload>
/**
 * Model ServiceBookingItem
 * 
 */
export type ServiceBookingItem = $Result.DefaultSelection<Prisma.$ServiceBookingItemPayload>
/**
 * Model TechnicianSchedule
 * 
 */
export type TechnicianSchedule = $Result.DefaultSelection<Prisma.$TechnicianSchedulePayload>
/**
 * Model ServiceStatusHistory
 * 
 */
export type ServiceStatusHistory = $Result.DefaultSelection<Prisma.$ServiceStatusHistoryPayload>
/**
 * Model ServicePayment
 * 
 */
export type ServicePayment = $Result.DefaultSelection<Prisma.$ServicePaymentPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model LoyaltyAccount
 * 
 */
export type LoyaltyAccount = $Result.DefaultSelection<Prisma.$LoyaltyAccountPayload>
/**
 * Model PointTransaction
 * 
 */
export type PointTransaction = $Result.DefaultSelection<Prisma.$PointTransactionPayload>
/**
 * Model RedemptionHistory
 * 
 */
export type RedemptionHistory = $Result.DefaultSelection<Prisma.$RedemptionHistoryPayload>
/**
 * Model LoyaltyReward
 * 
 */
export type LoyaltyReward = $Result.DefaultSelection<Prisma.$LoyaltyRewardPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model KnowledgeBaseEntry
 * 
 */
export type KnowledgeBaseEntry = $Result.DefaultSelection<Prisma.$KnowledgeBaseEntryPayload>
/**
 * Model PaymentIntent
 * 
 */
export type PaymentIntent = $Result.DefaultSelection<Prisma.$PaymentIntentPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignRecipient
 * 
 */
export type CampaignRecipient = $Result.DefaultSelection<Prisma.$CampaignRecipientPayload>
/**
 * Model CampaignOpen
 * 
 */
export type CampaignOpen = $Result.DefaultSelection<Prisma.$CampaignOpenPayload>
/**
 * Model CampaignClick
 * 
 */
export type CampaignClick = $Result.DefaultSelection<Prisma.$CampaignClickPayload>
/**
 * Model EmailLog
 * 
 */
export type EmailLog = $Result.DefaultSelection<Prisma.$EmailLogPayload>
/**
 * Model contact_messages
 * 
 */
export type contact_messages = $Result.DefaultSelection<Prisma.$contact_messagesPayload>
/**
 * Model site_settings
 * 
 */
export type site_settings = $Result.DefaultSelection<Prisma.$site_settingsPayload>
/**
 * Model software
 * 
 */
export type software = $Result.DefaultSelection<Prisma.$softwarePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ReviewStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const CampaignType: {
  PROMOTIONAL: 'PROMOTIONAL',
  NEWSLETTER: 'NEWSLETTER',
  PRODUCT_UPDATE: 'PRODUCT_UPDATE',
  WELCOME: 'WELCOME',
  ABANDONED_CART: 'ABANDONED_CART',
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  PUSH: 'PUSH',
  SOCIAL: 'SOCIAL'
};

export type CampaignType = (typeof CampaignType)[keyof typeof CampaignType]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  SENT: 'SENT',
  CANCELLED: 'CANCELLED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]

}

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type CampaignType = $Enums.CampaignType

export const CampaignType: typeof $Enums.CampaignType

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.RefundDelegate<ExtArgs>;

  /**
   * `prisma.serviceType`: Exposes CRUD operations for the **ServiceType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTypes
    * const serviceTypes = await prisma.serviceType.findMany()
    * ```
    */
  get serviceType(): Prisma.ServiceTypeDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs>;

  /**
   * `prisma.inventoryAlert`: Exposes CRUD operations for the **InventoryAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryAlerts
    * const inventoryAlerts = await prisma.inventoryAlert.findMany()
    * ```
    */
  get inventoryAlert(): Prisma.InventoryAlertDelegate<ExtArgs>;

  /**
   * `prisma.inventoryReport`: Exposes CRUD operations for the **InventoryReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryReports
    * const inventoryReports = await prisma.inventoryReport.findMany()
    * ```
    */
  get inventoryReport(): Prisma.InventoryReportDelegate<ExtArgs>;

  /**
   * `prisma.wishlistItem`: Exposes CRUD operations for the **WishlistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistItems
    * const wishlistItems = await prisma.wishlistItem.findMany()
    * ```
    */
  get wishlistItem(): Prisma.WishlistItemDelegate<ExtArgs>;

  /**
   * `prisma.productReview`: Exposes CRUD operations for the **ProductReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductReviews
    * const productReviews = await prisma.productReview.findMany()
    * ```
    */
  get productReview(): Prisma.ProductReviewDelegate<ExtArgs>;

  /**
   * `prisma.productReviewVote`: Exposes CRUD operations for the **ProductReviewVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductReviewVotes
    * const productReviewVotes = await prisma.productReviewVote.findMany()
    * ```
    */
  get productReviewVote(): Prisma.ProductReviewVoteDelegate<ExtArgs>;

  /**
   * `prisma.productReviewReport`: Exposes CRUD operations for the **ProductReviewReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductReviewReports
    * const productReviewReports = await prisma.productReviewReport.findMany()
    * ```
    */
  get productReviewReport(): Prisma.ProductReviewReportDelegate<ExtArgs>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs>;

  /**
   * `prisma.searchQuery`: Exposes CRUD operations for the **SearchQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchQueries
    * const searchQueries = await prisma.searchQuery.findMany()
    * ```
    */
  get searchQuery(): Prisma.SearchQueryDelegate<ExtArgs>;

  /**
   * `prisma.productView`: Exposes CRUD operations for the **ProductView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductViews
    * const productViews = await prisma.productView.findMany()
    * ```
    */
  get productView(): Prisma.ProductViewDelegate<ExtArgs>;

  /**
   * `prisma.serviceView`: Exposes CRUD operations for the **ServiceView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceViews
    * const serviceViews = await prisma.serviceView.findMany()
    * ```
    */
  get serviceView(): Prisma.ServiceViewDelegate<ExtArgs>;

  /**
   * `prisma.customerQuestion`: Exposes CRUD operations for the **CustomerQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerQuestions
    * const customerQuestions = await prisma.customerQuestion.findMany()
    * ```
    */
  get customerQuestion(): Prisma.CustomerQuestionDelegate<ExtArgs>;

  /**
   * `prisma.technician`: Exposes CRUD operations for the **Technician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Technicians
    * const technicians = await prisma.technician.findMany()
    * ```
    */
  get technician(): Prisma.TechnicianDelegate<ExtArgs>;

  /**
   * `prisma.serviceItem`: Exposes CRUD operations for the **ServiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceItems
    * const serviceItems = await prisma.serviceItem.findMany()
    * ```
    */
  get serviceItem(): Prisma.ServiceItemDelegate<ExtArgs>;

  /**
   * `prisma.serviceBooking`: Exposes CRUD operations for the **ServiceBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceBookings
    * const serviceBookings = await prisma.serviceBooking.findMany()
    * ```
    */
  get serviceBooking(): Prisma.ServiceBookingDelegate<ExtArgs>;

  /**
   * `prisma.serviceBookingItem`: Exposes CRUD operations for the **ServiceBookingItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceBookingItems
    * const serviceBookingItems = await prisma.serviceBookingItem.findMany()
    * ```
    */
  get serviceBookingItem(): Prisma.ServiceBookingItemDelegate<ExtArgs>;

  /**
   * `prisma.technicianSchedule`: Exposes CRUD operations for the **TechnicianSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicianSchedules
    * const technicianSchedules = await prisma.technicianSchedule.findMany()
    * ```
    */
  get technicianSchedule(): Prisma.TechnicianScheduleDelegate<ExtArgs>;

  /**
   * `prisma.serviceStatusHistory`: Exposes CRUD operations for the **ServiceStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceStatusHistories
    * const serviceStatusHistories = await prisma.serviceStatusHistory.findMany()
    * ```
    */
  get serviceStatusHistory(): Prisma.ServiceStatusHistoryDelegate<ExtArgs>;

  /**
   * `prisma.servicePayment`: Exposes CRUD operations for the **ServicePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePayments
    * const servicePayments = await prisma.servicePayment.findMany()
    * ```
    */
  get servicePayment(): Prisma.ServicePaymentDelegate<ExtArgs>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs>;

  /**
   * `prisma.loyaltyAccount`: Exposes CRUD operations for the **LoyaltyAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyAccounts
    * const loyaltyAccounts = await prisma.loyaltyAccount.findMany()
    * ```
    */
  get loyaltyAccount(): Prisma.LoyaltyAccountDelegate<ExtArgs>;

  /**
   * `prisma.pointTransaction`: Exposes CRUD operations for the **PointTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointTransactions
    * const pointTransactions = await prisma.pointTransaction.findMany()
    * ```
    */
  get pointTransaction(): Prisma.PointTransactionDelegate<ExtArgs>;

  /**
   * `prisma.redemptionHistory`: Exposes CRUD operations for the **RedemptionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RedemptionHistories
    * const redemptionHistories = await prisma.redemptionHistory.findMany()
    * ```
    */
  get redemptionHistory(): Prisma.RedemptionHistoryDelegate<ExtArgs>;

  /**
   * `prisma.loyaltyReward`: Exposes CRUD operations for the **LoyaltyReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyRewards
    * const loyaltyRewards = await prisma.loyaltyReward.findMany()
    * ```
    */
  get loyaltyReward(): Prisma.LoyaltyRewardDelegate<ExtArgs>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeBaseEntry`: Exposes CRUD operations for the **KnowledgeBaseEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBaseEntries
    * const knowledgeBaseEntries = await prisma.knowledgeBaseEntry.findMany()
    * ```
    */
  get knowledgeBaseEntry(): Prisma.KnowledgeBaseEntryDelegate<ExtArgs>;

  /**
   * `prisma.paymentIntent`: Exposes CRUD operations for the **PaymentIntent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentIntents
    * const paymentIntents = await prisma.paymentIntent.findMany()
    * ```
    */
  get paymentIntent(): Prisma.PaymentIntentDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignRecipient`: Exposes CRUD operations for the **CampaignRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignRecipients
    * const campaignRecipients = await prisma.campaignRecipient.findMany()
    * ```
    */
  get campaignRecipient(): Prisma.CampaignRecipientDelegate<ExtArgs>;

  /**
   * `prisma.campaignOpen`: Exposes CRUD operations for the **CampaignOpen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignOpens
    * const campaignOpens = await prisma.campaignOpen.findMany()
    * ```
    */
  get campaignOpen(): Prisma.CampaignOpenDelegate<ExtArgs>;

  /**
   * `prisma.campaignClick`: Exposes CRUD operations for the **CampaignClick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignClicks
    * const campaignClicks = await prisma.campaignClick.findMany()
    * ```
    */
  get campaignClick(): Prisma.CampaignClickDelegate<ExtArgs>;

  /**
   * `prisma.emailLog`: Exposes CRUD operations for the **EmailLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLogs
    * const emailLogs = await prisma.emailLog.findMany()
    * ```
    */
  get emailLog(): Prisma.EmailLogDelegate<ExtArgs>;

  /**
   * `prisma.contact_messages`: Exposes CRUD operations for the **contact_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_messages
    * const contact_messages = await prisma.contact_messages.findMany()
    * ```
    */
  get contact_messages(): Prisma.contact_messagesDelegate<ExtArgs>;

  /**
   * `prisma.site_settings`: Exposes CRUD operations for the **site_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Site_settings
    * const site_settings = await prisma.site_settings.findMany()
    * ```
    */
  get site_settings(): Prisma.site_settingsDelegate<ExtArgs>;

  /**
   * `prisma.software`: Exposes CRUD operations for the **software** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Software
    * const software = await prisma.software.findMany()
    * ```
    */
  get software(): Prisma.softwareDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Product: 'Product',
    Category: 'Category',
    Cart: 'Cart',
    CartItem: 'CartItem',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Payment: 'Payment',
    Refund: 'Refund',
    ServiceType: 'ServiceType',
    Service: 'Service',
    Notification: 'Notification',
    Inventory: 'Inventory',
    InventoryMovement: 'InventoryMovement',
    InventoryAlert: 'InventoryAlert',
    InventoryReport: 'InventoryReport',
    WishlistItem: 'WishlistItem',
    ProductReview: 'ProductReview',
    ProductReviewVote: 'ProductReviewVote',
    ProductReviewReport: 'ProductReviewReport',
    Page: 'Page',
    SearchQuery: 'SearchQuery',
    ProductView: 'ProductView',
    ServiceView: 'ServiceView',
    CustomerQuestion: 'CustomerQuestion',
    Technician: 'Technician',
    ServiceItem: 'ServiceItem',
    ServiceBooking: 'ServiceBooking',
    ServiceBookingItem: 'ServiceBookingItem',
    TechnicianSchedule: 'TechnicianSchedule',
    ServiceStatusHistory: 'ServiceStatusHistory',
    ServicePayment: 'ServicePayment',
    Promotion: 'Promotion',
    Banner: 'Banner',
    SystemConfig: 'SystemConfig',
    LoyaltyAccount: 'LoyaltyAccount',
    PointTransaction: 'PointTransaction',
    RedemptionHistory: 'RedemptionHistory',
    LoyaltyReward: 'LoyaltyReward',
    Webhook: 'Webhook',
    KnowledgeBaseEntry: 'KnowledgeBaseEntry',
    PaymentIntent: 'PaymentIntent',
    Project: 'Project',
    ActivityLog: 'ActivityLog',
    Campaign: 'Campaign',
    CampaignRecipient: 'CampaignRecipient',
    CampaignOpen: 'CampaignOpen',
    CampaignClick: 'CampaignClick',
    EmailLog: 'EmailLog',
    contact_messages: 'contact_messages',
    site_settings: 'site_settings',
    software: 'software'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "product" | "category" | "cart" | "cartItem" | "order" | "orderItem" | "payment" | "refund" | "serviceType" | "service" | "notification" | "inventory" | "inventoryMovement" | "inventoryAlert" | "inventoryReport" | "wishlistItem" | "productReview" | "productReviewVote" | "productReviewReport" | "page" | "searchQuery" | "productView" | "serviceView" | "customerQuestion" | "technician" | "serviceItem" | "serviceBooking" | "serviceBookingItem" | "technicianSchedule" | "serviceStatusHistory" | "servicePayment" | "promotion" | "banner" | "systemConfig" | "loyaltyAccount" | "pointTransaction" | "redemptionHistory" | "loyaltyReward" | "webhook" | "knowledgeBaseEntry" | "paymentIntent" | "project" | "activityLog" | "campaign" | "campaignRecipient" | "campaignOpen" | "campaignClick" | "emailLog" | "contact_messages" | "site_settings" | "software"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>
        fields: Prisma.RefundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      ServiceType: {
        payload: Prisma.$ServiceTypePayload<ExtArgs>
        fields: Prisma.ServiceTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>
          }
          findFirst: {
            args: Prisma.ServiceTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>
          }
          findMany: {
            args: Prisma.ServiceTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>[]
          }
          create: {
            args: Prisma.ServiceTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>
          }
          createMany: {
            args: Prisma.ServiceTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>[]
          }
          delete: {
            args: Prisma.ServiceTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>
          }
          update: {
            args: Prisma.ServiceTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>
          }
          deleteMany: {
            args: Prisma.ServiceTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTypePayload>
          }
          aggregate: {
            args: Prisma.ServiceTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceType>
          }
          groupBy: {
            args: Prisma.ServiceTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceTypeCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      InventoryAlert: {
        payload: Prisma.$InventoryAlertPayload<ExtArgs>
        fields: Prisma.InventoryAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>
          }
          findFirst: {
            args: Prisma.InventoryAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>
          }
          findMany: {
            args: Prisma.InventoryAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>[]
          }
          create: {
            args: Prisma.InventoryAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>
          }
          createMany: {
            args: Prisma.InventoryAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>[]
          }
          delete: {
            args: Prisma.InventoryAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>
          }
          update: {
            args: Prisma.InventoryAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>
          }
          deleteMany: {
            args: Prisma.InventoryAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAlertPayload>
          }
          aggregate: {
            args: Prisma.InventoryAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryAlert>
          }
          groupBy: {
            args: Prisma.InventoryAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryAlertCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryAlertCountAggregateOutputType> | number
          }
        }
      }
      InventoryReport: {
        payload: Prisma.$InventoryReportPayload<ExtArgs>
        fields: Prisma.InventoryReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>
          }
          findFirst: {
            args: Prisma.InventoryReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>
          }
          findMany: {
            args: Prisma.InventoryReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>[]
          }
          create: {
            args: Prisma.InventoryReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>
          }
          createMany: {
            args: Prisma.InventoryReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>[]
          }
          delete: {
            args: Prisma.InventoryReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>
          }
          update: {
            args: Prisma.InventoryReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>
          }
          deleteMany: {
            args: Prisma.InventoryReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryReportPayload>
          }
          aggregate: {
            args: Prisma.InventoryReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryReport>
          }
          groupBy: {
            args: Prisma.InventoryReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryReportCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryReportCountAggregateOutputType> | number
          }
        }
      }
      WishlistItem: {
        payload: Prisma.$WishlistItemPayload<ExtArgs>
        fields: Prisma.WishlistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findFirst: {
            args: Prisma.WishlistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findMany: {
            args: Prisma.WishlistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          create: {
            args: Prisma.WishlistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          createMany: {
            args: Prisma.WishlistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishlistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          delete: {
            args: Prisma.WishlistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          update: {
            args: Prisma.WishlistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          deleteMany: {
            args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WishlistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          aggregate: {
            args: Prisma.WishlistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlistItem>
          }
          groupBy: {
            args: Prisma.WishlistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistItemCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemCountAggregateOutputType> | number
          }
        }
      }
      ProductReview: {
        payload: Prisma.$ProductReviewPayload<ExtArgs>
        fields: Prisma.ProductReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          findFirst: {
            args: Prisma.ProductReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          findMany: {
            args: Prisma.ProductReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>[]
          }
          create: {
            args: Prisma.ProductReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          createMany: {
            args: Prisma.ProductReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>[]
          }
          delete: {
            args: Prisma.ProductReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          update: {
            args: Prisma.ProductReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          deleteMany: {
            args: Prisma.ProductReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          aggregate: {
            args: Prisma.ProductReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductReview>
          }
          groupBy: {
            args: Prisma.ProductReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewCountAggregateOutputType> | number
          }
        }
      }
      ProductReviewVote: {
        payload: Prisma.$ProductReviewVotePayload<ExtArgs>
        fields: Prisma.ProductReviewVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductReviewVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductReviewVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>
          }
          findFirst: {
            args: Prisma.ProductReviewVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductReviewVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>
          }
          findMany: {
            args: Prisma.ProductReviewVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>[]
          }
          create: {
            args: Prisma.ProductReviewVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>
          }
          createMany: {
            args: Prisma.ProductReviewVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductReviewVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>[]
          }
          delete: {
            args: Prisma.ProductReviewVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>
          }
          update: {
            args: Prisma.ProductReviewVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>
          }
          deleteMany: {
            args: Prisma.ProductReviewVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductReviewVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductReviewVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewVotePayload>
          }
          aggregate: {
            args: Prisma.ProductReviewVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductReviewVote>
          }
          groupBy: {
            args: Prisma.ProductReviewVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductReviewVoteCountArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewVoteCountAggregateOutputType> | number
          }
        }
      }
      ProductReviewReport: {
        payload: Prisma.$ProductReviewReportPayload<ExtArgs>
        fields: Prisma.ProductReviewReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductReviewReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductReviewReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>
          }
          findFirst: {
            args: Prisma.ProductReviewReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductReviewReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>
          }
          findMany: {
            args: Prisma.ProductReviewReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>[]
          }
          create: {
            args: Prisma.ProductReviewReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>
          }
          createMany: {
            args: Prisma.ProductReviewReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductReviewReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>[]
          }
          delete: {
            args: Prisma.ProductReviewReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>
          }
          update: {
            args: Prisma.ProductReviewReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>
          }
          deleteMany: {
            args: Prisma.ProductReviewReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductReviewReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductReviewReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewReportPayload>
          }
          aggregate: {
            args: Prisma.ProductReviewReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductReviewReport>
          }
          groupBy: {
            args: Prisma.ProductReviewReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductReviewReportCountArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewReportCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      SearchQuery: {
        payload: Prisma.$SearchQueryPayload<ExtArgs>
        fields: Prisma.SearchQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findFirst: {
            args: Prisma.SearchQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findMany: {
            args: Prisma.SearchQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          create: {
            args: Prisma.SearchQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          createMany: {
            args: Prisma.SearchQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchQueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          delete: {
            args: Prisma.SearchQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          update: {
            args: Prisma.SearchQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          deleteMany: {
            args: Prisma.SearchQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          aggregate: {
            args: Prisma.SearchQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchQuery>
          }
          groupBy: {
            args: Prisma.SearchQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchQueryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryCountAggregateOutputType> | number
          }
        }
      }
      ProductView: {
        payload: Prisma.$ProductViewPayload<ExtArgs>
        fields: Prisma.ProductViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          findFirst: {
            args: Prisma.ProductViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          findMany: {
            args: Prisma.ProductViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>[]
          }
          create: {
            args: Prisma.ProductViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          createMany: {
            args: Prisma.ProductViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>[]
          }
          delete: {
            args: Prisma.ProductViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          update: {
            args: Prisma.ProductViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          deleteMany: {
            args: Prisma.ProductViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductViewPayload>
          }
          aggregate: {
            args: Prisma.ProductViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductView>
          }
          groupBy: {
            args: Prisma.ProductViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductViewCountArgs<ExtArgs>
            result: $Utils.Optional<ProductViewCountAggregateOutputType> | number
          }
        }
      }
      ServiceView: {
        payload: Prisma.$ServiceViewPayload<ExtArgs>
        fields: Prisma.ServiceViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>
          }
          findFirst: {
            args: Prisma.ServiceViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>
          }
          findMany: {
            args: Prisma.ServiceViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>[]
          }
          create: {
            args: Prisma.ServiceViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>
          }
          createMany: {
            args: Prisma.ServiceViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>[]
          }
          delete: {
            args: Prisma.ServiceViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>
          }
          update: {
            args: Prisma.ServiceViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>
          }
          deleteMany: {
            args: Prisma.ServiceViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceViewPayload>
          }
          aggregate: {
            args: Prisma.ServiceViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceView>
          }
          groupBy: {
            args: Prisma.ServiceViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceViewCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceViewCountAggregateOutputType> | number
          }
        }
      }
      CustomerQuestion: {
        payload: Prisma.$CustomerQuestionPayload<ExtArgs>
        fields: Prisma.CustomerQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>
          }
          findFirst: {
            args: Prisma.CustomerQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>
          }
          findMany: {
            args: Prisma.CustomerQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>[]
          }
          create: {
            args: Prisma.CustomerQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>
          }
          createMany: {
            args: Prisma.CustomerQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>[]
          }
          delete: {
            args: Prisma.CustomerQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>
          }
          update: {
            args: Prisma.CustomerQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>
          }
          deleteMany: {
            args: Prisma.CustomerQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerQuestionPayload>
          }
          aggregate: {
            args: Prisma.CustomerQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerQuestion>
          }
          groupBy: {
            args: Prisma.CustomerQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerQuestionCountAggregateOutputType> | number
          }
        }
      }
      Technician: {
        payload: Prisma.$TechnicianPayload<ExtArgs>
        fields: Prisma.TechnicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          findFirst: {
            args: Prisma.TechnicianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          findMany: {
            args: Prisma.TechnicianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>[]
          }
          create: {
            args: Prisma.TechnicianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          createMany: {
            args: Prisma.TechnicianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>[]
          }
          delete: {
            args: Prisma.TechnicianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          update: {
            args: Prisma.TechnicianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          deleteMany: {
            args: Prisma.TechnicianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TechnicianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianPayload>
          }
          aggregate: {
            args: Prisma.TechnicianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnician>
          }
          groupBy: {
            args: Prisma.TechnicianGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicianCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicianCountAggregateOutputType> | number
          }
        }
      }
      ServiceItem: {
        payload: Prisma.$ServiceItemPayload<ExtArgs>
        fields: Prisma.ServiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          findFirst: {
            args: Prisma.ServiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          findMany: {
            args: Prisma.ServiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>[]
          }
          create: {
            args: Prisma.ServiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          createMany: {
            args: Prisma.ServiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>[]
          }
          delete: {
            args: Prisma.ServiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          update: {
            args: Prisma.ServiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          deleteMany: {
            args: Prisma.ServiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          aggregate: {
            args: Prisma.ServiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceItem>
          }
          groupBy: {
            args: Prisma.ServiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceItemCountAggregateOutputType> | number
          }
        }
      }
      ServiceBooking: {
        payload: Prisma.$ServiceBookingPayload<ExtArgs>
        fields: Prisma.ServiceBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          findFirst: {
            args: Prisma.ServiceBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          findMany: {
            args: Prisma.ServiceBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>[]
          }
          create: {
            args: Prisma.ServiceBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          createMany: {
            args: Prisma.ServiceBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>[]
          }
          delete: {
            args: Prisma.ServiceBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          update: {
            args: Prisma.ServiceBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingPayload>
          }
          aggregate: {
            args: Prisma.ServiceBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceBooking>
          }
          groupBy: {
            args: Prisma.ServiceBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceBookingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceBookingCountAggregateOutputType> | number
          }
        }
      }
      ServiceBookingItem: {
        payload: Prisma.$ServiceBookingItemPayload<ExtArgs>
        fields: Prisma.ServiceBookingItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceBookingItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceBookingItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>
          }
          findFirst: {
            args: Prisma.ServiceBookingItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceBookingItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>
          }
          findMany: {
            args: Prisma.ServiceBookingItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>[]
          }
          create: {
            args: Prisma.ServiceBookingItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>
          }
          createMany: {
            args: Prisma.ServiceBookingItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceBookingItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>[]
          }
          delete: {
            args: Prisma.ServiceBookingItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>
          }
          update: {
            args: Prisma.ServiceBookingItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>
          }
          deleteMany: {
            args: Prisma.ServiceBookingItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceBookingItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceBookingItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBookingItemPayload>
          }
          aggregate: {
            args: Prisma.ServiceBookingItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceBookingItem>
          }
          groupBy: {
            args: Prisma.ServiceBookingItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceBookingItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceBookingItemCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceBookingItemCountAggregateOutputType> | number
          }
        }
      }
      TechnicianSchedule: {
        payload: Prisma.$TechnicianSchedulePayload<ExtArgs>
        fields: Prisma.TechnicianScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicianScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicianScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>
          }
          findFirst: {
            args: Prisma.TechnicianScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicianScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>
          }
          findMany: {
            args: Prisma.TechnicianScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>[]
          }
          create: {
            args: Prisma.TechnicianScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>
          }
          createMany: {
            args: Prisma.TechnicianScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicianScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>[]
          }
          delete: {
            args: Prisma.TechnicianScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>
          }
          update: {
            args: Prisma.TechnicianScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>
          }
          deleteMany: {
            args: Prisma.TechnicianScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicianScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TechnicianScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSchedulePayload>
          }
          aggregate: {
            args: Prisma.TechnicianScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicianSchedule>
          }
          groupBy: {
            args: Prisma.TechnicianScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicianScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicianScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicianScheduleCountAggregateOutputType> | number
          }
        }
      }
      ServiceStatusHistory: {
        payload: Prisma.$ServiceStatusHistoryPayload<ExtArgs>
        fields: Prisma.ServiceStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.ServiceStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.ServiceStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.ServiceStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>
          }
          update: {
            args: Prisma.ServiceStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceStatusHistory>
          }
          groupBy: {
            args: Prisma.ServiceStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      ServicePayment: {
        payload: Prisma.$ServicePaymentPayload<ExtArgs>
        fields: Prisma.ServicePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>
          }
          findFirst: {
            args: Prisma.ServicePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>
          }
          findMany: {
            args: Prisma.ServicePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>[]
          }
          create: {
            args: Prisma.ServicePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>
          }
          createMany: {
            args: Prisma.ServicePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>[]
          }
          delete: {
            args: Prisma.ServicePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>
          }
          update: {
            args: Prisma.ServicePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>
          }
          deleteMany: {
            args: Prisma.ServicePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePaymentPayload>
          }
          aggregate: {
            args: Prisma.ServicePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePayment>
          }
          groupBy: {
            args: Prisma.ServicePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePaymentCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyAccount: {
        payload: Prisma.$LoyaltyAccountPayload<ExtArgs>
        fields: Prisma.LoyaltyAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>
          }
          findMany: {
            args: Prisma.LoyaltyAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>[]
          }
          create: {
            args: Prisma.LoyaltyAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>
          }
          createMany: {
            args: Prisma.LoyaltyAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>
          }
          update: {
            args: Prisma.LoyaltyAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoyaltyAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyAccountPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyAccount>
          }
          groupBy: {
            args: Prisma.LoyaltyAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyAccountCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyAccountCountAggregateOutputType> | number
          }
        }
      }
      PointTransaction: {
        payload: Prisma.$PointTransactionPayload<ExtArgs>
        fields: Prisma.PointTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findFirst: {
            args: Prisma.PointTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findMany: {
            args: Prisma.PointTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          create: {
            args: Prisma.PointTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          createMany: {
            args: Prisma.PointTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          delete: {
            args: Prisma.PointTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          update: {
            args: Prisma.PointTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PointTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          aggregate: {
            args: Prisma.PointTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointTransaction>
          }
          groupBy: {
            args: Prisma.PointTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionCountAggregateOutputType> | number
          }
        }
      }
      RedemptionHistory: {
        payload: Prisma.$RedemptionHistoryPayload<ExtArgs>
        fields: Prisma.RedemptionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedemptionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedemptionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>
          }
          findFirst: {
            args: Prisma.RedemptionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedemptionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>
          }
          findMany: {
            args: Prisma.RedemptionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>[]
          }
          create: {
            args: Prisma.RedemptionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>
          }
          createMany: {
            args: Prisma.RedemptionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedemptionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>[]
          }
          delete: {
            args: Prisma.RedemptionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>
          }
          update: {
            args: Prisma.RedemptionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.RedemptionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedemptionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RedemptionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedemptionHistoryPayload>
          }
          aggregate: {
            args: Prisma.RedemptionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedemptionHistory>
          }
          groupBy: {
            args: Prisma.RedemptionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedemptionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedemptionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<RedemptionHistoryCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyReward: {
        payload: Prisma.$LoyaltyRewardPayload<ExtArgs>
        fields: Prisma.LoyaltyRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>
          }
          findMany: {
            args: Prisma.LoyaltyRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>[]
          }
          create: {
            args: Prisma.LoyaltyRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>
          }
          createMany: {
            args: Prisma.LoyaltyRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>
          }
          update: {
            args: Prisma.LoyaltyRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoyaltyRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyRewardPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyReward>
          }
          groupBy: {
            args: Prisma.LoyaltyRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyRewardCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyRewardCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBaseEntry: {
        payload: Prisma.$KnowledgeBaseEntryPayload<ExtArgs>
        fields: Prisma.KnowledgeBaseEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeBaseEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeBaseEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          update: {
            args: Prisma.KnowledgeBaseEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeBaseEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseEntryPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBaseEntry>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseEntryCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseEntryCountAggregateOutputType> | number
          }
        }
      }
      PaymentIntent: {
        payload: Prisma.$PaymentIntentPayload<ExtArgs>
        fields: Prisma.PaymentIntentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentIntentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentIntentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          findFirst: {
            args: Prisma.PaymentIntentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentIntentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          findMany: {
            args: Prisma.PaymentIntentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
          }
          create: {
            args: Prisma.PaymentIntentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          createMany: {
            args: Prisma.PaymentIntentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentIntentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
          }
          delete: {
            args: Prisma.PaymentIntentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          update: {
            args: Prisma.PaymentIntentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentIntentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentIntentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentIntentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          aggregate: {
            args: Prisma.PaymentIntentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentIntent>
          }
          groupBy: {
            args: Prisma.PaymentIntentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentIntentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentIntentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentIntentCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignRecipient: {
        payload: Prisma.$CampaignRecipientPayload<ExtArgs>
        fields: Prisma.CampaignRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          findFirst: {
            args: Prisma.CampaignRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          findMany: {
            args: Prisma.CampaignRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>[]
          }
          create: {
            args: Prisma.CampaignRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          createMany: {
            args: Prisma.CampaignRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>[]
          }
          delete: {
            args: Prisma.CampaignRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          update: {
            args: Prisma.CampaignRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          deleteMany: {
            args: Prisma.CampaignRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignRecipientPayload>
          }
          aggregate: {
            args: Prisma.CampaignRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignRecipient>
          }
          groupBy: {
            args: Prisma.CampaignRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignRecipientCountAggregateOutputType> | number
          }
        }
      }
      CampaignOpen: {
        payload: Prisma.$CampaignOpenPayload<ExtArgs>
        fields: Prisma.CampaignOpenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignOpenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignOpenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>
          }
          findFirst: {
            args: Prisma.CampaignOpenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignOpenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>
          }
          findMany: {
            args: Prisma.CampaignOpenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>[]
          }
          create: {
            args: Prisma.CampaignOpenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>
          }
          createMany: {
            args: Prisma.CampaignOpenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignOpenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>[]
          }
          delete: {
            args: Prisma.CampaignOpenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>
          }
          update: {
            args: Prisma.CampaignOpenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>
          }
          deleteMany: {
            args: Prisma.CampaignOpenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignOpenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignOpenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignOpenPayload>
          }
          aggregate: {
            args: Prisma.CampaignOpenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignOpen>
          }
          groupBy: {
            args: Prisma.CampaignOpenGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignOpenGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignOpenCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignOpenCountAggregateOutputType> | number
          }
        }
      }
      CampaignClick: {
        payload: Prisma.$CampaignClickPayload<ExtArgs>
        fields: Prisma.CampaignClickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignClickFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignClickFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>
          }
          findFirst: {
            args: Prisma.CampaignClickFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignClickFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>
          }
          findMany: {
            args: Prisma.CampaignClickFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>[]
          }
          create: {
            args: Prisma.CampaignClickCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>
          }
          createMany: {
            args: Prisma.CampaignClickCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignClickCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>[]
          }
          delete: {
            args: Prisma.CampaignClickDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>
          }
          update: {
            args: Prisma.CampaignClickUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>
          }
          deleteMany: {
            args: Prisma.CampaignClickDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignClickUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignClickUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignClickPayload>
          }
          aggregate: {
            args: Prisma.CampaignClickAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignClick>
          }
          groupBy: {
            args: Prisma.CampaignClickGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignClickGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignClickCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignClickCountAggregateOutputType> | number
          }
        }
      }
      EmailLog: {
        payload: Prisma.$EmailLogPayload<ExtArgs>
        fields: Prisma.EmailLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findFirst: {
            args: Prisma.EmailLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findMany: {
            args: Prisma.EmailLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          create: {
            args: Prisma.EmailLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          createMany: {
            args: Prisma.EmailLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          delete: {
            args: Prisma.EmailLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          update: {
            args: Prisma.EmailLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          aggregate: {
            args: Prisma.EmailLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailLog>
          }
          groupBy: {
            args: Prisma.EmailLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailLogCountAggregateOutputType> | number
          }
        }
      }
      contact_messages: {
        payload: Prisma.$contact_messagesPayload<ExtArgs>
        fields: Prisma.contact_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contact_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contact_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          findFirst: {
            args: Prisma.contact_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contact_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          findMany: {
            args: Prisma.contact_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>[]
          }
          create: {
            args: Prisma.contact_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          createMany: {
            args: Prisma.contact_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.contact_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>[]
          }
          delete: {
            args: Prisma.contact_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          update: {
            args: Prisma.contact_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          deleteMany: {
            args: Prisma.contact_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contact_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contact_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contact_messagesPayload>
          }
          aggregate: {
            args: Prisma.Contact_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_messages>
          }
          groupBy: {
            args: Prisma.contact_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.contact_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_messagesCountAggregateOutputType> | number
          }
        }
      }
      site_settings: {
        payload: Prisma.$site_settingsPayload<ExtArgs>
        fields: Prisma.site_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.site_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.site_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          findFirst: {
            args: Prisma.site_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.site_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          findMany: {
            args: Prisma.site_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>[]
          }
          create: {
            args: Prisma.site_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          createMany: {
            args: Prisma.site_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.site_settingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>[]
          }
          delete: {
            args: Prisma.site_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          update: {
            args: Prisma.site_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          deleteMany: {
            args: Prisma.site_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.site_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.site_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          aggregate: {
            args: Prisma.Site_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSite_settings>
          }
          groupBy: {
            args: Prisma.site_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Site_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.site_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Site_settingsCountAggregateOutputType> | number
          }
        }
      }
      software: {
        payload: Prisma.$softwarePayload<ExtArgs>
        fields: Prisma.softwareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.softwareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.softwareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>
          }
          findFirst: {
            args: Prisma.softwareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.softwareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>
          }
          findMany: {
            args: Prisma.softwareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>[]
          }
          create: {
            args: Prisma.softwareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>
          }
          createMany: {
            args: Prisma.softwareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.softwareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>[]
          }
          delete: {
            args: Prisma.softwareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>
          }
          update: {
            args: Prisma.softwareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>
          }
          deleteMany: {
            args: Prisma.softwareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.softwareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.softwareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwarePayload>
          }
          aggregate: {
            args: Prisma.SoftwareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoftware>
          }
          groupBy: {
            args: Prisma.softwareGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoftwareGroupByOutputType>[]
          }
          count: {
            args: Prisma.softwareCountArgs<ExtArgs>
            result: $Utils.Optional<SoftwareCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activityLogs: number
    carts: number
    questions: number
    inventoryMovements: number
    notifications: number
    orders: number
    reviews: number
    productViews: number
    projects: number
    searchQueries: number
    ServiceBooking: number
    serviceViews: number
    wishlistItems: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    carts?: boolean | UserCountOutputTypeCountCartsArgs
    questions?: boolean | UserCountOutputTypeCountQuestionsArgs
    inventoryMovements?: boolean | UserCountOutputTypeCountInventoryMovementsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    productViews?: boolean | UserCountOutputTypeCountProductViewsArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    searchQueries?: boolean | UserCountOutputTypeCountSearchQueriesArgs
    ServiceBooking?: boolean | UserCountOutputTypeCountServiceBookingArgs
    serviceViews?: boolean | UserCountOutputTypeCountServiceViewsArgs
    wishlistItems?: boolean | UserCountOutputTypeCountWishlistItemsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerQuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    cartItems: number
    InventoryAlert: number
    InventoryMovement: number
    knowledgeEntries: number
    orderItems: number
    reviews: number
    views: number
    wishlistItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItems?: boolean | ProductCountOutputTypeCountCartItemsArgs
    InventoryAlert?: boolean | ProductCountOutputTypeCountInventoryAlertArgs
    InventoryMovement?: boolean | ProductCountOutputTypeCountInventoryMovementArgs
    knowledgeEntries?: boolean | ProductCountOutputTypeCountKnowledgeEntriesArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs
    views?: boolean | ProductCountOutputTypeCountViewsArgs
    wishlistItems?: boolean | ProductCountOutputTypeCountWishlistItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAlertWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountKnowledgeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseEntryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductViewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    paymentIntents: number
    payments: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    paymentIntents?: boolean | OrderCountOutputTypeCountPaymentIntentsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentIntentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentIntentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    refunds: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refunds?: boolean | PaymentCountOutputTypeCountRefundsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountRefundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
  }


  /**
   * Count Type ServiceTypeCountOutputType
   */

  export type ServiceTypeCountOutputType = {
    services: number
  }

  export type ServiceTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceTypeCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceTypeCountOutputType without action
   */
  export type ServiceTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTypeCountOutputType
     */
    select?: ServiceTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceTypeCountOutputType without action
   */
  export type ServiceTypeCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookings: number
    items: number
    views: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
    items?: boolean | ServiceCountOutputTypeCountItemsArgs
    views?: boolean | ServiceCountOutputTypeCountViewsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceItemWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceViewWhereInput
  }


  /**
   * Count Type ProductReviewCountOutputType
   */

  export type ProductReviewCountOutputType = {
    reports: number
    votes: number
  }

  export type ProductReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ProductReviewCountOutputTypeCountReportsArgs
    votes?: boolean | ProductReviewCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * ProductReviewCountOutputType without action
   */
  export type ProductReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewCountOutputType
     */
    select?: ProductReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductReviewCountOutputType without action
   */
  export type ProductReviewCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewReportWhereInput
  }

  /**
   * ProductReviewCountOutputType without action
   */
  export type ProductReviewCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewVoteWhereInput
  }


  /**
   * Count Type TechnicianCountOutputType
   */

  export type TechnicianCountOutputType = {
    bookings: number
    schedules: number
  }

  export type TechnicianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | TechnicianCountOutputTypeCountBookingsArgs
    schedules?: boolean | TechnicianCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * TechnicianCountOutputType without action
   */
  export type TechnicianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianCountOutputType
     */
    select?: TechnicianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TechnicianCountOutputType without action
   */
  export type TechnicianCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
  }

  /**
   * TechnicianCountOutputType without action
   */
  export type TechnicianCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianScheduleWhereInput
  }


  /**
   * Count Type ServiceItemCountOutputType
   */

  export type ServiceItemCountOutputType = {
    bookingItems: number
  }

  export type ServiceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingItems?: boolean | ServiceItemCountOutputTypeCountBookingItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceItemCountOutputType without action
   */
  export type ServiceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItemCountOutputType
     */
    select?: ServiceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceItemCountOutputType without action
   */
  export type ServiceItemCountOutputTypeCountBookingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingItemWhereInput
  }


  /**
   * Count Type ServiceBookingCountOutputType
   */

  export type ServiceBookingCountOutputType = {
    items: number
    payments: number
    history: number
  }

  export type ServiceBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ServiceBookingCountOutputTypeCountItemsArgs
    payments?: boolean | ServiceBookingCountOutputTypeCountPaymentsArgs
    history?: boolean | ServiceBookingCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * ServiceBookingCountOutputType without action
   */
  export type ServiceBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingCountOutputType
     */
    select?: ServiceBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceBookingCountOutputType without action
   */
  export type ServiceBookingCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingItemWhereInput
  }

  /**
   * ServiceBookingCountOutputType without action
   */
  export type ServiceBookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePaymentWhereInput
  }

  /**
   * ServiceBookingCountOutputType without action
   */
  export type ServiceBookingCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatusHistoryWhereInput
  }


  /**
   * Count Type LoyaltyAccountCountOutputType
   */

  export type LoyaltyAccountCountOutputType = {
    transactions: number
    redemptions: number
  }

  export type LoyaltyAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | LoyaltyAccountCountOutputTypeCountTransactionsArgs
    redemptions?: boolean | LoyaltyAccountCountOutputTypeCountRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * LoyaltyAccountCountOutputType without action
   */
  export type LoyaltyAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccountCountOutputType
     */
    select?: LoyaltyAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoyaltyAccountCountOutputType without action
   */
  export type LoyaltyAccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
  }

  /**
   * LoyaltyAccountCountOutputType without action
   */
  export type LoyaltyAccountCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedemptionHistoryWhereInput
  }


  /**
   * Count Type LoyaltyRewardCountOutputType
   */

  export type LoyaltyRewardCountOutputType = {
    redemptions: number
  }

  export type LoyaltyRewardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | LoyaltyRewardCountOutputTypeCountRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * LoyaltyRewardCountOutputType without action
   */
  export type LoyaltyRewardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyRewardCountOutputType
     */
    select?: LoyaltyRewardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoyaltyRewardCountOutputType without action
   */
  export type LoyaltyRewardCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedemptionHistoryWhereInput
  }


  /**
   * Count Type PaymentIntentCountOutputType
   */

  export type PaymentIntentCountOutputType = {
    payments: number
  }

  export type PaymentIntentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentIntentCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentIntentCountOutputType without action
   */
  export type PaymentIntentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntentCountOutputType
     */
    select?: PaymentIntentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentIntentCountOutputType without action
   */
  export type PaymentIntentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    clicks: number
    opens: number
    recipients: number
    emailLogs: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clicks?: boolean | CampaignCountOutputTypeCountClicksArgs
    opens?: boolean | CampaignCountOutputTypeCountOpensArgs
    recipients?: boolean | CampaignCountOutputTypeCountRecipientsArgs
    emailLogs?: boolean | CampaignCountOutputTypeCountEmailLogsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountClicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignClickWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountOpensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignOpenWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRecipientWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEmailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    phone: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    phone: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    loyaltyAccount?: boolean | User$loyaltyAccountArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    productViews?: boolean | User$productViewsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    searchQueries?: boolean | User$searchQueriesArgs<ExtArgs>
    ServiceBooking?: boolean | User$ServiceBookingArgs<ExtArgs>
    serviceViews?: boolean | User$serviceViewsArgs<ExtArgs>
    wishlistItems?: boolean | User$wishlistItemsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    questions?: boolean | User$questionsArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    loyaltyAccount?: boolean | User$loyaltyAccountArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    productViews?: boolean | User$productViewsArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    searchQueries?: boolean | User$searchQueriesArgs<ExtArgs>
    ServiceBooking?: boolean | User$ServiceBookingArgs<ExtArgs>
    serviceViews?: boolean | User$serviceViewsArgs<ExtArgs>
    wishlistItems?: boolean | User$wishlistItemsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      carts: Prisma.$CartPayload<ExtArgs>[]
      questions: Prisma.$CustomerQuestionPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      loyaltyAccount: Prisma.$LoyaltyAccountPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      reviews: Prisma.$ProductReviewPayload<ExtArgs>[]
      productViews: Prisma.$ProductViewPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      searchQueries: Prisma.$SearchQueryPayload<ExtArgs>[]
      ServiceBooking: Prisma.$ServiceBookingPayload<ExtArgs>[]
      serviceViews: Prisma.$ServiceViewPayload<ExtArgs>[]
      wishlistItems: Prisma.$WishlistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      phone: string | null
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    carts<T extends User$cartsArgs<ExtArgs> = {}>(args?: Subset<T, User$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany"> | Null>
    questions<T extends User$questionsArgs<ExtArgs> = {}>(args?: Subset<T, User$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryMovements<T extends User$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany"> | Null>
    loyaltyAccount<T extends User$loyaltyAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$loyaltyAccountArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany"> | Null>
    productViews<T extends User$productViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$productViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    searchQueries<T extends User$searchQueriesArgs<ExtArgs> = {}>(args?: Subset<T, User$searchQueriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany"> | Null>
    ServiceBooking<T extends User$ServiceBookingArgs<ExtArgs> = {}>(args?: Subset<T, User$ServiceBookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany"> | Null>
    serviceViews<T extends User$serviceViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "findMany"> | Null>
    wishlistItems<T extends User$wishlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$wishlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.carts
   */
  export type User$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * User.questions
   */
  export type User$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    where?: CustomerQuestionWhereInput
    orderBy?: CustomerQuestionOrderByWithRelationInput | CustomerQuestionOrderByWithRelationInput[]
    cursor?: CustomerQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerQuestionScalarFieldEnum | CustomerQuestionScalarFieldEnum[]
  }

  /**
   * User.inventoryMovements
   */
  export type User$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * User.loyaltyAccount
   */
  export type User$loyaltyAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    where?: LoyaltyAccountWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * User.productViews
   */
  export type User$productViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    where?: ProductViewWhereInput
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    cursor?: ProductViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.searchQueries
   */
  export type User$searchQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    cursor?: SearchQueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * User.ServiceBooking
   */
  export type User$ServiceBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    cursor?: ServiceBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * User.serviceViews
   */
  export type User$serviceViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    where?: ServiceViewWhereInput
    orderBy?: ServiceViewOrderByWithRelationInput | ServiceViewOrderByWithRelationInput[]
    cursor?: ServiceViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceViewScalarFieldEnum | ServiceViewScalarFieldEnum[]
  }

  /**
   * User.wishlistItems
   */
  export type User$wishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    priceCents: number | null
    originalPriceCents: number | null
    weight: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    maxOrderQuantity: number | null
    maxStock: number | null
    viewCount: number | null
  }

  export type ProductSumAggregateOutputType = {
    priceCents: number | null
    originalPriceCents: number | null
    weight: number | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    maxOrderQuantity: number | null
    maxStock: number | null
    viewCount: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    shortDescription: string | null
    priceCents: number | null
    originalPriceCents: number | null
    imageUrl: string | null
    images: string | null
    categoryId: string | null
    brand: string | null
    model: string | null
    sku: string | null
    specifications: string | null
    features: string | null
    warranty: string | null
    weight: number | null
    dimensions: string | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    maxOrderQuantity: number | null
    maxStock: number | null
    tags: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    canonicalUrl: string | null
    featured: boolean | null
    isActive: boolean | null
    isDeleted: boolean | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    shortDescription: string | null
    priceCents: number | null
    originalPriceCents: number | null
    imageUrl: string | null
    images: string | null
    categoryId: string | null
    brand: string | null
    model: string | null
    sku: string | null
    specifications: string | null
    features: string | null
    warranty: string | null
    weight: number | null
    dimensions: string | null
    stockQuantity: number | null
    minOrderQuantity: number | null
    maxOrderQuantity: number | null
    maxStock: number | null
    tags: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    canonicalUrl: string | null
    featured: boolean | null
    isActive: boolean | null
    isDeleted: boolean | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    shortDescription: number
    priceCents: number
    originalPriceCents: number
    imageUrl: number
    images: number
    categoryId: number
    brand: number
    model: number
    sku: number
    specifications: number
    features: number
    warranty: number
    weight: number
    dimensions: number
    stockQuantity: number
    minOrderQuantity: number
    maxOrderQuantity: number
    maxStock: number
    tags: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    canonicalUrl: number
    featured: number
    isActive: number
    isDeleted: number
    viewCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    priceCents?: true
    originalPriceCents?: true
    weight?: true
    stockQuantity?: true
    minOrderQuantity?: true
    maxOrderQuantity?: true
    maxStock?: true
    viewCount?: true
  }

  export type ProductSumAggregateInputType = {
    priceCents?: true
    originalPriceCents?: true
    weight?: true
    stockQuantity?: true
    minOrderQuantity?: true
    maxOrderQuantity?: true
    maxStock?: true
    viewCount?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    shortDescription?: true
    priceCents?: true
    originalPriceCents?: true
    imageUrl?: true
    images?: true
    categoryId?: true
    brand?: true
    model?: true
    sku?: true
    specifications?: true
    features?: true
    warranty?: true
    weight?: true
    dimensions?: true
    stockQuantity?: true
    minOrderQuantity?: true
    maxOrderQuantity?: true
    maxStock?: true
    tags?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    canonicalUrl?: true
    featured?: true
    isActive?: true
    isDeleted?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    shortDescription?: true
    priceCents?: true
    originalPriceCents?: true
    imageUrl?: true
    images?: true
    categoryId?: true
    brand?: true
    model?: true
    sku?: true
    specifications?: true
    features?: true
    warranty?: true
    weight?: true
    dimensions?: true
    stockQuantity?: true
    minOrderQuantity?: true
    maxOrderQuantity?: true
    maxStock?: true
    tags?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    canonicalUrl?: true
    featured?: true
    isActive?: true
    isDeleted?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    shortDescription?: true
    priceCents?: true
    originalPriceCents?: true
    imageUrl?: true
    images?: true
    categoryId?: true
    brand?: true
    model?: true
    sku?: true
    specifications?: true
    features?: true
    warranty?: true
    weight?: true
    dimensions?: true
    stockQuantity?: true
    minOrderQuantity?: true
    maxOrderQuantity?: true
    maxStock?: true
    tags?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    canonicalUrl?: true
    featured?: true
    isActive?: true
    isDeleted?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string | null
    shortDescription: string | null
    priceCents: number
    originalPriceCents: number | null
    imageUrl: string | null
    images: string | null
    categoryId: string | null
    brand: string | null
    model: string | null
    sku: string | null
    specifications: string | null
    features: string | null
    warranty: string | null
    weight: number | null
    dimensions: string | null
    stockQuantity: number
    minOrderQuantity: number
    maxOrderQuantity: number | null
    maxStock: number | null
    tags: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    canonicalUrl: string | null
    featured: boolean
    isActive: boolean
    isDeleted: boolean
    viewCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    priceCents?: boolean
    originalPriceCents?: boolean
    imageUrl?: boolean
    images?: boolean
    categoryId?: boolean
    brand?: boolean
    model?: boolean
    sku?: boolean
    specifications?: boolean
    features?: boolean
    warranty?: boolean
    weight?: boolean
    dimensions?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    maxOrderQuantity?: boolean
    maxStock?: boolean
    tags?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    canonicalUrl?: boolean
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    InventoryAlert?: boolean | Product$InventoryAlertArgs<ExtArgs>
    InventoryMovement?: boolean | Product$InventoryMovementArgs<ExtArgs>
    knowledgeEntries?: boolean | Product$knowledgeEntriesArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    views?: boolean | Product$viewsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    wishlistItems?: boolean | Product$wishlistItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    priceCents?: boolean
    originalPriceCents?: boolean
    imageUrl?: boolean
    images?: boolean
    categoryId?: boolean
    brand?: boolean
    model?: boolean
    sku?: boolean
    specifications?: boolean
    features?: boolean
    warranty?: boolean
    weight?: boolean
    dimensions?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    maxOrderQuantity?: boolean
    maxStock?: boolean
    tags?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    canonicalUrl?: boolean
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    priceCents?: boolean
    originalPriceCents?: boolean
    imageUrl?: boolean
    images?: boolean
    categoryId?: boolean
    brand?: boolean
    model?: boolean
    sku?: boolean
    specifications?: boolean
    features?: boolean
    warranty?: boolean
    weight?: boolean
    dimensions?: boolean
    stockQuantity?: boolean
    minOrderQuantity?: boolean
    maxOrderQuantity?: boolean
    maxStock?: boolean
    tags?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    canonicalUrl?: boolean
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    InventoryAlert?: boolean | Product$InventoryAlertArgs<ExtArgs>
    InventoryMovement?: boolean | Product$InventoryMovementArgs<ExtArgs>
    knowledgeEntries?: boolean | Product$knowledgeEntriesArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    views?: boolean | Product$viewsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    wishlistItems?: boolean | Product$wishlistItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs> | null
      InventoryAlert: Prisma.$InventoryAlertPayload<ExtArgs>[]
      InventoryMovement: Prisma.$InventoryMovementPayload<ExtArgs>[]
      knowledgeEntries: Prisma.$KnowledgeBaseEntryPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      reviews: Prisma.$ProductReviewPayload<ExtArgs>[]
      views: Prisma.$ProductViewPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      wishlistItems: Prisma.$WishlistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string | null
      shortDescription: string | null
      priceCents: number
      originalPriceCents: number | null
      imageUrl: string | null
      images: string | null
      categoryId: string | null
      brand: string | null
      model: string | null
      sku: string | null
      specifications: string | null
      features: string | null
      warranty: string | null
      weight: number | null
      dimensions: string | null
      stockQuantity: number
      minOrderQuantity: number
      maxOrderQuantity: number | null
      maxStock: number | null
      tags: string | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
      canonicalUrl: string | null
      featured: boolean
      isActive: boolean
      isDeleted: boolean
      viewCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cartItems<T extends Product$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany"> | Null>
    inventory<T extends Product$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    InventoryAlert<T extends Product$InventoryAlertArgs<ExtArgs> = {}>(args?: Subset<T, Product$InventoryAlertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "findMany"> | Null>
    InventoryMovement<T extends Product$InventoryMovementArgs<ExtArgs> = {}>(args?: Subset<T, Product$InventoryMovementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany"> | Null>
    knowledgeEntries<T extends Product$knowledgeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$knowledgeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findMany"> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany"> | Null>
    views<T extends Product$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    wishlistItems<T extends Product$wishlistItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$wishlistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly shortDescription: FieldRef<"Product", 'String'>
    readonly priceCents: FieldRef<"Product", 'Int'>
    readonly originalPriceCents: FieldRef<"Product", 'Int'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly images: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly brand: FieldRef<"Product", 'String'>
    readonly model: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly specifications: FieldRef<"Product", 'String'>
    readonly features: FieldRef<"Product", 'String'>
    readonly warranty: FieldRef<"Product", 'String'>
    readonly weight: FieldRef<"Product", 'Float'>
    readonly dimensions: FieldRef<"Product", 'String'>
    readonly stockQuantity: FieldRef<"Product", 'Int'>
    readonly minOrderQuantity: FieldRef<"Product", 'Int'>
    readonly maxOrderQuantity: FieldRef<"Product", 'Int'>
    readonly maxStock: FieldRef<"Product", 'Int'>
    readonly tags: FieldRef<"Product", 'String'>
    readonly metaTitle: FieldRef<"Product", 'String'>
    readonly metaDescription: FieldRef<"Product", 'String'>
    readonly metaKeywords: FieldRef<"Product", 'String'>
    readonly canonicalUrl: FieldRef<"Product", 'String'>
    readonly featured: FieldRef<"Product", 'Boolean'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly isDeleted: FieldRef<"Product", 'Boolean'>
    readonly viewCount: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.cartItems
   */
  export type Product$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.inventory
   */
  export type Product$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
  }

  /**
   * Product.InventoryAlert
   */
  export type Product$InventoryAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    where?: InventoryAlertWhereInput
    orderBy?: InventoryAlertOrderByWithRelationInput | InventoryAlertOrderByWithRelationInput[]
    cursor?: InventoryAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAlertScalarFieldEnum | InventoryAlertScalarFieldEnum[]
  }

  /**
   * Product.InventoryMovement
   */
  export type Product$InventoryMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Product.knowledgeEntries
   */
  export type Product$knowledgeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    where?: KnowledgeBaseEntryWhereInput
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseEntryScalarFieldEnum | KnowledgeBaseEntryScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * Product.views
   */
  export type Product$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    where?: ProductViewWhereInput
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    cursor?: ProductViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product.wishlistItems
   */
  export type Product$wishlistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    canonicalUrl: string | null
    description: string | null
    imageUrl: string | null
    metaDescription: string | null
    metaKeywords: string | null
    metaTitle: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    canonicalUrl: string | null
    description: string | null
    imageUrl: string | null
    metaDescription: string | null
    metaKeywords: string | null
    metaTitle: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    parentId: number
    isActive: number
    createdAt: number
    updatedAt: number
    canonicalUrl: number
    description: number
    imageUrl: number
    metaDescription: number
    metaKeywords: number
    metaTitle: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    canonicalUrl?: true
    description?: true
    imageUrl?: true
    metaDescription?: true
    metaKeywords?: true
    metaTitle?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    canonicalUrl?: true
    description?: true
    imageUrl?: true
    metaDescription?: true
    metaKeywords?: true
    metaTitle?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    canonicalUrl?: true
    description?: true
    imageUrl?: true
    metaDescription?: true
    metaKeywords?: true
    metaTitle?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    parentId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    canonicalUrl: string | null
    description: string | null
    imageUrl: string | null
    metaDescription: string | null
    metaKeywords: string | null
    metaTitle: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canonicalUrl?: boolean
    description?: boolean
    imageUrl?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    metaTitle?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canonicalUrl?: boolean
    description?: boolean
    imageUrl?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    metaTitle?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canonicalUrl?: boolean
    description?: boolean
    imageUrl?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    metaTitle?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      parentId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      canonicalUrl: string | null
      description: string | null
      imageUrl: string | null
      metaDescription: string | null
      metaKeywords: string | null
      metaTitle: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly canonicalUrl: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly imageUrl: FieldRef<"Category", 'String'>
    readonly metaDescription: FieldRef<"Category", 'String'>
    readonly metaKeywords: FieldRef<"Category", 'String'>
    readonly metaTitle: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    guestId: string | null
    status: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    guestId: string | null
    status: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    guestId: number
    status: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    guestId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    guestId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    guestId?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    userId: string | null
    guestId: string | null
    status: string
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    guestId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Cart$itemsArgs<ExtArgs>
    user?: boolean | Cart$userArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    guestId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    guestId?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Cart$itemsArgs<ExtArgs>
    user?: boolean | Cart$userArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      items: Prisma.$CartItemPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      guestId: string | null
      status: string
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Cart$userArgs<ExtArgs> = {}>(args?: Subset<T, Cart$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */ 
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly guestId: FieldRef<"Cart", 'String'>
    readonly status: FieldRef<"Cart", 'String'>
    readonly expiresAt: FieldRef<"Cart", 'DateTime'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
  }

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart.user
   */
  export type Cart$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    quantity: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string
    quantity: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string
      quantity: number
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */ 
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly price: FieldRef<"CartItem", 'Int'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotalCents: number | null
    discountCents: number | null
    shippingCents: number | null
    totalCents: number | null
  }

  export type OrderSumAggregateOutputType = {
    subtotalCents: number | null
    discountCents: number | null
    shippingCents: number | null
    totalCents: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNo: string | null
    userId: string | null
    subtotalCents: number | null
    discountCents: number | null
    shippingCents: number | null
    totalCents: number | null
    status: string | null
    shippingAddress: string | null
    shippingCoordinates: string | null
    promotionCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNo: string | null
    userId: string | null
    subtotalCents: number | null
    discountCents: number | null
    shippingCents: number | null
    totalCents: number | null
    status: string | null
    shippingAddress: string | null
    shippingCoordinates: string | null
    promotionCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNo: number
    userId: number
    subtotalCents: number
    discountCents: number
    shippingCents: number
    totalCents: number
    status: number
    shippingAddress: number
    shippingCoordinates: number
    promotionCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotalCents?: true
    discountCents?: true
    shippingCents?: true
    totalCents?: true
  }

  export type OrderSumAggregateInputType = {
    subtotalCents?: true
    discountCents?: true
    shippingCents?: true
    totalCents?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNo?: true
    userId?: true
    subtotalCents?: true
    discountCents?: true
    shippingCents?: true
    totalCents?: true
    status?: true
    shippingAddress?: true
    shippingCoordinates?: true
    promotionCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNo?: true
    userId?: true
    subtotalCents?: true
    discountCents?: true
    shippingCents?: true
    totalCents?: true
    status?: true
    shippingAddress?: true
    shippingCoordinates?: true
    promotionCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNo?: true
    userId?: true
    subtotalCents?: true
    discountCents?: true
    shippingCents?: true
    totalCents?: true
    status?: true
    shippingAddress?: true
    shippingCoordinates?: true
    promotionCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNo: string
    userId: string
    subtotalCents: number
    discountCents: number
    shippingCents: number
    totalCents: number
    status: string
    shippingAddress: string | null
    shippingCoordinates: string | null
    promotionCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    userId?: boolean
    subtotalCents?: boolean
    discountCents?: boolean
    shippingCents?: boolean
    totalCents?: boolean
    status?: boolean
    shippingAddress?: boolean
    shippingCoordinates?: boolean
    promotionCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Order$itemsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentIntents?: boolean | Order$paymentIntentsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    userId?: boolean
    subtotalCents?: boolean
    discountCents?: boolean
    shippingCents?: boolean
    totalCents?: boolean
    status?: boolean
    shippingAddress?: boolean
    shippingCoordinates?: boolean
    promotionCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNo?: boolean
    userId?: boolean
    subtotalCents?: boolean
    discountCents?: boolean
    shippingCents?: boolean
    totalCents?: boolean
    status?: boolean
    shippingAddress?: boolean
    shippingCoordinates?: boolean
    promotionCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Order$itemsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentIntents?: boolean | Order$paymentIntentsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      paymentIntents: Prisma.$PaymentIntentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNo: string
      userId: string
      subtotalCents: number
      discountCents: number
      shippingCents: number
      totalCents: number
      status: string
      shippingAddress: string | null
      shippingCoordinates: string | null
      promotionCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paymentIntents<T extends Order$paymentIntentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentIntentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNo: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly subtotalCents: FieldRef<"Order", 'Int'>
    readonly discountCents: FieldRef<"Order", 'Int'>
    readonly shippingCents: FieldRef<"Order", 'Int'>
    readonly totalCents: FieldRef<"Order", 'Int'>
    readonly status: FieldRef<"Order", 'String'>
    readonly shippingAddress: FieldRef<"Order", 'String'>
    readonly shippingCoordinates: FieldRef<"Order", 'String'>
    readonly promotionCode: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.paymentIntents
   */
  export type Order$paymentIntentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    where?: PaymentIntentWhereInput
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    cursor?: PaymentIntentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    unitPrice: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
    unitPrice: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    name: string | null
    unitPrice: number | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    name: string | null
    unitPrice: number | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: number
    name: number
    unitPrice: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
    unitPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
    unitPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    name?: true
    unitPrice?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    name?: true
    unitPrice?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    name?: true
    unitPrice?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    name: string | null
    unitPrice: number | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    name?: boolean
    unitPrice?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    name?: boolean
    unitPrice?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    name?: boolean
    unitPrice?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      price: number
      name: string | null
      unitPrice: number | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Int'>
    readonly name: FieldRef<"OrderItem", 'String'>
    readonly unitPrice: FieldRef<"OrderItem", 'Int'>
    readonly imageUrl: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amountCents: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    intentId: string | null
    provider: string | null
    amountCents: number | null
    status: string | null
    transactionId: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    intentId: string | null
    provider: string | null
    amountCents: number | null
    status: string | null
    transactionId: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    intentId: number
    provider: number
    amountCents: number
    status: number
    transactionId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amountCents?: true
  }

  export type PaymentSumAggregateInputType = {
    amountCents?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    intentId?: true
    provider?: true
    amountCents?: true
    status?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    intentId?: true
    provider?: true
    amountCents?: true
    status?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    intentId?: true
    provider?: true
    amountCents?: true
    status?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderId: string
    intentId: string | null
    provider: string
    amountCents: number
    status: string
    transactionId: string | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    intentId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intent?: boolean | Payment$intentArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    intentId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intent?: boolean | Payment$intentArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    intentId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intent?: boolean | Payment$intentArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intent?: boolean | Payment$intentArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      intent: Prisma.$PaymentIntentPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs>
      refunds: Prisma.$RefundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      intentId: string | null
      provider: string
      amountCents: number
      status: string
      transactionId: string | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intent<T extends Payment$intentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$intentArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    refunds<T extends Payment$refundsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$refundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly intentId: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly amountCents: FieldRef<"Payment", 'Int'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.intent
   */
  export type Payment$intentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    where?: PaymentIntentWhereInput
  }

  /**
   * Payment.refunds
   */
  export type Payment$refundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    cursor?: RefundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type RefundSumAggregateOutputType = {
    amountCents: number | null
  }

  export type RefundMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    amountCents: number | null
    reason: string | null
    status: string | null
    providerRefundId: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    errorMessage: string | null
  }

  export type RefundMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    amountCents: number | null
    reason: string | null
    status: string | null
    providerRefundId: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    errorMessage: string | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    paymentId: number
    amountCents: number
    reason: number
    status: number
    providerRefundId: number
    processedAt: number
    createdAt: number
    updatedAt: number
    errorMessage: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    amountCents?: true
  }

  export type RefundSumAggregateInputType = {
    amountCents?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    paymentId?: true
    amountCents?: true
    reason?: true
    status?: true
    providerRefundId?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    errorMessage?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    paymentId?: true
    amountCents?: true
    reason?: true
    status?: true
    providerRefundId?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    errorMessage?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    paymentId?: true
    amountCents?: true
    reason?: true
    status?: true
    providerRefundId?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    errorMessage?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type RefundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: RefundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: string
    paymentId: string
    amountCents: number
    reason: string | null
    status: string
    providerRefundId: string | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    errorMessage: string | null
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type RefundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    amountCents?: boolean
    reason?: boolean
    status?: boolean
    providerRefundId?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    errorMessage?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    amountCents?: boolean
    reason?: boolean
    status?: boolean
    providerRefundId?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    errorMessage?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectScalar = {
    id?: boolean
    paymentId?: boolean
    amountCents?: boolean
    reason?: boolean
    status?: boolean
    providerRefundId?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    errorMessage?: boolean
  }

  export type RefundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type RefundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $RefundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refund"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      amountCents: number
      reason: string | null
      status: string
      providerRefundId: string | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
      errorMessage: string | null
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }

  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<Prisma.$RefundPayload, S>

  type RefundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface RefundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refund'], meta: { name: 'Refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundFindUniqueArgs>(args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundFindFirstArgs>(args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundFindManyArgs>(args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
     */
    create<T extends RefundCreateArgs>(args: SelectSubset<T, RefundCreateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Refunds.
     * @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundCreateManyArgs>(args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refunds and returns the data saved in the database.
     * @param {RefundCreateManyAndReturnArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
     */
    delete<T extends RefundDeleteArgs>(args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundUpdateArgs>(args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundDeleteManyArgs>(args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundUpdateManyArgs>(args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends RefundUpsertArgs>(args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs['orderBy'] }
        : { orderBy?: RefundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refund model
   */
  readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Refund model
   */ 
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", 'String'>
    readonly paymentId: FieldRef<"Refund", 'String'>
    readonly amountCents: FieldRef<"Refund", 'Int'>
    readonly reason: FieldRef<"Refund", 'String'>
    readonly status: FieldRef<"Refund", 'String'>
    readonly providerRefundId: FieldRef<"Refund", 'String'>
    readonly processedAt: FieldRef<"Refund", 'DateTime'>
    readonly createdAt: FieldRef<"Refund", 'DateTime'>
    readonly updatedAt: FieldRef<"Refund", 'DateTime'>
    readonly errorMessage: FieldRef<"Refund", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>
  }

  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Refund createManyAndReturn
   */
  export type RefundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
  }

  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
  }

  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput
  }

  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
  }


  /**
   * Model ServiceType
   */

  export type AggregateServiceType = {
    _count: ServiceTypeCountAggregateOutputType | null
    _avg: ServiceTypeAvgAggregateOutputType | null
    _sum: ServiceTypeSumAggregateOutputType | null
    _min: ServiceTypeMinAggregateOutputType | null
    _max: ServiceTypeMaxAggregateOutputType | null
  }

  export type ServiceTypeAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ServiceTypeSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ServiceTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    color: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTypeAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ServiceTypeSumAggregateInputType = {
    sortOrder?: true
  }

  export type ServiceTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceType to aggregate.
     */
    where?: ServiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTypes to fetch.
     */
    orderBy?: ServiceTypeOrderByWithRelationInput | ServiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTypes
    **/
    _count?: true | ServiceTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTypeMaxAggregateInputType
  }

  export type GetServiceTypeAggregateType<T extends ServiceTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceType[P]>
      : GetScalarType<T[P], AggregateServiceType[P]>
  }




  export type ServiceTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTypeWhereInput
    orderBy?: ServiceTypeOrderByWithAggregationInput | ServiceTypeOrderByWithAggregationInput[]
    by: ServiceTypeScalarFieldEnum[] | ServiceTypeScalarFieldEnum
    having?: ServiceTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTypeCountAggregateInputType | true
    _avg?: ServiceTypeAvgAggregateInputType
    _sum?: ServiceTypeSumAggregateInputType
    _min?: ServiceTypeMinAggregateInputType
    _max?: ServiceTypeMaxAggregateInputType
  }

  export type ServiceTypeGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ServiceTypeCountAggregateOutputType | null
    _avg: ServiceTypeAvgAggregateOutputType | null
    _sum: ServiceTypeSumAggregateOutputType | null
    _min: ServiceTypeMinAggregateOutputType | null
    _max: ServiceTypeMaxAggregateOutputType | null
  }

  type GetServiceTypeGroupByPayload<T extends ServiceTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTypeGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | ServiceType$servicesArgs<ExtArgs>
    _count?: boolean | ServiceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceType"]>

  export type ServiceTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceType"]>

  export type ServiceTypeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceType$servicesArgs<ExtArgs>
    _count?: boolean | ServiceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceType"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      color: string | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceType"]>
    composites: {}
  }

  type ServiceTypeGetPayload<S extends boolean | null | undefined | ServiceTypeDefaultArgs> = $Result.GetResult<Prisma.$ServiceTypePayload, S>

  type ServiceTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceTypeCountAggregateInputType | true
    }

  export interface ServiceTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceType'], meta: { name: 'ServiceType' } }
    /**
     * Find zero or one ServiceType that matches the filter.
     * @param {ServiceTypeFindUniqueArgs} args - Arguments to find a ServiceType
     * @example
     * // Get one ServiceType
     * const serviceType = await prisma.serviceType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceTypeFindUniqueArgs>(args: SelectSubset<T, ServiceTypeFindUniqueArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceTypeFindUniqueOrThrowArgs} args - Arguments to find a ServiceType
     * @example
     * // Get one ServiceType
     * const serviceType = await prisma.serviceType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTypeFindFirstArgs} args - Arguments to find a ServiceType
     * @example
     * // Get one ServiceType
     * const serviceType = await prisma.serviceType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceTypeFindFirstArgs>(args?: SelectSubset<T, ServiceTypeFindFirstArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTypeFindFirstOrThrowArgs} args - Arguments to find a ServiceType
     * @example
     * // Get one ServiceType
     * const serviceType = await prisma.serviceType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTypes
     * const serviceTypes = await prisma.serviceType.findMany()
     * 
     * // Get first 10 ServiceTypes
     * const serviceTypes = await prisma.serviceType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTypeWithIdOnly = await prisma.serviceType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceTypeFindManyArgs>(args?: SelectSubset<T, ServiceTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceType.
     * @param {ServiceTypeCreateArgs} args - Arguments to create a ServiceType.
     * @example
     * // Create one ServiceType
     * const ServiceType = await prisma.serviceType.create({
     *   data: {
     *     // ... data to create a ServiceType
     *   }
     * })
     * 
     */
    create<T extends ServiceTypeCreateArgs>(args: SelectSubset<T, ServiceTypeCreateArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceTypes.
     * @param {ServiceTypeCreateManyArgs} args - Arguments to create many ServiceTypes.
     * @example
     * // Create many ServiceTypes
     * const serviceType = await prisma.serviceType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceTypeCreateManyArgs>(args?: SelectSubset<T, ServiceTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceTypes and returns the data saved in the database.
     * @param {ServiceTypeCreateManyAndReturnArgs} args - Arguments to create many ServiceTypes.
     * @example
     * // Create many ServiceTypes
     * const serviceType = await prisma.serviceType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceTypes and only return the `id`
     * const serviceTypeWithIdOnly = await prisma.serviceType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceType.
     * @param {ServiceTypeDeleteArgs} args - Arguments to delete one ServiceType.
     * @example
     * // Delete one ServiceType
     * const ServiceType = await prisma.serviceType.delete({
     *   where: {
     *     // ... filter to delete one ServiceType
     *   }
     * })
     * 
     */
    delete<T extends ServiceTypeDeleteArgs>(args: SelectSubset<T, ServiceTypeDeleteArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceType.
     * @param {ServiceTypeUpdateArgs} args - Arguments to update one ServiceType.
     * @example
     * // Update one ServiceType
     * const serviceType = await prisma.serviceType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceTypeUpdateArgs>(args: SelectSubset<T, ServiceTypeUpdateArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceTypes.
     * @param {ServiceTypeDeleteManyArgs} args - Arguments to filter ServiceTypes to delete.
     * @example
     * // Delete a few ServiceTypes
     * const { count } = await prisma.serviceType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceTypeDeleteManyArgs>(args?: SelectSubset<T, ServiceTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTypes
     * const serviceType = await prisma.serviceType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceTypeUpdateManyArgs>(args: SelectSubset<T, ServiceTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceType.
     * @param {ServiceTypeUpsertArgs} args - Arguments to update or create a ServiceType.
     * @example
     * // Update or create a ServiceType
     * const serviceType = await prisma.serviceType.upsert({
     *   create: {
     *     // ... data to create a ServiceType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceType we want to update
     *   }
     * })
     */
    upsert<T extends ServiceTypeUpsertArgs>(args: SelectSubset<T, ServiceTypeUpsertArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTypeCountArgs} args - Arguments to filter ServiceTypes to count.
     * @example
     * // Count the number of ServiceTypes
     * const count = await prisma.serviceType.count({
     *   where: {
     *     // ... the filter for the ServiceTypes we want to count
     *   }
     * })
    **/
    count<T extends ServiceTypeCountArgs>(
      args?: Subset<T, ServiceTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTypeAggregateArgs>(args: Subset<T, ServiceTypeAggregateArgs>): Prisma.PrismaPromise<GetServiceTypeAggregateType<T>>

    /**
     * Group by ServiceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTypeGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceType model
   */
  readonly fields: ServiceTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceType$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceType$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceType model
   */ 
  interface ServiceTypeFieldRefs {
    readonly id: FieldRef<"ServiceType", 'String'>
    readonly name: FieldRef<"ServiceType", 'String'>
    readonly slug: FieldRef<"ServiceType", 'String'>
    readonly description: FieldRef<"ServiceType", 'String'>
    readonly icon: FieldRef<"ServiceType", 'String'>
    readonly color: FieldRef<"ServiceType", 'String'>
    readonly isActive: FieldRef<"ServiceType", 'Boolean'>
    readonly sortOrder: FieldRef<"ServiceType", 'Int'>
    readonly createdAt: FieldRef<"ServiceType", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceType findUnique
   */
  export type ServiceTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceType to fetch.
     */
    where: ServiceTypeWhereUniqueInput
  }

  /**
   * ServiceType findUniqueOrThrow
   */
  export type ServiceTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceType to fetch.
     */
    where: ServiceTypeWhereUniqueInput
  }

  /**
   * ServiceType findFirst
   */
  export type ServiceTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceType to fetch.
     */
    where?: ServiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTypes to fetch.
     */
    orderBy?: ServiceTypeOrderByWithRelationInput | ServiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTypes.
     */
    cursor?: ServiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTypes.
     */
    distinct?: ServiceTypeScalarFieldEnum | ServiceTypeScalarFieldEnum[]
  }

  /**
   * ServiceType findFirstOrThrow
   */
  export type ServiceTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceType to fetch.
     */
    where?: ServiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTypes to fetch.
     */
    orderBy?: ServiceTypeOrderByWithRelationInput | ServiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTypes.
     */
    cursor?: ServiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTypes.
     */
    distinct?: ServiceTypeScalarFieldEnum | ServiceTypeScalarFieldEnum[]
  }

  /**
   * ServiceType findMany
   */
  export type ServiceTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTypes to fetch.
     */
    where?: ServiceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTypes to fetch.
     */
    orderBy?: ServiceTypeOrderByWithRelationInput | ServiceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTypes.
     */
    cursor?: ServiceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTypes.
     */
    skip?: number
    distinct?: ServiceTypeScalarFieldEnum | ServiceTypeScalarFieldEnum[]
  }

  /**
   * ServiceType create
   */
  export type ServiceTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceType.
     */
    data: XOR<ServiceTypeCreateInput, ServiceTypeUncheckedCreateInput>
  }

  /**
   * ServiceType createMany
   */
  export type ServiceTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTypes.
     */
    data: ServiceTypeCreateManyInput | ServiceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceType createManyAndReturn
   */
  export type ServiceTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceTypes.
     */
    data: ServiceTypeCreateManyInput | ServiceTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceType update
   */
  export type ServiceTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceType.
     */
    data: XOR<ServiceTypeUpdateInput, ServiceTypeUncheckedUpdateInput>
    /**
     * Choose, which ServiceType to update.
     */
    where: ServiceTypeWhereUniqueInput
  }

  /**
   * ServiceType updateMany
   */
  export type ServiceTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTypes.
     */
    data: XOR<ServiceTypeUpdateManyMutationInput, ServiceTypeUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTypes to update
     */
    where?: ServiceTypeWhereInput
  }

  /**
   * ServiceType upsert
   */
  export type ServiceTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceType to update in case it exists.
     */
    where: ServiceTypeWhereUniqueInput
    /**
     * In case the ServiceType found by the `where` argument doesn't exist, create a new ServiceType with this data.
     */
    create: XOR<ServiceTypeCreateInput, ServiceTypeUncheckedCreateInput>
    /**
     * In case the ServiceType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTypeUpdateInput, ServiceTypeUncheckedUpdateInput>
  }

  /**
   * ServiceType delete
   */
  export type ServiceTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    /**
     * Filter which ServiceType to delete.
     */
    where: ServiceTypeWhereUniqueInput
  }

  /**
   * ServiceType deleteMany
   */
  export type ServiceTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTypes to delete
     */
    where?: ServiceTypeWhereInput
  }

  /**
   * ServiceType.services
   */
  export type ServiceType$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceType without action
   */
  export type ServiceTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    basePriceCents: number | null
    price: number | null
    minPrice: number | null
    maxPrice: number | null
    duration: number | null
    viewCount: number | null
  }

  export type ServiceSumAggregateOutputType = {
    basePriceCents: number | null
    price: number | null
    minPrice: number | null
    maxPrice: number | null
    duration: number | null
    viewCount: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    shortDescription: string | null
    basePriceCents: number | null
    price: number | null
    minPrice: number | null
    maxPrice: number | null
    priceType: string | null
    duration: number | null
    typeId: string | null
    images: string | null
    isActive: boolean | null
    isFeatured: boolean | null
    seoTitle: string | null
    seoDescription: string | null
    type: string | null
    tags: string | null
    features: string | null
    requirements: string | null
    metadata: string | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    shortDescription: string | null
    basePriceCents: number | null
    price: number | null
    minPrice: number | null
    maxPrice: number | null
    priceType: string | null
    duration: number | null
    typeId: string | null
    images: string | null
    isActive: boolean | null
    isFeatured: boolean | null
    seoTitle: string | null
    seoDescription: string | null
    type: string | null
    tags: string | null
    features: string | null
    requirements: string | null
    metadata: string | null
    viewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    shortDescription: number
    basePriceCents: number
    price: number
    minPrice: number
    maxPrice: number
    priceType: number
    duration: number
    typeId: number
    images: number
    isActive: number
    isFeatured: number
    seoTitle: number
    seoDescription: number
    type: number
    tags: number
    features: number
    requirements: number
    metadata: number
    viewCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    basePriceCents?: true
    price?: true
    minPrice?: true
    maxPrice?: true
    duration?: true
    viewCount?: true
  }

  export type ServiceSumAggregateInputType = {
    basePriceCents?: true
    price?: true
    minPrice?: true
    maxPrice?: true
    duration?: true
    viewCount?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    shortDescription?: true
    basePriceCents?: true
    price?: true
    minPrice?: true
    maxPrice?: true
    priceType?: true
    duration?: true
    typeId?: true
    images?: true
    isActive?: true
    isFeatured?: true
    seoTitle?: true
    seoDescription?: true
    type?: true
    tags?: true
    features?: true
    requirements?: true
    metadata?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    shortDescription?: true
    basePriceCents?: true
    price?: true
    minPrice?: true
    maxPrice?: true
    priceType?: true
    duration?: true
    typeId?: true
    images?: true
    isActive?: true
    isFeatured?: true
    seoTitle?: true
    seoDescription?: true
    type?: true
    tags?: true
    features?: true
    requirements?: true
    metadata?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    shortDescription?: true
    basePriceCents?: true
    price?: true
    minPrice?: true
    maxPrice?: true
    priceType?: true
    duration?: true
    typeId?: true
    images?: true
    isActive?: true
    isFeatured?: true
    seoTitle?: true
    seoDescription?: true
    type?: true
    tags?: true
    features?: true
    requirements?: true
    metadata?: true
    viewCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string | null
    shortDescription: string | null
    basePriceCents: number
    price: number
    minPrice: number | null
    maxPrice: number | null
    priceType: string
    duration: number
    typeId: string | null
    images: string | null
    isActive: boolean
    isFeatured: boolean
    seoTitle: string | null
    seoDescription: string | null
    type: string | null
    tags: string | null
    features: string | null
    requirements: string | null
    metadata: string | null
    viewCount: number
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    basePriceCents?: boolean
    price?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    priceType?: boolean
    duration?: boolean
    typeId?: boolean
    images?: boolean
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    type?: boolean
    tags?: boolean
    features?: boolean
    requirements?: boolean
    metadata?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    items?: boolean | Service$itemsArgs<ExtArgs>
    views?: boolean | Service$viewsArgs<ExtArgs>
    serviceType?: boolean | Service$serviceTypeArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    basePriceCents?: boolean
    price?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    priceType?: boolean
    duration?: boolean
    typeId?: boolean
    images?: boolean
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    type?: boolean
    tags?: boolean
    features?: boolean
    requirements?: boolean
    metadata?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceType?: boolean | Service$serviceTypeArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    shortDescription?: boolean
    basePriceCents?: boolean
    price?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    priceType?: boolean
    duration?: boolean
    typeId?: boolean
    images?: boolean
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    type?: boolean
    tags?: boolean
    features?: boolean
    requirements?: boolean
    metadata?: boolean
    viewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    items?: boolean | Service$itemsArgs<ExtArgs>
    views?: boolean | Service$viewsArgs<ExtArgs>
    serviceType?: boolean | Service$serviceTypeArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceType?: boolean | Service$serviceTypeArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      bookings: Prisma.$ServiceBookingPayload<ExtArgs>[]
      items: Prisma.$ServiceItemPayload<ExtArgs>[]
      views: Prisma.$ServiceViewPayload<ExtArgs>[]
      serviceType: Prisma.$ServiceTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string | null
      shortDescription: string | null
      basePriceCents: number
      price: number
      minPrice: number | null
      maxPrice: number | null
      priceType: string
      duration: number
      typeId: string | null
      images: string | null
      isActive: boolean
      isFeatured: boolean
      seoTitle: string | null
      seoDescription: string | null
      type: string | null
      tags: string | null
      features: string | null
      requirements: string | null
      metadata: string | null
      viewCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany"> | Null>
    items<T extends Service$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    views<T extends Service$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Service$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "findMany"> | Null>
    serviceType<T extends Service$serviceTypeArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceTypeArgs<ExtArgs>>): Prisma__ServiceTypeClient<$Result.GetResult<Prisma.$ServiceTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly shortDescription: FieldRef<"Service", 'String'>
    readonly basePriceCents: FieldRef<"Service", 'Int'>
    readonly price: FieldRef<"Service", 'Int'>
    readonly minPrice: FieldRef<"Service", 'Int'>
    readonly maxPrice: FieldRef<"Service", 'Int'>
    readonly priceType: FieldRef<"Service", 'String'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly typeId: FieldRef<"Service", 'String'>
    readonly images: FieldRef<"Service", 'String'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly isFeatured: FieldRef<"Service", 'Boolean'>
    readonly seoTitle: FieldRef<"Service", 'String'>
    readonly seoDescription: FieldRef<"Service", 'String'>
    readonly type: FieldRef<"Service", 'String'>
    readonly tags: FieldRef<"Service", 'String'>
    readonly features: FieldRef<"Service", 'String'>
    readonly requirements: FieldRef<"Service", 'String'>
    readonly metadata: FieldRef<"Service", 'String'>
    readonly viewCount: FieldRef<"Service", 'Int'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    cursor?: ServiceBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * Service.items
   */
  export type Service$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    where?: ServiceItemWhereInput
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    cursor?: ServiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * Service.views
   */
  export type Service$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    where?: ServiceViewWhereInput
    orderBy?: ServiceViewOrderByWithRelationInput | ServiceViewOrderByWithRelationInput[]
    cursor?: ServiceViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceViewScalarFieldEnum | ServiceViewScalarFieldEnum[]
  }

  /**
   * Service.serviceType
   */
  export type Service$serviceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceType
     */
    select?: ServiceTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTypeInclude<ExtArgs> | null
    where?: ServiceTypeWhereInput
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    stock: number | null
    reserved: number | null
    lowStockThreshold: number | null
  }

  export type InventorySumAggregateOutputType = {
    stock: number | null
    reserved: number | null
    lowStockThreshold: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    stock: number | null
    reserved: number | null
    lowStockThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    stock: number | null
    reserved: number | null
    lowStockThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    productId: number
    stock: number
    reserved: number
    lowStockThreshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    stock?: true
    reserved?: true
    lowStockThreshold?: true
  }

  export type InventorySumAggregateInputType = {
    stock?: true
    reserved?: true
    lowStockThreshold?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    productId?: true
    stock?: true
    reserved?: true
    lowStockThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    productId?: true
    stock?: true
    reserved?: true
    lowStockThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    productId?: true
    stock?: true
    reserved?: true
    lowStockThreshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    productId: string
    stock: number
    reserved: number
    lowStockThreshold: number
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    stock?: boolean
    reserved?: boolean
    lowStockThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    stock?: boolean
    reserved?: boolean
    lowStockThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    productId?: boolean
    stock?: boolean
    reserved?: boolean
    lowStockThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      stock: number
      reserved: number
      lowStockThreshold: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */ 
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly productId: FieldRef<"Inventory", 'String'>
    readonly stock: FieldRef<"Inventory", 'Int'>
    readonly reserved: FieldRef<"Inventory", 'Int'>
    readonly lowStockThreshold: FieldRef<"Inventory", 'Int'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    quantity: number | null
    previousStock: number | null
    newStock: number | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    quantity: number | null
    previousStock: number | null
    newStock: number | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: string | null
    productId: string | null
    type: string | null
    quantity: number | null
    previousStock: number | null
    newStock: number | null
    reason: string | null
    referenceId: string | null
    referenceType: string | null
    userId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    type: string | null
    quantity: number | null
    previousStock: number | null
    newStock: number | null
    reason: string | null
    referenceId: string | null
    referenceType: string | null
    userId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    productId: number
    type: number
    quantity: number
    previousStock: number
    newStock: number
    reason: number
    referenceId: number
    referenceType: number
    userId: number
    notes: number
    createdAt: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    quantity?: true
    previousStock?: true
    newStock?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    quantity?: true
    previousStock?: true
    newStock?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    previousStock?: true
    newStock?: true
    reason?: true
    referenceId?: true
    referenceType?: true
    userId?: true
    notes?: true
    createdAt?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    previousStock?: true
    newStock?: true
    reason?: true
    referenceId?: true
    referenceType?: true
    userId?: true
    notes?: true
    createdAt?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    quantity?: true
    previousStock?: true
    newStock?: true
    reason?: true
    referenceId?: true
    referenceType?: true
    userId?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: string
    productId: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason: string | null
    referenceId: string | null
    referenceType: string | null
    userId: string | null
    notes: string | null
    createdAt: Date
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    previousStock?: boolean
    newStock?: boolean
    reason?: boolean
    referenceId?: boolean
    referenceType?: boolean
    userId?: boolean
    notes?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | InventoryMovement$userArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    previousStock?: boolean
    newStock?: boolean
    reason?: boolean
    referenceId?: boolean
    referenceType?: boolean
    userId?: boolean
    notes?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | InventoryMovement$userArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    previousStock?: boolean
    newStock?: boolean
    reason?: boolean
    referenceId?: boolean
    referenceType?: boolean
    userId?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | InventoryMovement$userArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | InventoryMovement$userArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      type: string
      quantity: number
      previousStock: number
      newStock: number
      reason: string | null
      referenceId: string | null
      referenceType: string | null
      userId: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends InventoryMovement$userArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovement$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */ 
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'String'>
    readonly productId: FieldRef<"InventoryMovement", 'String'>
    readonly type: FieldRef<"InventoryMovement", 'String'>
    readonly quantity: FieldRef<"InventoryMovement", 'Int'>
    readonly previousStock: FieldRef<"InventoryMovement", 'Int'>
    readonly newStock: FieldRef<"InventoryMovement", 'Int'>
    readonly reason: FieldRef<"InventoryMovement", 'String'>
    readonly referenceId: FieldRef<"InventoryMovement", 'String'>
    readonly referenceType: FieldRef<"InventoryMovement", 'String'>
    readonly userId: FieldRef<"InventoryMovement", 'String'>
    readonly notes: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
  }

  /**
   * InventoryMovement.user
   */
  export type InventoryMovement$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model InventoryAlert
   */

  export type AggregateInventoryAlert = {
    _count: InventoryAlertCountAggregateOutputType | null
    _avg: InventoryAlertAvgAggregateOutputType | null
    _sum: InventoryAlertSumAggregateOutputType | null
    _min: InventoryAlertMinAggregateOutputType | null
    _max: InventoryAlertMaxAggregateOutputType | null
  }

  export type InventoryAlertAvgAggregateOutputType = {
    threshold: number | null
    currentStock: number | null
  }

  export type InventoryAlertSumAggregateOutputType = {
    threshold: number | null
    currentStock: number | null
  }

  export type InventoryAlertMinAggregateOutputType = {
    id: string | null
    productId: string | null
    type: string | null
    message: string | null
    threshold: number | null
    currentStock: number | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryAlertMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    type: string | null
    message: string | null
    threshold: number | null
    currentStock: number | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryAlertCountAggregateOutputType = {
    id: number
    productId: number
    type: number
    message: number
    threshold: number
    currentStock: number
    isResolved: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAlertAvgAggregateInputType = {
    threshold?: true
    currentStock?: true
  }

  export type InventoryAlertSumAggregateInputType = {
    threshold?: true
    currentStock?: true
  }

  export type InventoryAlertMinAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    message?: true
    threshold?: true
    currentStock?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryAlertMaxAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    message?: true
    threshold?: true
    currentStock?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryAlertCountAggregateInputType = {
    id?: true
    productId?: true
    type?: true
    message?: true
    threshold?: true
    currentStock?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAlert to aggregate.
     */
    where?: InventoryAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAlerts to fetch.
     */
    orderBy?: InventoryAlertOrderByWithRelationInput | InventoryAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryAlerts
    **/
    _count?: true | InventoryAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryAlertMaxAggregateInputType
  }

  export type GetInventoryAlertAggregateType<T extends InventoryAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryAlert[P]>
      : GetScalarType<T[P], AggregateInventoryAlert[P]>
  }




  export type InventoryAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAlertWhereInput
    orderBy?: InventoryAlertOrderByWithAggregationInput | InventoryAlertOrderByWithAggregationInput[]
    by: InventoryAlertScalarFieldEnum[] | InventoryAlertScalarFieldEnum
    having?: InventoryAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryAlertCountAggregateInputType | true
    _avg?: InventoryAlertAvgAggregateInputType
    _sum?: InventoryAlertSumAggregateInputType
    _min?: InventoryAlertMinAggregateInputType
    _max?: InventoryAlertMaxAggregateInputType
  }

  export type InventoryAlertGroupByOutputType = {
    id: string
    productId: string
    type: string
    message: string
    threshold: number | null
    currentStock: number
    isResolved: boolean
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryAlertCountAggregateOutputType | null
    _avg: InventoryAlertAvgAggregateOutputType | null
    _sum: InventoryAlertSumAggregateOutputType | null
    _min: InventoryAlertMinAggregateOutputType | null
    _max: InventoryAlertMaxAggregateOutputType | null
  }

  type GetInventoryAlertGroupByPayload<T extends InventoryAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryAlertGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryAlertGroupByOutputType[P]>
        }
      >
    >


  export type InventoryAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    message?: boolean
    threshold?: boolean
    currentStock?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAlert"]>

  export type InventoryAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    type?: boolean
    message?: boolean
    threshold?: boolean
    currentStock?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAlert"]>

  export type InventoryAlertSelectScalar = {
    id?: boolean
    productId?: boolean
    type?: boolean
    message?: boolean
    threshold?: boolean
    currentStock?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type InventoryAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $InventoryAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryAlert"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      type: string
      message: string
      threshold: number | null
      currentStock: number
      isResolved: boolean
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryAlert"]>
    composites: {}
  }

  type InventoryAlertGetPayload<S extends boolean | null | undefined | InventoryAlertDefaultArgs> = $Result.GetResult<Prisma.$InventoryAlertPayload, S>

  type InventoryAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryAlertCountAggregateInputType | true
    }

  export interface InventoryAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryAlert'], meta: { name: 'InventoryAlert' } }
    /**
     * Find zero or one InventoryAlert that matches the filter.
     * @param {InventoryAlertFindUniqueArgs} args - Arguments to find a InventoryAlert
     * @example
     * // Get one InventoryAlert
     * const inventoryAlert = await prisma.inventoryAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryAlertFindUniqueArgs>(args: SelectSubset<T, InventoryAlertFindUniqueArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryAlertFindUniqueOrThrowArgs} args - Arguments to find a InventoryAlert
     * @example
     * // Get one InventoryAlert
     * const inventoryAlert = await prisma.inventoryAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAlertFindFirstArgs} args - Arguments to find a InventoryAlert
     * @example
     * // Get one InventoryAlert
     * const inventoryAlert = await prisma.inventoryAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryAlertFindFirstArgs>(args?: SelectSubset<T, InventoryAlertFindFirstArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAlertFindFirstOrThrowArgs} args - Arguments to find a InventoryAlert
     * @example
     * // Get one InventoryAlert
     * const inventoryAlert = await prisma.inventoryAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryAlerts
     * const inventoryAlerts = await prisma.inventoryAlert.findMany()
     * 
     * // Get first 10 InventoryAlerts
     * const inventoryAlerts = await prisma.inventoryAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryAlertWithIdOnly = await prisma.inventoryAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryAlertFindManyArgs>(args?: SelectSubset<T, InventoryAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryAlert.
     * @param {InventoryAlertCreateArgs} args - Arguments to create a InventoryAlert.
     * @example
     * // Create one InventoryAlert
     * const InventoryAlert = await prisma.inventoryAlert.create({
     *   data: {
     *     // ... data to create a InventoryAlert
     *   }
     * })
     * 
     */
    create<T extends InventoryAlertCreateArgs>(args: SelectSubset<T, InventoryAlertCreateArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryAlerts.
     * @param {InventoryAlertCreateManyArgs} args - Arguments to create many InventoryAlerts.
     * @example
     * // Create many InventoryAlerts
     * const inventoryAlert = await prisma.inventoryAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryAlertCreateManyArgs>(args?: SelectSubset<T, InventoryAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryAlerts and returns the data saved in the database.
     * @param {InventoryAlertCreateManyAndReturnArgs} args - Arguments to create many InventoryAlerts.
     * @example
     * // Create many InventoryAlerts
     * const inventoryAlert = await prisma.inventoryAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryAlerts and only return the `id`
     * const inventoryAlertWithIdOnly = await prisma.inventoryAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryAlert.
     * @param {InventoryAlertDeleteArgs} args - Arguments to delete one InventoryAlert.
     * @example
     * // Delete one InventoryAlert
     * const InventoryAlert = await prisma.inventoryAlert.delete({
     *   where: {
     *     // ... filter to delete one InventoryAlert
     *   }
     * })
     * 
     */
    delete<T extends InventoryAlertDeleteArgs>(args: SelectSubset<T, InventoryAlertDeleteArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryAlert.
     * @param {InventoryAlertUpdateArgs} args - Arguments to update one InventoryAlert.
     * @example
     * // Update one InventoryAlert
     * const inventoryAlert = await prisma.inventoryAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryAlertUpdateArgs>(args: SelectSubset<T, InventoryAlertUpdateArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryAlerts.
     * @param {InventoryAlertDeleteManyArgs} args - Arguments to filter InventoryAlerts to delete.
     * @example
     * // Delete a few InventoryAlerts
     * const { count } = await prisma.inventoryAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryAlertDeleteManyArgs>(args?: SelectSubset<T, InventoryAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryAlerts
     * const inventoryAlert = await prisma.inventoryAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryAlertUpdateManyArgs>(args: SelectSubset<T, InventoryAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryAlert.
     * @param {InventoryAlertUpsertArgs} args - Arguments to update or create a InventoryAlert.
     * @example
     * // Update or create a InventoryAlert
     * const inventoryAlert = await prisma.inventoryAlert.upsert({
     *   create: {
     *     // ... data to create a InventoryAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryAlert we want to update
     *   }
     * })
     */
    upsert<T extends InventoryAlertUpsertArgs>(args: SelectSubset<T, InventoryAlertUpsertArgs<ExtArgs>>): Prisma__InventoryAlertClient<$Result.GetResult<Prisma.$InventoryAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAlertCountArgs} args - Arguments to filter InventoryAlerts to count.
     * @example
     * // Count the number of InventoryAlerts
     * const count = await prisma.inventoryAlert.count({
     *   where: {
     *     // ... the filter for the InventoryAlerts we want to count
     *   }
     * })
    **/
    count<T extends InventoryAlertCountArgs>(
      args?: Subset<T, InventoryAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAlertAggregateArgs>(args: Subset<T, InventoryAlertAggregateArgs>): Prisma.PrismaPromise<GetInventoryAlertAggregateType<T>>

    /**
     * Group by InventoryAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryAlertGroupByArgs['orderBy'] }
        : { orderBy?: InventoryAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryAlert model
   */
  readonly fields: InventoryAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryAlert model
   */ 
  interface InventoryAlertFieldRefs {
    readonly id: FieldRef<"InventoryAlert", 'String'>
    readonly productId: FieldRef<"InventoryAlert", 'String'>
    readonly type: FieldRef<"InventoryAlert", 'String'>
    readonly message: FieldRef<"InventoryAlert", 'String'>
    readonly threshold: FieldRef<"InventoryAlert", 'Int'>
    readonly currentStock: FieldRef<"InventoryAlert", 'Int'>
    readonly isResolved: FieldRef<"InventoryAlert", 'Boolean'>
    readonly resolvedAt: FieldRef<"InventoryAlert", 'DateTime'>
    readonly createdAt: FieldRef<"InventoryAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryAlert findUnique
   */
  export type InventoryAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAlert to fetch.
     */
    where: InventoryAlertWhereUniqueInput
  }

  /**
   * InventoryAlert findUniqueOrThrow
   */
  export type InventoryAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAlert to fetch.
     */
    where: InventoryAlertWhereUniqueInput
  }

  /**
   * InventoryAlert findFirst
   */
  export type InventoryAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAlert to fetch.
     */
    where?: InventoryAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAlerts to fetch.
     */
    orderBy?: InventoryAlertOrderByWithRelationInput | InventoryAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAlerts.
     */
    cursor?: InventoryAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAlerts.
     */
    distinct?: InventoryAlertScalarFieldEnum | InventoryAlertScalarFieldEnum[]
  }

  /**
   * InventoryAlert findFirstOrThrow
   */
  export type InventoryAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAlert to fetch.
     */
    where?: InventoryAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAlerts to fetch.
     */
    orderBy?: InventoryAlertOrderByWithRelationInput | InventoryAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAlerts.
     */
    cursor?: InventoryAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAlerts.
     */
    distinct?: InventoryAlertScalarFieldEnum | InventoryAlertScalarFieldEnum[]
  }

  /**
   * InventoryAlert findMany
   */
  export type InventoryAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAlerts to fetch.
     */
    where?: InventoryAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAlerts to fetch.
     */
    orderBy?: InventoryAlertOrderByWithRelationInput | InventoryAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryAlerts.
     */
    cursor?: InventoryAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAlerts.
     */
    skip?: number
    distinct?: InventoryAlertScalarFieldEnum | InventoryAlertScalarFieldEnum[]
  }

  /**
   * InventoryAlert create
   */
  export type InventoryAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryAlert.
     */
    data: XOR<InventoryAlertCreateInput, InventoryAlertUncheckedCreateInput>
  }

  /**
   * InventoryAlert createMany
   */
  export type InventoryAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryAlerts.
     */
    data: InventoryAlertCreateManyInput | InventoryAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryAlert createManyAndReturn
   */
  export type InventoryAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryAlerts.
     */
    data: InventoryAlertCreateManyInput | InventoryAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryAlert update
   */
  export type InventoryAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryAlert.
     */
    data: XOR<InventoryAlertUpdateInput, InventoryAlertUncheckedUpdateInput>
    /**
     * Choose, which InventoryAlert to update.
     */
    where: InventoryAlertWhereUniqueInput
  }

  /**
   * InventoryAlert updateMany
   */
  export type InventoryAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryAlerts.
     */
    data: XOR<InventoryAlertUpdateManyMutationInput, InventoryAlertUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAlerts to update
     */
    where?: InventoryAlertWhereInput
  }

  /**
   * InventoryAlert upsert
   */
  export type InventoryAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryAlert to update in case it exists.
     */
    where: InventoryAlertWhereUniqueInput
    /**
     * In case the InventoryAlert found by the `where` argument doesn't exist, create a new InventoryAlert with this data.
     */
    create: XOR<InventoryAlertCreateInput, InventoryAlertUncheckedCreateInput>
    /**
     * In case the InventoryAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryAlertUpdateInput, InventoryAlertUncheckedUpdateInput>
  }

  /**
   * InventoryAlert delete
   */
  export type InventoryAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
    /**
     * Filter which InventoryAlert to delete.
     */
    where: InventoryAlertWhereUniqueInput
  }

  /**
   * InventoryAlert deleteMany
   */
  export type InventoryAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAlerts to delete
     */
    where?: InventoryAlertWhereInput
  }

  /**
   * InventoryAlert without action
   */
  export type InventoryAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAlert
     */
    select?: InventoryAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAlertInclude<ExtArgs> | null
  }


  /**
   * Model InventoryReport
   */

  export type AggregateInventoryReport = {
    _count: InventoryReportCountAggregateOutputType | null
    _min: InventoryReportMinAggregateOutputType | null
    _max: InventoryReportMaxAggregateOutputType | null
  }

  export type InventoryReportMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    description: string | null
    parameters: string | null
    data: string | null
    generatedBy: string | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryReportMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    description: string | null
    parameters: string | null
    data: string | null
    generatedBy: string | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryReportCountAggregateOutputType = {
    id: number
    type: number
    title: number
    description: number
    parameters: number
    data: number
    generatedBy: number
    generatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryReportMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    parameters?: true
    data?: true
    generatedBy?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryReportMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    parameters?: true
    data?: true
    generatedBy?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryReportCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    parameters?: true
    data?: true
    generatedBy?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryReport to aggregate.
     */
    where?: InventoryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryReports to fetch.
     */
    orderBy?: InventoryReportOrderByWithRelationInput | InventoryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryReports
    **/
    _count?: true | InventoryReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryReportMaxAggregateInputType
  }

  export type GetInventoryReportAggregateType<T extends InventoryReportAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryReport[P]>
      : GetScalarType<T[P], AggregateInventoryReport[P]>
  }




  export type InventoryReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryReportWhereInput
    orderBy?: InventoryReportOrderByWithAggregationInput | InventoryReportOrderByWithAggregationInput[]
    by: InventoryReportScalarFieldEnum[] | InventoryReportScalarFieldEnum
    having?: InventoryReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryReportCountAggregateInputType | true
    _min?: InventoryReportMinAggregateInputType
    _max?: InventoryReportMaxAggregateInputType
  }

  export type InventoryReportGroupByOutputType = {
    id: string
    type: string
    title: string
    description: string | null
    parameters: string | null
    data: string | null
    generatedBy: string | null
    generatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: InventoryReportCountAggregateOutputType | null
    _min: InventoryReportMinAggregateOutputType | null
    _max: InventoryReportMaxAggregateOutputType | null
  }

  type GetInventoryReportGroupByPayload<T extends InventoryReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryReportGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryReportGroupByOutputType[P]>
        }
      >
    >


  export type InventoryReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    parameters?: boolean
    data?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventoryReport"]>

  export type InventoryReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    parameters?: boolean
    data?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventoryReport"]>

  export type InventoryReportSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    parameters?: boolean
    data?: boolean
    generatedBy?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $InventoryReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      description: string | null
      parameters: string | null
      data: string | null
      generatedBy: string | null
      generatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryReport"]>
    composites: {}
  }

  type InventoryReportGetPayload<S extends boolean | null | undefined | InventoryReportDefaultArgs> = $Result.GetResult<Prisma.$InventoryReportPayload, S>

  type InventoryReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryReportCountAggregateInputType | true
    }

  export interface InventoryReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryReport'], meta: { name: 'InventoryReport' } }
    /**
     * Find zero or one InventoryReport that matches the filter.
     * @param {InventoryReportFindUniqueArgs} args - Arguments to find a InventoryReport
     * @example
     * // Get one InventoryReport
     * const inventoryReport = await prisma.inventoryReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryReportFindUniqueArgs>(args: SelectSubset<T, InventoryReportFindUniqueArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryReportFindUniqueOrThrowArgs} args - Arguments to find a InventoryReport
     * @example
     * // Get one InventoryReport
     * const inventoryReport = await prisma.inventoryReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryReportFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryReportFindFirstArgs} args - Arguments to find a InventoryReport
     * @example
     * // Get one InventoryReport
     * const inventoryReport = await prisma.inventoryReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryReportFindFirstArgs>(args?: SelectSubset<T, InventoryReportFindFirstArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryReportFindFirstOrThrowArgs} args - Arguments to find a InventoryReport
     * @example
     * // Get one InventoryReport
     * const inventoryReport = await prisma.inventoryReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryReportFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryReports
     * const inventoryReports = await prisma.inventoryReport.findMany()
     * 
     * // Get first 10 InventoryReports
     * const inventoryReports = await prisma.inventoryReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryReportWithIdOnly = await prisma.inventoryReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryReportFindManyArgs>(args?: SelectSubset<T, InventoryReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryReport.
     * @param {InventoryReportCreateArgs} args - Arguments to create a InventoryReport.
     * @example
     * // Create one InventoryReport
     * const InventoryReport = await prisma.inventoryReport.create({
     *   data: {
     *     // ... data to create a InventoryReport
     *   }
     * })
     * 
     */
    create<T extends InventoryReportCreateArgs>(args: SelectSubset<T, InventoryReportCreateArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryReports.
     * @param {InventoryReportCreateManyArgs} args - Arguments to create many InventoryReports.
     * @example
     * // Create many InventoryReports
     * const inventoryReport = await prisma.inventoryReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryReportCreateManyArgs>(args?: SelectSubset<T, InventoryReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryReports and returns the data saved in the database.
     * @param {InventoryReportCreateManyAndReturnArgs} args - Arguments to create many InventoryReports.
     * @example
     * // Create many InventoryReports
     * const inventoryReport = await prisma.inventoryReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryReports and only return the `id`
     * const inventoryReportWithIdOnly = await prisma.inventoryReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryReportCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryReport.
     * @param {InventoryReportDeleteArgs} args - Arguments to delete one InventoryReport.
     * @example
     * // Delete one InventoryReport
     * const InventoryReport = await prisma.inventoryReport.delete({
     *   where: {
     *     // ... filter to delete one InventoryReport
     *   }
     * })
     * 
     */
    delete<T extends InventoryReportDeleteArgs>(args: SelectSubset<T, InventoryReportDeleteArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryReport.
     * @param {InventoryReportUpdateArgs} args - Arguments to update one InventoryReport.
     * @example
     * // Update one InventoryReport
     * const inventoryReport = await prisma.inventoryReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryReportUpdateArgs>(args: SelectSubset<T, InventoryReportUpdateArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryReports.
     * @param {InventoryReportDeleteManyArgs} args - Arguments to filter InventoryReports to delete.
     * @example
     * // Delete a few InventoryReports
     * const { count } = await prisma.inventoryReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryReportDeleteManyArgs>(args?: SelectSubset<T, InventoryReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryReports
     * const inventoryReport = await prisma.inventoryReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryReportUpdateManyArgs>(args: SelectSubset<T, InventoryReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryReport.
     * @param {InventoryReportUpsertArgs} args - Arguments to update or create a InventoryReport.
     * @example
     * // Update or create a InventoryReport
     * const inventoryReport = await prisma.inventoryReport.upsert({
     *   create: {
     *     // ... data to create a InventoryReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryReport we want to update
     *   }
     * })
     */
    upsert<T extends InventoryReportUpsertArgs>(args: SelectSubset<T, InventoryReportUpsertArgs<ExtArgs>>): Prisma__InventoryReportClient<$Result.GetResult<Prisma.$InventoryReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryReportCountArgs} args - Arguments to filter InventoryReports to count.
     * @example
     * // Count the number of InventoryReports
     * const count = await prisma.inventoryReport.count({
     *   where: {
     *     // ... the filter for the InventoryReports we want to count
     *   }
     * })
    **/
    count<T extends InventoryReportCountArgs>(
      args?: Subset<T, InventoryReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryReportAggregateArgs>(args: Subset<T, InventoryReportAggregateArgs>): Prisma.PrismaPromise<GetInventoryReportAggregateType<T>>

    /**
     * Group by InventoryReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryReportGroupByArgs['orderBy'] }
        : { orderBy?: InventoryReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryReport model
   */
  readonly fields: InventoryReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryReport model
   */ 
  interface InventoryReportFieldRefs {
    readonly id: FieldRef<"InventoryReport", 'String'>
    readonly type: FieldRef<"InventoryReport", 'String'>
    readonly title: FieldRef<"InventoryReport", 'String'>
    readonly description: FieldRef<"InventoryReport", 'String'>
    readonly parameters: FieldRef<"InventoryReport", 'String'>
    readonly data: FieldRef<"InventoryReport", 'String'>
    readonly generatedBy: FieldRef<"InventoryReport", 'String'>
    readonly generatedAt: FieldRef<"InventoryReport", 'DateTime'>
    readonly createdAt: FieldRef<"InventoryReport", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryReport findUnique
   */
  export type InventoryReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * Filter, which InventoryReport to fetch.
     */
    where: InventoryReportWhereUniqueInput
  }

  /**
   * InventoryReport findUniqueOrThrow
   */
  export type InventoryReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * Filter, which InventoryReport to fetch.
     */
    where: InventoryReportWhereUniqueInput
  }

  /**
   * InventoryReport findFirst
   */
  export type InventoryReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * Filter, which InventoryReport to fetch.
     */
    where?: InventoryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryReports to fetch.
     */
    orderBy?: InventoryReportOrderByWithRelationInput | InventoryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryReports.
     */
    cursor?: InventoryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryReports.
     */
    distinct?: InventoryReportScalarFieldEnum | InventoryReportScalarFieldEnum[]
  }

  /**
   * InventoryReport findFirstOrThrow
   */
  export type InventoryReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * Filter, which InventoryReport to fetch.
     */
    where?: InventoryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryReports to fetch.
     */
    orderBy?: InventoryReportOrderByWithRelationInput | InventoryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryReports.
     */
    cursor?: InventoryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryReports.
     */
    distinct?: InventoryReportScalarFieldEnum | InventoryReportScalarFieldEnum[]
  }

  /**
   * InventoryReport findMany
   */
  export type InventoryReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * Filter, which InventoryReports to fetch.
     */
    where?: InventoryReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryReports to fetch.
     */
    orderBy?: InventoryReportOrderByWithRelationInput | InventoryReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryReports.
     */
    cursor?: InventoryReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryReports.
     */
    skip?: number
    distinct?: InventoryReportScalarFieldEnum | InventoryReportScalarFieldEnum[]
  }

  /**
   * InventoryReport create
   */
  export type InventoryReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * The data needed to create a InventoryReport.
     */
    data: XOR<InventoryReportCreateInput, InventoryReportUncheckedCreateInput>
  }

  /**
   * InventoryReport createMany
   */
  export type InventoryReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryReports.
     */
    data: InventoryReportCreateManyInput | InventoryReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryReport createManyAndReturn
   */
  export type InventoryReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryReports.
     */
    data: InventoryReportCreateManyInput | InventoryReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryReport update
   */
  export type InventoryReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * The data needed to update a InventoryReport.
     */
    data: XOR<InventoryReportUpdateInput, InventoryReportUncheckedUpdateInput>
    /**
     * Choose, which InventoryReport to update.
     */
    where: InventoryReportWhereUniqueInput
  }

  /**
   * InventoryReport updateMany
   */
  export type InventoryReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryReports.
     */
    data: XOR<InventoryReportUpdateManyMutationInput, InventoryReportUncheckedUpdateManyInput>
    /**
     * Filter which InventoryReports to update
     */
    where?: InventoryReportWhereInput
  }

  /**
   * InventoryReport upsert
   */
  export type InventoryReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * The filter to search for the InventoryReport to update in case it exists.
     */
    where: InventoryReportWhereUniqueInput
    /**
     * In case the InventoryReport found by the `where` argument doesn't exist, create a new InventoryReport with this data.
     */
    create: XOR<InventoryReportCreateInput, InventoryReportUncheckedCreateInput>
    /**
     * In case the InventoryReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryReportUpdateInput, InventoryReportUncheckedUpdateInput>
  }

  /**
   * InventoryReport delete
   */
  export type InventoryReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
    /**
     * Filter which InventoryReport to delete.
     */
    where: InventoryReportWhereUniqueInput
  }

  /**
   * InventoryReport deleteMany
   */
  export type InventoryReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryReports to delete
     */
    where?: InventoryReportWhereInput
  }

  /**
   * InventoryReport without action
   */
  export type InventoryReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryReport
     */
    select?: InventoryReportSelect<ExtArgs> | null
  }


  /**
   * Model WishlistItem
   */

  export type AggregateWishlistItem = {
    _count: WishlistItemCountAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  export type WishlistItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type WishlistItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type WishlistItemCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    createdAt: number
    _all: number
  }


  export type WishlistItemMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
  }

  export type WishlistItemMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
  }

  export type WishlistItemCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
    _all?: true
  }

  export type WishlistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItem to aggregate.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistItems
    **/
    _count?: true | WishlistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistItemMaxAggregateInputType
  }

  export type GetWishlistItemAggregateType<T extends WishlistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistItem[P]>
      : GetScalarType<T[P], AggregateWishlistItem[P]>
  }




  export type WishlistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithAggregationInput | WishlistItemOrderByWithAggregationInput[]
    by: WishlistItemScalarFieldEnum[] | WishlistItemScalarFieldEnum
    having?: WishlistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistItemCountAggregateInputType | true
    _min?: WishlistItemMinAggregateInputType
    _max?: WishlistItemMaxAggregateInputType
  }

  export type WishlistItemGroupByOutputType = {
    id: string
    userId: string
    productId: string
    createdAt: Date
    _count: WishlistItemCountAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  type GetWishlistItemGroupByPayload<T extends WishlistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
        }
      >
    >


  export type WishlistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
  }

  export type WishlistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WishlistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WishlistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishlistItem"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      createdAt: Date
    }, ExtArgs["result"]["wishlistItem"]>
    composites: {}
  }

  type WishlistItemGetPayload<S extends boolean | null | undefined | WishlistItemDefaultArgs> = $Result.GetResult<Prisma.$WishlistItemPayload, S>

  type WishlistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WishlistItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WishlistItemCountAggregateInputType | true
    }

  export interface WishlistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishlistItem'], meta: { name: 'WishlistItem' } }
    /**
     * Find zero or one WishlistItem that matches the filter.
     * @param {WishlistItemFindUniqueArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistItemFindUniqueArgs>(args: SelectSubset<T, WishlistItemFindUniqueArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WishlistItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WishlistItemFindUniqueOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WishlistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistItemFindFirstArgs>(args?: SelectSubset<T, WishlistItemFindFirstArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WishlistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WishlistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany()
     * 
     * // Get first 10 WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistItemFindManyArgs>(args?: SelectSubset<T, WishlistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WishlistItem.
     * @param {WishlistItemCreateArgs} args - Arguments to create a WishlistItem.
     * @example
     * // Create one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.create({
     *   data: {
     *     // ... data to create a WishlistItem
     *   }
     * })
     * 
     */
    create<T extends WishlistItemCreateArgs>(args: SelectSubset<T, WishlistItemCreateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WishlistItems.
     * @param {WishlistItemCreateManyArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistItemCreateManyArgs>(args?: SelectSubset<T, WishlistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WishlistItems and returns the data saved in the database.
     * @param {WishlistItemCreateManyAndReturnArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WishlistItems and only return the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishlistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WishlistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WishlistItem.
     * @param {WishlistItemDeleteArgs} args - Arguments to delete one WishlistItem.
     * @example
     * // Delete one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.delete({
     *   where: {
     *     // ... filter to delete one WishlistItem
     *   }
     * })
     * 
     */
    delete<T extends WishlistItemDeleteArgs>(args: SelectSubset<T, WishlistItemDeleteArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WishlistItem.
     * @param {WishlistItemUpdateArgs} args - Arguments to update one WishlistItem.
     * @example
     * // Update one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistItemUpdateArgs>(args: SelectSubset<T, WishlistItemUpdateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WishlistItems.
     * @param {WishlistItemDeleteManyArgs} args - Arguments to filter WishlistItems to delete.
     * @example
     * // Delete a few WishlistItems
     * const { count } = await prisma.wishlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistItemDeleteManyArgs>(args?: SelectSubset<T, WishlistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistItemUpdateManyArgs>(args: SelectSubset<T, WishlistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WishlistItem.
     * @param {WishlistItemUpsertArgs} args - Arguments to update or create a WishlistItem.
     * @example
     * // Update or create a WishlistItem
     * const wishlistItem = await prisma.wishlistItem.upsert({
     *   create: {
     *     // ... data to create a WishlistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistItem we want to update
     *   }
     * })
     */
    upsert<T extends WishlistItemUpsertArgs>(args: SelectSubset<T, WishlistItemUpsertArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemCountArgs} args - Arguments to filter WishlistItems to count.
     * @example
     * // Count the number of WishlistItems
     * const count = await prisma.wishlistItem.count({
     *   where: {
     *     // ... the filter for the WishlistItems we want to count
     *   }
     * })
    **/
    count<T extends WishlistItemCountArgs>(
      args?: Subset<T, WishlistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistItemAggregateArgs>(args: Subset<T, WishlistItemAggregateArgs>): Prisma.PrismaPromise<GetWishlistItemAggregateType<T>>

    /**
     * Group by WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistItemGroupByArgs['orderBy'] }
        : { orderBy?: WishlistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WishlistItem model
   */
  readonly fields: WishlistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WishlistItem model
   */ 
  interface WishlistItemFieldRefs {
    readonly id: FieldRef<"WishlistItem", 'String'>
    readonly userId: FieldRef<"WishlistItem", 'String'>
    readonly productId: FieldRef<"WishlistItem", 'String'>
    readonly createdAt: FieldRef<"WishlistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WishlistItem findUnique
   */
  export type WishlistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findUniqueOrThrow
   */
  export type WishlistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findFirst
   */
  export type WishlistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findFirstOrThrow
   */
  export type WishlistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findMany
   */
  export type WishlistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItems to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem create
   */
  export type WishlistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WishlistItem.
     */
    data: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
  }

  /**
   * WishlistItem createMany
   */
  export type WishlistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WishlistItem createManyAndReturn
   */
  export type WishlistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishlistItem update
   */
  export type WishlistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WishlistItem.
     */
    data: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
    /**
     * Choose, which WishlistItem to update.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem updateMany
   */
  export type WishlistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
  }

  /**
   * WishlistItem upsert
   */
  export type WishlistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WishlistItem to update in case it exists.
     */
    where: WishlistItemWhereUniqueInput
    /**
     * In case the WishlistItem found by the `where` argument doesn't exist, create a new WishlistItem with this data.
     */
    create: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
    /**
     * In case the WishlistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
  }

  /**
   * WishlistItem delete
   */
  export type WishlistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter which WishlistItem to delete.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem deleteMany
   */
  export type WishlistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItems to delete
     */
    where?: WishlistItemWhereInput
  }

  /**
   * WishlistItem without action
   */
  export type WishlistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
  }


  /**
   * Model ProductReview
   */

  export type AggregateProductReview = {
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  export type ProductReviewAvgAggregateOutputType = {
    rating: number | null
    upvotes: number | null
    downvotes: number | null
  }

  export type ProductReviewSumAggregateOutputType = {
    rating: number | null
    upvotes: number | null
    downvotes: number | null
  }

  export type ProductReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    rating: number | null
    title: string | null
    comment: string | null
    isVerified: boolean | null
    status: $Enums.ReviewStatus | null
    upvotes: number | null
    downvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    rating: number | null
    title: string | null
    comment: string | null
    isVerified: boolean | null
    status: $Enums.ReviewStatus | null
    upvotes: number | null
    downvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductReviewCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    rating: number
    title: number
    comment: number
    isVerified: number
    status: number
    upvotes: number
    downvotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductReviewAvgAggregateInputType = {
    rating?: true
    upvotes?: true
    downvotes?: true
  }

  export type ProductReviewSumAggregateInputType = {
    rating?: true
    upvotes?: true
    downvotes?: true
  }

  export type ProductReviewMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    title?: true
    comment?: true
    isVerified?: true
    status?: true
    upvotes?: true
    downvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    title?: true
    comment?: true
    isVerified?: true
    status?: true
    upvotes?: true
    downvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductReviewCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    title?: true
    comment?: true
    isVerified?: true
    status?: true
    upvotes?: true
    downvotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReview to aggregate.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductReviews
    **/
    _count?: true | ProductReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductReviewMaxAggregateInputType
  }

  export type GetProductReviewAggregateType<T extends ProductReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateProductReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReview[P]>
      : GetScalarType<T[P], AggregateProductReview[P]>
  }




  export type ProductReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithAggregationInput | ProductReviewOrderByWithAggregationInput[]
    by: ProductReviewScalarFieldEnum[] | ProductReviewScalarFieldEnum
    having?: ProductReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductReviewCountAggregateInputType | true
    _avg?: ProductReviewAvgAggregateInputType
    _sum?: ProductReviewSumAggregateInputType
    _min?: ProductReviewMinAggregateInputType
    _max?: ProductReviewMaxAggregateInputType
  }

  export type ProductReviewGroupByOutputType = {
    id: string
    userId: string
    productId: string
    rating: number
    title: string | null
    comment: string | null
    isVerified: boolean
    status: $Enums.ReviewStatus
    upvotes: number
    downvotes: number
    createdAt: Date
    updatedAt: Date
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  type GetProductReviewGroupByPayload<T extends ProductReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
        }
      >
    >


  export type ProductReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    isVerified?: boolean
    status?: boolean
    upvotes?: boolean
    downvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reports?: boolean | ProductReview$reportsArgs<ExtArgs>
    votes?: boolean | ProductReview$votesArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProductReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReview"]>

  export type ProductReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    isVerified?: boolean
    status?: boolean
    upvotes?: boolean
    downvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReview"]>

  export type ProductReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    isVerified?: boolean
    status?: boolean
    upvotes?: boolean
    downvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ProductReview$reportsArgs<ExtArgs>
    votes?: boolean | ProductReview$votesArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProductReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductReview"
    objects: {
      reports: Prisma.$ProductReviewReportPayload<ExtArgs>[]
      votes: Prisma.$ProductReviewVotePayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      rating: number
      title: string | null
      comment: string | null
      isVerified: boolean
      status: $Enums.ReviewStatus
      upvotes: number
      downvotes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productReview"]>
    composites: {}
  }

  type ProductReviewGetPayload<S extends boolean | null | undefined | ProductReviewDefaultArgs> = $Result.GetResult<Prisma.$ProductReviewPayload, S>

  type ProductReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductReviewCountAggregateInputType | true
    }

  export interface ProductReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductReview'], meta: { name: 'ProductReview' } }
    /**
     * Find zero or one ProductReview that matches the filter.
     * @param {ProductReviewFindUniqueArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductReviewFindUniqueArgs>(args: SelectSubset<T, ProductReviewFindUniqueArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductReviewFindUniqueOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductReviewFindFirstArgs>(args?: SelectSubset<T, ProductReviewFindFirstArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReviews
     * const productReviews = await prisma.productReview.findMany()
     * 
     * // Get first 10 ProductReviews
     * const productReviews = await prisma.productReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productReviewWithIdOnly = await prisma.productReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductReviewFindManyArgs>(args?: SelectSubset<T, ProductReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductReview.
     * @param {ProductReviewCreateArgs} args - Arguments to create a ProductReview.
     * @example
     * // Create one ProductReview
     * const ProductReview = await prisma.productReview.create({
     *   data: {
     *     // ... data to create a ProductReview
     *   }
     * })
     * 
     */
    create<T extends ProductReviewCreateArgs>(args: SelectSubset<T, ProductReviewCreateArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductReviews.
     * @param {ProductReviewCreateManyArgs} args - Arguments to create many ProductReviews.
     * @example
     * // Create many ProductReviews
     * const productReview = await prisma.productReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductReviewCreateManyArgs>(args?: SelectSubset<T, ProductReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductReviews and returns the data saved in the database.
     * @param {ProductReviewCreateManyAndReturnArgs} args - Arguments to create many ProductReviews.
     * @example
     * // Create many ProductReviews
     * const productReview = await prisma.productReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductReviews and only return the `id`
     * const productReviewWithIdOnly = await prisma.productReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductReview.
     * @param {ProductReviewDeleteArgs} args - Arguments to delete one ProductReview.
     * @example
     * // Delete one ProductReview
     * const ProductReview = await prisma.productReview.delete({
     *   where: {
     *     // ... filter to delete one ProductReview
     *   }
     * })
     * 
     */
    delete<T extends ProductReviewDeleteArgs>(args: SelectSubset<T, ProductReviewDeleteArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductReview.
     * @param {ProductReviewUpdateArgs} args - Arguments to update one ProductReview.
     * @example
     * // Update one ProductReview
     * const productReview = await prisma.productReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductReviewUpdateArgs>(args: SelectSubset<T, ProductReviewUpdateArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductReviews.
     * @param {ProductReviewDeleteManyArgs} args - Arguments to filter ProductReviews to delete.
     * @example
     * // Delete a few ProductReviews
     * const { count } = await prisma.productReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductReviewDeleteManyArgs>(args?: SelectSubset<T, ProductReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReviews
     * const productReview = await prisma.productReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductReviewUpdateManyArgs>(args: SelectSubset<T, ProductReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductReview.
     * @param {ProductReviewUpsertArgs} args - Arguments to update or create a ProductReview.
     * @example
     * // Update or create a ProductReview
     * const productReview = await prisma.productReview.upsert({
     *   create: {
     *     // ... data to create a ProductReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReview we want to update
     *   }
     * })
     */
    upsert<T extends ProductReviewUpsertArgs>(args: SelectSubset<T, ProductReviewUpsertArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewCountArgs} args - Arguments to filter ProductReviews to count.
     * @example
     * // Count the number of ProductReviews
     * const count = await prisma.productReview.count({
     *   where: {
     *     // ... the filter for the ProductReviews we want to count
     *   }
     * })
    **/
    count<T extends ProductReviewCountArgs>(
      args?: Subset<T, ProductReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductReviewAggregateArgs>(args: Subset<T, ProductReviewAggregateArgs>): Prisma.PrismaPromise<GetProductReviewAggregateType<T>>

    /**
     * Group by ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReviewGroupByArgs['orderBy'] }
        : { orderBy?: ProductReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductReview model
   */
  readonly fields: ProductReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reports<T extends ProductReview$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ProductReview$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "findMany"> | Null>
    votes<T extends ProductReview$votesArgs<ExtArgs> = {}>(args?: Subset<T, ProductReview$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "findMany"> | Null>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductReview model
   */ 
  interface ProductReviewFieldRefs {
    readonly id: FieldRef<"ProductReview", 'String'>
    readonly userId: FieldRef<"ProductReview", 'String'>
    readonly productId: FieldRef<"ProductReview", 'String'>
    readonly rating: FieldRef<"ProductReview", 'Int'>
    readonly title: FieldRef<"ProductReview", 'String'>
    readonly comment: FieldRef<"ProductReview", 'String'>
    readonly isVerified: FieldRef<"ProductReview", 'Boolean'>
    readonly status: FieldRef<"ProductReview", 'ReviewStatus'>
    readonly upvotes: FieldRef<"ProductReview", 'Int'>
    readonly downvotes: FieldRef<"ProductReview", 'Int'>
    readonly createdAt: FieldRef<"ProductReview", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductReview findUnique
   */
  export type ProductReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview findUniqueOrThrow
   */
  export type ProductReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview findFirst
   */
  export type ProductReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview findFirstOrThrow
   */
  export type ProductReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview findMany
   */
  export type ProductReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviews to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview create
   */
  export type ProductReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductReview.
     */
    data: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
  }

  /**
   * ProductReview createMany
   */
  export type ProductReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductReviews.
     */
    data: ProductReviewCreateManyInput | ProductReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductReview createManyAndReturn
   */
  export type ProductReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductReviews.
     */
    data: ProductReviewCreateManyInput | ProductReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductReview update
   */
  export type ProductReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductReview.
     */
    data: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
    /**
     * Choose, which ProductReview to update.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview updateMany
   */
  export type ProductReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductReviews.
     */
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyInput>
    /**
     * Filter which ProductReviews to update
     */
    where?: ProductReviewWhereInput
  }

  /**
   * ProductReview upsert
   */
  export type ProductReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductReview to update in case it exists.
     */
    where: ProductReviewWhereUniqueInput
    /**
     * In case the ProductReview found by the `where` argument doesn't exist, create a new ProductReview with this data.
     */
    create: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
    /**
     * In case the ProductReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
  }

  /**
   * ProductReview delete
   */
  export type ProductReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter which ProductReview to delete.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview deleteMany
   */
  export type ProductReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviews to delete
     */
    where?: ProductReviewWhereInput
  }

  /**
   * ProductReview.reports
   */
  export type ProductReview$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    where?: ProductReviewReportWhereInput
    orderBy?: ProductReviewReportOrderByWithRelationInput | ProductReviewReportOrderByWithRelationInput[]
    cursor?: ProductReviewReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewReportScalarFieldEnum | ProductReviewReportScalarFieldEnum[]
  }

  /**
   * ProductReview.votes
   */
  export type ProductReview$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    where?: ProductReviewVoteWhereInput
    orderBy?: ProductReviewVoteOrderByWithRelationInput | ProductReviewVoteOrderByWithRelationInput[]
    cursor?: ProductReviewVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewVoteScalarFieldEnum | ProductReviewVoteScalarFieldEnum[]
  }

  /**
   * ProductReview without action
   */
  export type ProductReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
  }


  /**
   * Model ProductReviewVote
   */

  export type AggregateProductReviewVote = {
    _count: ProductReviewVoteCountAggregateOutputType | null
    _min: ProductReviewVoteMinAggregateOutputType | null
    _max: ProductReviewVoteMaxAggregateOutputType | null
  }

  export type ProductReviewVoteMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    isUpvote: boolean | null
    createdAt: Date | null
  }

  export type ProductReviewVoteMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    isUpvote: boolean | null
    createdAt: Date | null
  }

  export type ProductReviewVoteCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    isUpvote: number
    createdAt: number
    _all: number
  }


  export type ProductReviewVoteMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    isUpvote?: true
    createdAt?: true
  }

  export type ProductReviewVoteMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    isUpvote?: true
    createdAt?: true
  }

  export type ProductReviewVoteCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    isUpvote?: true
    createdAt?: true
    _all?: true
  }

  export type ProductReviewVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviewVote to aggregate.
     */
    where?: ProductReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewVotes to fetch.
     */
    orderBy?: ProductReviewVoteOrderByWithRelationInput | ProductReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductReviewVotes
    **/
    _count?: true | ProductReviewVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductReviewVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductReviewVoteMaxAggregateInputType
  }

  export type GetProductReviewVoteAggregateType<T extends ProductReviewVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateProductReviewVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReviewVote[P]>
      : GetScalarType<T[P], AggregateProductReviewVote[P]>
  }




  export type ProductReviewVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewVoteWhereInput
    orderBy?: ProductReviewVoteOrderByWithAggregationInput | ProductReviewVoteOrderByWithAggregationInput[]
    by: ProductReviewVoteScalarFieldEnum[] | ProductReviewVoteScalarFieldEnum
    having?: ProductReviewVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductReviewVoteCountAggregateInputType | true
    _min?: ProductReviewVoteMinAggregateInputType
    _max?: ProductReviewVoteMaxAggregateInputType
  }

  export type ProductReviewVoteGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    isUpvote: boolean
    createdAt: Date
    _count: ProductReviewVoteCountAggregateOutputType | null
    _min: ProductReviewVoteMinAggregateOutputType | null
    _max: ProductReviewVoteMaxAggregateOutputType | null
  }

  type GetProductReviewVoteGroupByPayload<T extends ProductReviewVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductReviewVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductReviewVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReviewVoteGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReviewVoteGroupByOutputType[P]>
        }
      >
    >


  export type ProductReviewVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    isUpvote?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReviewVote"]>

  export type ProductReviewVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    isUpvote?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReviewVote"]>

  export type ProductReviewVoteSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    isUpvote?: boolean
    createdAt?: boolean
  }

  export type ProductReviewVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }
  export type ProductReviewVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }

  export type $ProductReviewVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductReviewVote"
    objects: {
      review: Prisma.$ProductReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      isUpvote: boolean
      createdAt: Date
    }, ExtArgs["result"]["productReviewVote"]>
    composites: {}
  }

  type ProductReviewVoteGetPayload<S extends boolean | null | undefined | ProductReviewVoteDefaultArgs> = $Result.GetResult<Prisma.$ProductReviewVotePayload, S>

  type ProductReviewVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductReviewVoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductReviewVoteCountAggregateInputType | true
    }

  export interface ProductReviewVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductReviewVote'], meta: { name: 'ProductReviewVote' } }
    /**
     * Find zero or one ProductReviewVote that matches the filter.
     * @param {ProductReviewVoteFindUniqueArgs} args - Arguments to find a ProductReviewVote
     * @example
     * // Get one ProductReviewVote
     * const productReviewVote = await prisma.productReviewVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductReviewVoteFindUniqueArgs>(args: SelectSubset<T, ProductReviewVoteFindUniqueArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductReviewVote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductReviewVoteFindUniqueOrThrowArgs} args - Arguments to find a ProductReviewVote
     * @example
     * // Get one ProductReviewVote
     * const productReviewVote = await prisma.productReviewVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductReviewVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductReviewVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductReviewVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewVoteFindFirstArgs} args - Arguments to find a ProductReviewVote
     * @example
     * // Get one ProductReviewVote
     * const productReviewVote = await prisma.productReviewVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductReviewVoteFindFirstArgs>(args?: SelectSubset<T, ProductReviewVoteFindFirstArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductReviewVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewVoteFindFirstOrThrowArgs} args - Arguments to find a ProductReviewVote
     * @example
     * // Get one ProductReviewVote
     * const productReviewVote = await prisma.productReviewVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductReviewVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductReviewVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductReviewVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReviewVotes
     * const productReviewVotes = await prisma.productReviewVote.findMany()
     * 
     * // Get first 10 ProductReviewVotes
     * const productReviewVotes = await prisma.productReviewVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productReviewVoteWithIdOnly = await prisma.productReviewVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductReviewVoteFindManyArgs>(args?: SelectSubset<T, ProductReviewVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductReviewVote.
     * @param {ProductReviewVoteCreateArgs} args - Arguments to create a ProductReviewVote.
     * @example
     * // Create one ProductReviewVote
     * const ProductReviewVote = await prisma.productReviewVote.create({
     *   data: {
     *     // ... data to create a ProductReviewVote
     *   }
     * })
     * 
     */
    create<T extends ProductReviewVoteCreateArgs>(args: SelectSubset<T, ProductReviewVoteCreateArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductReviewVotes.
     * @param {ProductReviewVoteCreateManyArgs} args - Arguments to create many ProductReviewVotes.
     * @example
     * // Create many ProductReviewVotes
     * const productReviewVote = await prisma.productReviewVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductReviewVoteCreateManyArgs>(args?: SelectSubset<T, ProductReviewVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductReviewVotes and returns the data saved in the database.
     * @param {ProductReviewVoteCreateManyAndReturnArgs} args - Arguments to create many ProductReviewVotes.
     * @example
     * // Create many ProductReviewVotes
     * const productReviewVote = await prisma.productReviewVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductReviewVotes and only return the `id`
     * const productReviewVoteWithIdOnly = await prisma.productReviewVote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductReviewVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductReviewVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductReviewVote.
     * @param {ProductReviewVoteDeleteArgs} args - Arguments to delete one ProductReviewVote.
     * @example
     * // Delete one ProductReviewVote
     * const ProductReviewVote = await prisma.productReviewVote.delete({
     *   where: {
     *     // ... filter to delete one ProductReviewVote
     *   }
     * })
     * 
     */
    delete<T extends ProductReviewVoteDeleteArgs>(args: SelectSubset<T, ProductReviewVoteDeleteArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductReviewVote.
     * @param {ProductReviewVoteUpdateArgs} args - Arguments to update one ProductReviewVote.
     * @example
     * // Update one ProductReviewVote
     * const productReviewVote = await prisma.productReviewVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductReviewVoteUpdateArgs>(args: SelectSubset<T, ProductReviewVoteUpdateArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductReviewVotes.
     * @param {ProductReviewVoteDeleteManyArgs} args - Arguments to filter ProductReviewVotes to delete.
     * @example
     * // Delete a few ProductReviewVotes
     * const { count } = await prisma.productReviewVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductReviewVoteDeleteManyArgs>(args?: SelectSubset<T, ProductReviewVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReviewVotes
     * const productReviewVote = await prisma.productReviewVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductReviewVoteUpdateManyArgs>(args: SelectSubset<T, ProductReviewVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductReviewVote.
     * @param {ProductReviewVoteUpsertArgs} args - Arguments to update or create a ProductReviewVote.
     * @example
     * // Update or create a ProductReviewVote
     * const productReviewVote = await prisma.productReviewVote.upsert({
     *   create: {
     *     // ... data to create a ProductReviewVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReviewVote we want to update
     *   }
     * })
     */
    upsert<T extends ProductReviewVoteUpsertArgs>(args: SelectSubset<T, ProductReviewVoteUpsertArgs<ExtArgs>>): Prisma__ProductReviewVoteClient<$Result.GetResult<Prisma.$ProductReviewVotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewVoteCountArgs} args - Arguments to filter ProductReviewVotes to count.
     * @example
     * // Count the number of ProductReviewVotes
     * const count = await prisma.productReviewVote.count({
     *   where: {
     *     // ... the filter for the ProductReviewVotes we want to count
     *   }
     * })
    **/
    count<T extends ProductReviewVoteCountArgs>(
      args?: Subset<T, ProductReviewVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductReviewVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductReviewVoteAggregateArgs>(args: Subset<T, ProductReviewVoteAggregateArgs>): Prisma.PrismaPromise<GetProductReviewVoteAggregateType<T>>

    /**
     * Group by ProductReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductReviewVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReviewVoteGroupByArgs['orderBy'] }
        : { orderBy?: ProductReviewVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductReviewVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductReviewVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductReviewVote model
   */
  readonly fields: ProductReviewVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReviewVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductReviewVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ProductReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductReviewDefaultArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductReviewVote model
   */ 
  interface ProductReviewVoteFieldRefs {
    readonly id: FieldRef<"ProductReviewVote", 'String'>
    readonly reviewId: FieldRef<"ProductReviewVote", 'String'>
    readonly userId: FieldRef<"ProductReviewVote", 'String'>
    readonly isUpvote: FieldRef<"ProductReviewVote", 'Boolean'>
    readonly createdAt: FieldRef<"ProductReviewVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductReviewVote findUnique
   */
  export type ProductReviewVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewVote to fetch.
     */
    where: ProductReviewVoteWhereUniqueInput
  }

  /**
   * ProductReviewVote findUniqueOrThrow
   */
  export type ProductReviewVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewVote to fetch.
     */
    where: ProductReviewVoteWhereUniqueInput
  }

  /**
   * ProductReviewVote findFirst
   */
  export type ProductReviewVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewVote to fetch.
     */
    where?: ProductReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewVotes to fetch.
     */
    orderBy?: ProductReviewVoteOrderByWithRelationInput | ProductReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviewVotes.
     */
    cursor?: ProductReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviewVotes.
     */
    distinct?: ProductReviewVoteScalarFieldEnum | ProductReviewVoteScalarFieldEnum[]
  }

  /**
   * ProductReviewVote findFirstOrThrow
   */
  export type ProductReviewVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewVote to fetch.
     */
    where?: ProductReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewVotes to fetch.
     */
    orderBy?: ProductReviewVoteOrderByWithRelationInput | ProductReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviewVotes.
     */
    cursor?: ProductReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviewVotes.
     */
    distinct?: ProductReviewVoteScalarFieldEnum | ProductReviewVoteScalarFieldEnum[]
  }

  /**
   * ProductReviewVote findMany
   */
  export type ProductReviewVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewVotes to fetch.
     */
    where?: ProductReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewVotes to fetch.
     */
    orderBy?: ProductReviewVoteOrderByWithRelationInput | ProductReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductReviewVotes.
     */
    cursor?: ProductReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewVotes.
     */
    skip?: number
    distinct?: ProductReviewVoteScalarFieldEnum | ProductReviewVoteScalarFieldEnum[]
  }

  /**
   * ProductReviewVote create
   */
  export type ProductReviewVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductReviewVote.
     */
    data: XOR<ProductReviewVoteCreateInput, ProductReviewVoteUncheckedCreateInput>
  }

  /**
   * ProductReviewVote createMany
   */
  export type ProductReviewVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductReviewVotes.
     */
    data: ProductReviewVoteCreateManyInput | ProductReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductReviewVote createManyAndReturn
   */
  export type ProductReviewVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductReviewVotes.
     */
    data: ProductReviewVoteCreateManyInput | ProductReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductReviewVote update
   */
  export type ProductReviewVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductReviewVote.
     */
    data: XOR<ProductReviewVoteUpdateInput, ProductReviewVoteUncheckedUpdateInput>
    /**
     * Choose, which ProductReviewVote to update.
     */
    where: ProductReviewVoteWhereUniqueInput
  }

  /**
   * ProductReviewVote updateMany
   */
  export type ProductReviewVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductReviewVotes.
     */
    data: XOR<ProductReviewVoteUpdateManyMutationInput, ProductReviewVoteUncheckedUpdateManyInput>
    /**
     * Filter which ProductReviewVotes to update
     */
    where?: ProductReviewVoteWhereInput
  }

  /**
   * ProductReviewVote upsert
   */
  export type ProductReviewVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductReviewVote to update in case it exists.
     */
    where: ProductReviewVoteWhereUniqueInput
    /**
     * In case the ProductReviewVote found by the `where` argument doesn't exist, create a new ProductReviewVote with this data.
     */
    create: XOR<ProductReviewVoteCreateInput, ProductReviewVoteUncheckedCreateInput>
    /**
     * In case the ProductReviewVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReviewVoteUpdateInput, ProductReviewVoteUncheckedUpdateInput>
  }

  /**
   * ProductReviewVote delete
   */
  export type ProductReviewVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
    /**
     * Filter which ProductReviewVote to delete.
     */
    where: ProductReviewVoteWhereUniqueInput
  }

  /**
   * ProductReviewVote deleteMany
   */
  export type ProductReviewVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviewVotes to delete
     */
    where?: ProductReviewVoteWhereInput
  }

  /**
   * ProductReviewVote without action
   */
  export type ProductReviewVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewVote
     */
    select?: ProductReviewVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewVoteInclude<ExtArgs> | null
  }


  /**
   * Model ProductReviewReport
   */

  export type AggregateProductReviewReport = {
    _count: ProductReviewReportCountAggregateOutputType | null
    _min: ProductReviewReportMinAggregateOutputType | null
    _max: ProductReviewReportMaxAggregateOutputType | null
  }

  export type ProductReviewReportMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ProductReviewReportMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ProductReviewReportCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ProductReviewReportMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ProductReviewReportMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ProductReviewReportCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ProductReviewReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviewReport to aggregate.
     */
    where?: ProductReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewReports to fetch.
     */
    orderBy?: ProductReviewReportOrderByWithRelationInput | ProductReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductReviewReports
    **/
    _count?: true | ProductReviewReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductReviewReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductReviewReportMaxAggregateInputType
  }

  export type GetProductReviewReportAggregateType<T extends ProductReviewReportAggregateArgs> = {
        [P in keyof T & keyof AggregateProductReviewReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReviewReport[P]>
      : GetScalarType<T[P], AggregateProductReviewReport[P]>
  }




  export type ProductReviewReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewReportWhereInput
    orderBy?: ProductReviewReportOrderByWithAggregationInput | ProductReviewReportOrderByWithAggregationInput[]
    by: ProductReviewReportScalarFieldEnum[] | ProductReviewReportScalarFieldEnum
    having?: ProductReviewReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductReviewReportCountAggregateInputType | true
    _min?: ProductReviewReportMinAggregateInputType
    _max?: ProductReviewReportMaxAggregateInputType
  }

  export type ProductReviewReportGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    reason: string
    createdAt: Date
    _count: ProductReviewReportCountAggregateOutputType | null
    _min: ProductReviewReportMinAggregateOutputType | null
    _max: ProductReviewReportMaxAggregateOutputType | null
  }

  type GetProductReviewReportGroupByPayload<T extends ProductReviewReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductReviewReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductReviewReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReviewReportGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReviewReportGroupByOutputType[P]>
        }
      >
    >


  export type ProductReviewReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReviewReport"]>

  export type ProductReviewReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReviewReport"]>

  export type ProductReviewReportSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ProductReviewReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }
  export type ProductReviewReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ProductReviewDefaultArgs<ExtArgs>
  }

  export type $ProductReviewReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductReviewReport"
    objects: {
      review: Prisma.$ProductReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["productReviewReport"]>
    composites: {}
  }

  type ProductReviewReportGetPayload<S extends boolean | null | undefined | ProductReviewReportDefaultArgs> = $Result.GetResult<Prisma.$ProductReviewReportPayload, S>

  type ProductReviewReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductReviewReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductReviewReportCountAggregateInputType | true
    }

  export interface ProductReviewReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductReviewReport'], meta: { name: 'ProductReviewReport' } }
    /**
     * Find zero or one ProductReviewReport that matches the filter.
     * @param {ProductReviewReportFindUniqueArgs} args - Arguments to find a ProductReviewReport
     * @example
     * // Get one ProductReviewReport
     * const productReviewReport = await prisma.productReviewReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductReviewReportFindUniqueArgs>(args: SelectSubset<T, ProductReviewReportFindUniqueArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductReviewReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductReviewReportFindUniqueOrThrowArgs} args - Arguments to find a ProductReviewReport
     * @example
     * // Get one ProductReviewReport
     * const productReviewReport = await prisma.productReviewReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductReviewReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductReviewReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductReviewReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewReportFindFirstArgs} args - Arguments to find a ProductReviewReport
     * @example
     * // Get one ProductReviewReport
     * const productReviewReport = await prisma.productReviewReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductReviewReportFindFirstArgs>(args?: SelectSubset<T, ProductReviewReportFindFirstArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductReviewReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewReportFindFirstOrThrowArgs} args - Arguments to find a ProductReviewReport
     * @example
     * // Get one ProductReviewReport
     * const productReviewReport = await prisma.productReviewReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductReviewReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductReviewReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductReviewReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReviewReports
     * const productReviewReports = await prisma.productReviewReport.findMany()
     * 
     * // Get first 10 ProductReviewReports
     * const productReviewReports = await prisma.productReviewReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productReviewReportWithIdOnly = await prisma.productReviewReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductReviewReportFindManyArgs>(args?: SelectSubset<T, ProductReviewReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductReviewReport.
     * @param {ProductReviewReportCreateArgs} args - Arguments to create a ProductReviewReport.
     * @example
     * // Create one ProductReviewReport
     * const ProductReviewReport = await prisma.productReviewReport.create({
     *   data: {
     *     // ... data to create a ProductReviewReport
     *   }
     * })
     * 
     */
    create<T extends ProductReviewReportCreateArgs>(args: SelectSubset<T, ProductReviewReportCreateArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductReviewReports.
     * @param {ProductReviewReportCreateManyArgs} args - Arguments to create many ProductReviewReports.
     * @example
     * // Create many ProductReviewReports
     * const productReviewReport = await prisma.productReviewReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductReviewReportCreateManyArgs>(args?: SelectSubset<T, ProductReviewReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductReviewReports and returns the data saved in the database.
     * @param {ProductReviewReportCreateManyAndReturnArgs} args - Arguments to create many ProductReviewReports.
     * @example
     * // Create many ProductReviewReports
     * const productReviewReport = await prisma.productReviewReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductReviewReports and only return the `id`
     * const productReviewReportWithIdOnly = await prisma.productReviewReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductReviewReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductReviewReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductReviewReport.
     * @param {ProductReviewReportDeleteArgs} args - Arguments to delete one ProductReviewReport.
     * @example
     * // Delete one ProductReviewReport
     * const ProductReviewReport = await prisma.productReviewReport.delete({
     *   where: {
     *     // ... filter to delete one ProductReviewReport
     *   }
     * })
     * 
     */
    delete<T extends ProductReviewReportDeleteArgs>(args: SelectSubset<T, ProductReviewReportDeleteArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductReviewReport.
     * @param {ProductReviewReportUpdateArgs} args - Arguments to update one ProductReviewReport.
     * @example
     * // Update one ProductReviewReport
     * const productReviewReport = await prisma.productReviewReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductReviewReportUpdateArgs>(args: SelectSubset<T, ProductReviewReportUpdateArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductReviewReports.
     * @param {ProductReviewReportDeleteManyArgs} args - Arguments to filter ProductReviewReports to delete.
     * @example
     * // Delete a few ProductReviewReports
     * const { count } = await prisma.productReviewReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductReviewReportDeleteManyArgs>(args?: SelectSubset<T, ProductReviewReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReviewReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReviewReports
     * const productReviewReport = await prisma.productReviewReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductReviewReportUpdateManyArgs>(args: SelectSubset<T, ProductReviewReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductReviewReport.
     * @param {ProductReviewReportUpsertArgs} args - Arguments to update or create a ProductReviewReport.
     * @example
     * // Update or create a ProductReviewReport
     * const productReviewReport = await prisma.productReviewReport.upsert({
     *   create: {
     *     // ... data to create a ProductReviewReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReviewReport we want to update
     *   }
     * })
     */
    upsert<T extends ProductReviewReportUpsertArgs>(args: SelectSubset<T, ProductReviewReportUpsertArgs<ExtArgs>>): Prisma__ProductReviewReportClient<$Result.GetResult<Prisma.$ProductReviewReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductReviewReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewReportCountArgs} args - Arguments to filter ProductReviewReports to count.
     * @example
     * // Count the number of ProductReviewReports
     * const count = await prisma.productReviewReport.count({
     *   where: {
     *     // ... the filter for the ProductReviewReports we want to count
     *   }
     * })
    **/
    count<T extends ProductReviewReportCountArgs>(
      args?: Subset<T, ProductReviewReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductReviewReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductReviewReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductReviewReportAggregateArgs>(args: Subset<T, ProductReviewReportAggregateArgs>): Prisma.PrismaPromise<GetProductReviewReportAggregateType<T>>

    /**
     * Group by ProductReviewReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductReviewReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReviewReportGroupByArgs['orderBy'] }
        : { orderBy?: ProductReviewReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductReviewReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductReviewReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductReviewReport model
   */
  readonly fields: ProductReviewReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReviewReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductReviewReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ProductReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductReviewDefaultArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductReviewReport model
   */ 
  interface ProductReviewReportFieldRefs {
    readonly id: FieldRef<"ProductReviewReport", 'String'>
    readonly reviewId: FieldRef<"ProductReviewReport", 'String'>
    readonly userId: FieldRef<"ProductReviewReport", 'String'>
    readonly reason: FieldRef<"ProductReviewReport", 'String'>
    readonly createdAt: FieldRef<"ProductReviewReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductReviewReport findUnique
   */
  export type ProductReviewReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewReport to fetch.
     */
    where: ProductReviewReportWhereUniqueInput
  }

  /**
   * ProductReviewReport findUniqueOrThrow
   */
  export type ProductReviewReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewReport to fetch.
     */
    where: ProductReviewReportWhereUniqueInput
  }

  /**
   * ProductReviewReport findFirst
   */
  export type ProductReviewReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewReport to fetch.
     */
    where?: ProductReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewReports to fetch.
     */
    orderBy?: ProductReviewReportOrderByWithRelationInput | ProductReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviewReports.
     */
    cursor?: ProductReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviewReports.
     */
    distinct?: ProductReviewReportScalarFieldEnum | ProductReviewReportScalarFieldEnum[]
  }

  /**
   * ProductReviewReport findFirstOrThrow
   */
  export type ProductReviewReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewReport to fetch.
     */
    where?: ProductReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewReports to fetch.
     */
    orderBy?: ProductReviewReportOrderByWithRelationInput | ProductReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviewReports.
     */
    cursor?: ProductReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviewReports.
     */
    distinct?: ProductReviewReportScalarFieldEnum | ProductReviewReportScalarFieldEnum[]
  }

  /**
   * ProductReviewReport findMany
   */
  export type ProductReviewReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviewReports to fetch.
     */
    where?: ProductReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviewReports to fetch.
     */
    orderBy?: ProductReviewReportOrderByWithRelationInput | ProductReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductReviewReports.
     */
    cursor?: ProductReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviewReports.
     */
    skip?: number
    distinct?: ProductReviewReportScalarFieldEnum | ProductReviewReportScalarFieldEnum[]
  }

  /**
   * ProductReviewReport create
   */
  export type ProductReviewReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductReviewReport.
     */
    data: XOR<ProductReviewReportCreateInput, ProductReviewReportUncheckedCreateInput>
  }

  /**
   * ProductReviewReport createMany
   */
  export type ProductReviewReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductReviewReports.
     */
    data: ProductReviewReportCreateManyInput | ProductReviewReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductReviewReport createManyAndReturn
   */
  export type ProductReviewReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductReviewReports.
     */
    data: ProductReviewReportCreateManyInput | ProductReviewReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductReviewReport update
   */
  export type ProductReviewReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductReviewReport.
     */
    data: XOR<ProductReviewReportUpdateInput, ProductReviewReportUncheckedUpdateInput>
    /**
     * Choose, which ProductReviewReport to update.
     */
    where: ProductReviewReportWhereUniqueInput
  }

  /**
   * ProductReviewReport updateMany
   */
  export type ProductReviewReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductReviewReports.
     */
    data: XOR<ProductReviewReportUpdateManyMutationInput, ProductReviewReportUncheckedUpdateManyInput>
    /**
     * Filter which ProductReviewReports to update
     */
    where?: ProductReviewReportWhereInput
  }

  /**
   * ProductReviewReport upsert
   */
  export type ProductReviewReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductReviewReport to update in case it exists.
     */
    where: ProductReviewReportWhereUniqueInput
    /**
     * In case the ProductReviewReport found by the `where` argument doesn't exist, create a new ProductReviewReport with this data.
     */
    create: XOR<ProductReviewReportCreateInput, ProductReviewReportUncheckedCreateInput>
    /**
     * In case the ProductReviewReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReviewReportUpdateInput, ProductReviewReportUncheckedUpdateInput>
  }

  /**
   * ProductReviewReport delete
   */
  export type ProductReviewReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
    /**
     * Filter which ProductReviewReport to delete.
     */
    where: ProductReviewReportWhereUniqueInput
  }

  /**
   * ProductReviewReport deleteMany
   */
  export type ProductReviewReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviewReports to delete
     */
    where?: ProductReviewReportWhereInput
  }

  /**
   * ProductReviewReport without action
   */
  export type ProductReviewReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReviewReport
     */
    select?: ProductReviewReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewReportInclude<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    content: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    content: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    content: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: string
    slug: string
    title: string
    content: string
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      content: string
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */ 
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly title: FieldRef<"Page", 'String'>
    readonly content: FieldRef<"Page", 'String'>
    readonly isPublished: FieldRef<"Page", 'Boolean'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
  }


  /**
   * Model SearchQuery
   */

  export type AggregateSearchQuery = {
    _count: SearchQueryCountAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  export type SearchQueryMinAggregateOutputType = {
    id: string | null
    query: string | null
    userId: string | null
    timestamp: Date | null
  }

  export type SearchQueryMaxAggregateOutputType = {
    id: string | null
    query: string | null
    userId: string | null
    timestamp: Date | null
  }

  export type SearchQueryCountAggregateOutputType = {
    id: number
    query: number
    userId: number
    timestamp: number
    _all: number
  }


  export type SearchQueryMinAggregateInputType = {
    id?: true
    query?: true
    userId?: true
    timestamp?: true
  }

  export type SearchQueryMaxAggregateInputType = {
    id?: true
    query?: true
    userId?: true
    timestamp?: true
  }

  export type SearchQueryCountAggregateInputType = {
    id?: true
    query?: true
    userId?: true
    timestamp?: true
    _all?: true
  }

  export type SearchQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQuery to aggregate.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchQueries
    **/
    _count?: true | SearchQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchQueryMaxAggregateInputType
  }

  export type GetSearchQueryAggregateType<T extends SearchQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchQuery[P]>
      : GetScalarType<T[P], AggregateSearchQuery[P]>
  }




  export type SearchQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithAggregationInput | SearchQueryOrderByWithAggregationInput[]
    by: SearchQueryScalarFieldEnum[] | SearchQueryScalarFieldEnum
    having?: SearchQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchQueryCountAggregateInputType | true
    _min?: SearchQueryMinAggregateInputType
    _max?: SearchQueryMaxAggregateInputType
  }

  export type SearchQueryGroupByOutputType = {
    id: string
    query: string
    userId: string | null
    timestamp: Date
    _count: SearchQueryCountAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  type GetSearchQueryGroupByPayload<T extends SearchQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
        }
      >
    >


  export type SearchQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    userId?: boolean
    timestamp?: boolean
    user?: boolean | SearchQuery$userArgs<ExtArgs>
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    userId?: boolean
    timestamp?: boolean
    user?: boolean | SearchQuery$userArgs<ExtArgs>
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectScalar = {
    id?: boolean
    query?: boolean
    userId?: boolean
    timestamp?: boolean
  }

  export type SearchQueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SearchQuery$userArgs<ExtArgs>
  }
  export type SearchQueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SearchQuery$userArgs<ExtArgs>
  }

  export type $SearchQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchQuery"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      userId: string | null
      timestamp: Date
    }, ExtArgs["result"]["searchQuery"]>
    composites: {}
  }

  type SearchQueryGetPayload<S extends boolean | null | undefined | SearchQueryDefaultArgs> = $Result.GetResult<Prisma.$SearchQueryPayload, S>

  type SearchQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SearchQueryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SearchQueryCountAggregateInputType | true
    }

  export interface SearchQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchQuery'], meta: { name: 'SearchQuery' } }
    /**
     * Find zero or one SearchQuery that matches the filter.
     * @param {SearchQueryFindUniqueArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchQueryFindUniqueArgs>(args: SelectSubset<T, SearchQueryFindUniqueArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SearchQuery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SearchQueryFindUniqueOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SearchQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchQueryFindFirstArgs>(args?: SelectSubset<T, SearchQueryFindFirstArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SearchQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SearchQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany()
     * 
     * // Get first 10 SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchQueryFindManyArgs>(args?: SelectSubset<T, SearchQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SearchQuery.
     * @param {SearchQueryCreateArgs} args - Arguments to create a SearchQuery.
     * @example
     * // Create one SearchQuery
     * const SearchQuery = await prisma.searchQuery.create({
     *   data: {
     *     // ... data to create a SearchQuery
     *   }
     * })
     * 
     */
    create<T extends SearchQueryCreateArgs>(args: SelectSubset<T, SearchQueryCreateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SearchQueries.
     * @param {SearchQueryCreateManyArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchQueryCreateManyArgs>(args?: SelectSubset<T, SearchQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchQueries and returns the data saved in the database.
     * @param {SearchQueryCreateManyAndReturnArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchQueryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchQueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SearchQuery.
     * @param {SearchQueryDeleteArgs} args - Arguments to delete one SearchQuery.
     * @example
     * // Delete one SearchQuery
     * const SearchQuery = await prisma.searchQuery.delete({
     *   where: {
     *     // ... filter to delete one SearchQuery
     *   }
     * })
     * 
     */
    delete<T extends SearchQueryDeleteArgs>(args: SelectSubset<T, SearchQueryDeleteArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SearchQuery.
     * @param {SearchQueryUpdateArgs} args - Arguments to update one SearchQuery.
     * @example
     * // Update one SearchQuery
     * const searchQuery = await prisma.searchQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchQueryUpdateArgs>(args: SelectSubset<T, SearchQueryUpdateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SearchQueries.
     * @param {SearchQueryDeleteManyArgs} args - Arguments to filter SearchQueries to delete.
     * @example
     * // Delete a few SearchQueries
     * const { count } = await prisma.searchQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchQueryDeleteManyArgs>(args?: SelectSubset<T, SearchQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchQueryUpdateManyArgs>(args: SelectSubset<T, SearchQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchQuery.
     * @param {SearchQueryUpsertArgs} args - Arguments to update or create a SearchQuery.
     * @example
     * // Update or create a SearchQuery
     * const searchQuery = await prisma.searchQuery.upsert({
     *   create: {
     *     // ... data to create a SearchQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchQuery we want to update
     *   }
     * })
     */
    upsert<T extends SearchQueryUpsertArgs>(args: SelectSubset<T, SearchQueryUpsertArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryCountArgs} args - Arguments to filter SearchQueries to count.
     * @example
     * // Count the number of SearchQueries
     * const count = await prisma.searchQuery.count({
     *   where: {
     *     // ... the filter for the SearchQueries we want to count
     *   }
     * })
    **/
    count<T extends SearchQueryCountArgs>(
      args?: Subset<T, SearchQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchQueryAggregateArgs>(args: Subset<T, SearchQueryAggregateArgs>): Prisma.PrismaPromise<GetSearchQueryAggregateType<T>>

    /**
     * Group by SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchQueryGroupByArgs['orderBy'] }
        : { orderBy?: SearchQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchQuery model
   */
  readonly fields: SearchQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SearchQuery$userArgs<ExtArgs> = {}>(args?: Subset<T, SearchQuery$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchQuery model
   */ 
  interface SearchQueryFieldRefs {
    readonly id: FieldRef<"SearchQuery", 'String'>
    readonly query: FieldRef<"SearchQuery", 'String'>
    readonly userId: FieldRef<"SearchQuery", 'String'>
    readonly timestamp: FieldRef<"SearchQuery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchQuery findUnique
   */
  export type SearchQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findUniqueOrThrow
   */
  export type SearchQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findFirst
   */
  export type SearchQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findFirstOrThrow
   */
  export type SearchQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findMany
   */
  export type SearchQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQueries to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery create
   */
  export type SearchQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchQuery.
     */
    data: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
  }

  /**
   * SearchQuery createMany
   */
  export type SearchQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery createManyAndReturn
   */
  export type SearchQueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchQuery update
   */
  export type SearchQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchQuery.
     */
    data: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
    /**
     * Choose, which SearchQuery to update.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery updateMany
   */
  export type SearchQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
  }

  /**
   * SearchQuery upsert
   */
  export type SearchQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchQuery to update in case it exists.
     */
    where: SearchQueryWhereUniqueInput
    /**
     * In case the SearchQuery found by the `where` argument doesn't exist, create a new SearchQuery with this data.
     */
    create: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
    /**
     * In case the SearchQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
  }

  /**
   * SearchQuery delete
   */
  export type SearchQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter which SearchQuery to delete.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery deleteMany
   */
  export type SearchQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQueries to delete
     */
    where?: SearchQueryWhereInput
  }

  /**
   * SearchQuery.user
   */
  export type SearchQuery$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SearchQuery without action
   */
  export type SearchQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
  }


  /**
   * Model ProductView
   */

  export type AggregateProductView = {
    _count: ProductViewCountAggregateOutputType | null
    _avg: ProductViewAvgAggregateOutputType | null
    _sum: ProductViewSumAggregateOutputType | null
    _min: ProductViewMinAggregateOutputType | null
    _max: ProductViewMaxAggregateOutputType | null
  }

  export type ProductViewAvgAggregateOutputType = {
    duration: number | null
  }

  export type ProductViewSumAggregateOutputType = {
    duration: number | null
  }

  export type ProductViewMinAggregateOutputType = {
    id: string | null
    productId: string | null
    userId: string | null
    timestamp: Date | null
    duration: number | null
  }

  export type ProductViewMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    userId: string | null
    timestamp: Date | null
    duration: number | null
  }

  export type ProductViewCountAggregateOutputType = {
    id: number
    productId: number
    userId: number
    timestamp: number
    duration: number
    _all: number
  }


  export type ProductViewAvgAggregateInputType = {
    duration?: true
  }

  export type ProductViewSumAggregateInputType = {
    duration?: true
  }

  export type ProductViewMinAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    timestamp?: true
    duration?: true
  }

  export type ProductViewMaxAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    timestamp?: true
    duration?: true
  }

  export type ProductViewCountAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    timestamp?: true
    duration?: true
    _all?: true
  }

  export type ProductViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductView to aggregate.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductViews
    **/
    _count?: true | ProductViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductViewMaxAggregateInputType
  }

  export type GetProductViewAggregateType<T extends ProductViewAggregateArgs> = {
        [P in keyof T & keyof AggregateProductView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductView[P]>
      : GetScalarType<T[P], AggregateProductView[P]>
  }




  export type ProductViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductViewWhereInput
    orderBy?: ProductViewOrderByWithAggregationInput | ProductViewOrderByWithAggregationInput[]
    by: ProductViewScalarFieldEnum[] | ProductViewScalarFieldEnum
    having?: ProductViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductViewCountAggregateInputType | true
    _avg?: ProductViewAvgAggregateInputType
    _sum?: ProductViewSumAggregateInputType
    _min?: ProductViewMinAggregateInputType
    _max?: ProductViewMaxAggregateInputType
  }

  export type ProductViewGroupByOutputType = {
    id: string
    productId: string
    userId: string | null
    timestamp: Date
    duration: number | null
    _count: ProductViewCountAggregateOutputType | null
    _avg: ProductViewAvgAggregateOutputType | null
    _sum: ProductViewSumAggregateOutputType | null
    _min: ProductViewMinAggregateOutputType | null
    _max: ProductViewMaxAggregateOutputType | null
  }

  type GetProductViewGroupByPayload<T extends ProductViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductViewGroupByOutputType[P]>
            : GetScalarType<T[P], ProductViewGroupByOutputType[P]>
        }
      >
    >


  export type ProductViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    userId?: boolean
    timestamp?: boolean
    duration?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | ProductView$userArgs<ExtArgs>
  }, ExtArgs["result"]["productView"]>

  export type ProductViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    userId?: boolean
    timestamp?: boolean
    duration?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | ProductView$userArgs<ExtArgs>
  }, ExtArgs["result"]["productView"]>

  export type ProductViewSelectScalar = {
    id?: boolean
    productId?: boolean
    userId?: boolean
    timestamp?: boolean
    duration?: boolean
  }

  export type ProductViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | ProductView$userArgs<ExtArgs>
  }
  export type ProductViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | ProductView$userArgs<ExtArgs>
  }

  export type $ProductViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductView"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      userId: string | null
      timestamp: Date
      duration: number | null
    }, ExtArgs["result"]["productView"]>
    composites: {}
  }

  type ProductViewGetPayload<S extends boolean | null | undefined | ProductViewDefaultArgs> = $Result.GetResult<Prisma.$ProductViewPayload, S>

  type ProductViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductViewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductViewCountAggregateInputType | true
    }

  export interface ProductViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductView'], meta: { name: 'ProductView' } }
    /**
     * Find zero or one ProductView that matches the filter.
     * @param {ProductViewFindUniqueArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductViewFindUniqueArgs>(args: SelectSubset<T, ProductViewFindUniqueArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductViewFindUniqueOrThrowArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewFindFirstArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductViewFindFirstArgs>(args?: SelectSubset<T, ProductViewFindFirstArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewFindFirstOrThrowArgs} args - Arguments to find a ProductView
     * @example
     * // Get one ProductView
     * const productView = await prisma.productView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductViews
     * const productViews = await prisma.productView.findMany()
     * 
     * // Get first 10 ProductViews
     * const productViews = await prisma.productView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productViewWithIdOnly = await prisma.productView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductViewFindManyArgs>(args?: SelectSubset<T, ProductViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductView.
     * @param {ProductViewCreateArgs} args - Arguments to create a ProductView.
     * @example
     * // Create one ProductView
     * const ProductView = await prisma.productView.create({
     *   data: {
     *     // ... data to create a ProductView
     *   }
     * })
     * 
     */
    create<T extends ProductViewCreateArgs>(args: SelectSubset<T, ProductViewCreateArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductViews.
     * @param {ProductViewCreateManyArgs} args - Arguments to create many ProductViews.
     * @example
     * // Create many ProductViews
     * const productView = await prisma.productView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductViewCreateManyArgs>(args?: SelectSubset<T, ProductViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductViews and returns the data saved in the database.
     * @param {ProductViewCreateManyAndReturnArgs} args - Arguments to create many ProductViews.
     * @example
     * // Create many ProductViews
     * const productView = await prisma.productView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductViews and only return the `id`
     * const productViewWithIdOnly = await prisma.productView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductView.
     * @param {ProductViewDeleteArgs} args - Arguments to delete one ProductView.
     * @example
     * // Delete one ProductView
     * const ProductView = await prisma.productView.delete({
     *   where: {
     *     // ... filter to delete one ProductView
     *   }
     * })
     * 
     */
    delete<T extends ProductViewDeleteArgs>(args: SelectSubset<T, ProductViewDeleteArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductView.
     * @param {ProductViewUpdateArgs} args - Arguments to update one ProductView.
     * @example
     * // Update one ProductView
     * const productView = await prisma.productView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductViewUpdateArgs>(args: SelectSubset<T, ProductViewUpdateArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductViews.
     * @param {ProductViewDeleteManyArgs} args - Arguments to filter ProductViews to delete.
     * @example
     * // Delete a few ProductViews
     * const { count } = await prisma.productView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductViewDeleteManyArgs>(args?: SelectSubset<T, ProductViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductViews
     * const productView = await prisma.productView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductViewUpdateManyArgs>(args: SelectSubset<T, ProductViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductView.
     * @param {ProductViewUpsertArgs} args - Arguments to update or create a ProductView.
     * @example
     * // Update or create a ProductView
     * const productView = await prisma.productView.upsert({
     *   create: {
     *     // ... data to create a ProductView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductView we want to update
     *   }
     * })
     */
    upsert<T extends ProductViewUpsertArgs>(args: SelectSubset<T, ProductViewUpsertArgs<ExtArgs>>): Prisma__ProductViewClient<$Result.GetResult<Prisma.$ProductViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewCountArgs} args - Arguments to filter ProductViews to count.
     * @example
     * // Count the number of ProductViews
     * const count = await prisma.productView.count({
     *   where: {
     *     // ... the filter for the ProductViews we want to count
     *   }
     * })
    **/
    count<T extends ProductViewCountArgs>(
      args?: Subset<T, ProductViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductViewAggregateArgs>(args: Subset<T, ProductViewAggregateArgs>): Prisma.PrismaPromise<GetProductViewAggregateType<T>>

    /**
     * Group by ProductView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductViewGroupByArgs['orderBy'] }
        : { orderBy?: ProductViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductView model
   */
  readonly fields: ProductViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends ProductView$userArgs<ExtArgs> = {}>(args?: Subset<T, ProductView$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductView model
   */ 
  interface ProductViewFieldRefs {
    readonly id: FieldRef<"ProductView", 'String'>
    readonly productId: FieldRef<"ProductView", 'String'>
    readonly userId: FieldRef<"ProductView", 'String'>
    readonly timestamp: FieldRef<"ProductView", 'DateTime'>
    readonly duration: FieldRef<"ProductView", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductView findUnique
   */
  export type ProductViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView findUniqueOrThrow
   */
  export type ProductViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView findFirst
   */
  export type ProductViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductViews.
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductViews.
     */
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * ProductView findFirstOrThrow
   */
  export type ProductViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductView to fetch.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductViews.
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductViews.
     */
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * ProductView findMany
   */
  export type ProductViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter, which ProductViews to fetch.
     */
    where?: ProductViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductViews to fetch.
     */
    orderBy?: ProductViewOrderByWithRelationInput | ProductViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductViews.
     */
    cursor?: ProductViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductViews.
     */
    skip?: number
    distinct?: ProductViewScalarFieldEnum | ProductViewScalarFieldEnum[]
  }

  /**
   * ProductView create
   */
  export type ProductViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductView.
     */
    data: XOR<ProductViewCreateInput, ProductViewUncheckedCreateInput>
  }

  /**
   * ProductView createMany
   */
  export type ProductViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductViews.
     */
    data: ProductViewCreateManyInput | ProductViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductView createManyAndReturn
   */
  export type ProductViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductViews.
     */
    data: ProductViewCreateManyInput | ProductViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductView update
   */
  export type ProductViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductView.
     */
    data: XOR<ProductViewUpdateInput, ProductViewUncheckedUpdateInput>
    /**
     * Choose, which ProductView to update.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView updateMany
   */
  export type ProductViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductViews.
     */
    data: XOR<ProductViewUpdateManyMutationInput, ProductViewUncheckedUpdateManyInput>
    /**
     * Filter which ProductViews to update
     */
    where?: ProductViewWhereInput
  }

  /**
   * ProductView upsert
   */
  export type ProductViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductView to update in case it exists.
     */
    where: ProductViewWhereUniqueInput
    /**
     * In case the ProductView found by the `where` argument doesn't exist, create a new ProductView with this data.
     */
    create: XOR<ProductViewCreateInput, ProductViewUncheckedCreateInput>
    /**
     * In case the ProductView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductViewUpdateInput, ProductViewUncheckedUpdateInput>
  }

  /**
   * ProductView delete
   */
  export type ProductViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
    /**
     * Filter which ProductView to delete.
     */
    where: ProductViewWhereUniqueInput
  }

  /**
   * ProductView deleteMany
   */
  export type ProductViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductViews to delete
     */
    where?: ProductViewWhereInput
  }

  /**
   * ProductView.user
   */
  export type ProductView$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductView without action
   */
  export type ProductViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductView
     */
    select?: ProductViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductViewInclude<ExtArgs> | null
  }


  /**
   * Model ServiceView
   */

  export type AggregateServiceView = {
    _count: ServiceViewCountAggregateOutputType | null
    _avg: ServiceViewAvgAggregateOutputType | null
    _sum: ServiceViewSumAggregateOutputType | null
    _min: ServiceViewMinAggregateOutputType | null
    _max: ServiceViewMaxAggregateOutputType | null
  }

  export type ServiceViewAvgAggregateOutputType = {
    duration: number | null
  }

  export type ServiceViewSumAggregateOutputType = {
    duration: number | null
  }

  export type ServiceViewMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    userId: string | null
    timestamp: Date | null
    duration: number | null
  }

  export type ServiceViewMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    userId: string | null
    timestamp: Date | null
    duration: number | null
  }

  export type ServiceViewCountAggregateOutputType = {
    id: number
    serviceId: number
    userId: number
    timestamp: number
    duration: number
    _all: number
  }


  export type ServiceViewAvgAggregateInputType = {
    duration?: true
  }

  export type ServiceViewSumAggregateInputType = {
    duration?: true
  }

  export type ServiceViewMinAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
    timestamp?: true
    duration?: true
  }

  export type ServiceViewMaxAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
    timestamp?: true
    duration?: true
  }

  export type ServiceViewCountAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
    timestamp?: true
    duration?: true
    _all?: true
  }

  export type ServiceViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceView to aggregate.
     */
    where?: ServiceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceViews to fetch.
     */
    orderBy?: ServiceViewOrderByWithRelationInput | ServiceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceViews
    **/
    _count?: true | ServiceViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceViewMaxAggregateInputType
  }

  export type GetServiceViewAggregateType<T extends ServiceViewAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceView[P]>
      : GetScalarType<T[P], AggregateServiceView[P]>
  }




  export type ServiceViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceViewWhereInput
    orderBy?: ServiceViewOrderByWithAggregationInput | ServiceViewOrderByWithAggregationInput[]
    by: ServiceViewScalarFieldEnum[] | ServiceViewScalarFieldEnum
    having?: ServiceViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceViewCountAggregateInputType | true
    _avg?: ServiceViewAvgAggregateInputType
    _sum?: ServiceViewSumAggregateInputType
    _min?: ServiceViewMinAggregateInputType
    _max?: ServiceViewMaxAggregateInputType
  }

  export type ServiceViewGroupByOutputType = {
    id: string
    serviceId: string
    userId: string | null
    timestamp: Date
    duration: number | null
    _count: ServiceViewCountAggregateOutputType | null
    _avg: ServiceViewAvgAggregateOutputType | null
    _sum: ServiceViewSumAggregateOutputType | null
    _min: ServiceViewMinAggregateOutputType | null
    _max: ServiceViewMaxAggregateOutputType | null
  }

  type GetServiceViewGroupByPayload<T extends ServiceViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceViewGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceViewGroupByOutputType[P]>
        }
      >
    >


  export type ServiceViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userId?: boolean
    timestamp?: boolean
    duration?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | ServiceView$userArgs<ExtArgs>
  }, ExtArgs["result"]["serviceView"]>

  export type ServiceViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userId?: boolean
    timestamp?: boolean
    duration?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | ServiceView$userArgs<ExtArgs>
  }, ExtArgs["result"]["serviceView"]>

  export type ServiceViewSelectScalar = {
    id?: boolean
    serviceId?: boolean
    userId?: boolean
    timestamp?: boolean
    duration?: boolean
  }

  export type ServiceViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | ServiceView$userArgs<ExtArgs>
  }
  export type ServiceViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | ServiceView$userArgs<ExtArgs>
  }

  export type $ServiceViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceView"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      userId: string | null
      timestamp: Date
      duration: number | null
    }, ExtArgs["result"]["serviceView"]>
    composites: {}
  }

  type ServiceViewGetPayload<S extends boolean | null | undefined | ServiceViewDefaultArgs> = $Result.GetResult<Prisma.$ServiceViewPayload, S>

  type ServiceViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceViewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceViewCountAggregateInputType | true
    }

  export interface ServiceViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceView'], meta: { name: 'ServiceView' } }
    /**
     * Find zero or one ServiceView that matches the filter.
     * @param {ServiceViewFindUniqueArgs} args - Arguments to find a ServiceView
     * @example
     * // Get one ServiceView
     * const serviceView = await prisma.serviceView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceViewFindUniqueArgs>(args: SelectSubset<T, ServiceViewFindUniqueArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceViewFindUniqueOrThrowArgs} args - Arguments to find a ServiceView
     * @example
     * // Get one ServiceView
     * const serviceView = await prisma.serviceView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceViewFindFirstArgs} args - Arguments to find a ServiceView
     * @example
     * // Get one ServiceView
     * const serviceView = await prisma.serviceView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceViewFindFirstArgs>(args?: SelectSubset<T, ServiceViewFindFirstArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceViewFindFirstOrThrowArgs} args - Arguments to find a ServiceView
     * @example
     * // Get one ServiceView
     * const serviceView = await prisma.serviceView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceViews
     * const serviceViews = await prisma.serviceView.findMany()
     * 
     * // Get first 10 ServiceViews
     * const serviceViews = await prisma.serviceView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceViewWithIdOnly = await prisma.serviceView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceViewFindManyArgs>(args?: SelectSubset<T, ServiceViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceView.
     * @param {ServiceViewCreateArgs} args - Arguments to create a ServiceView.
     * @example
     * // Create one ServiceView
     * const ServiceView = await prisma.serviceView.create({
     *   data: {
     *     // ... data to create a ServiceView
     *   }
     * })
     * 
     */
    create<T extends ServiceViewCreateArgs>(args: SelectSubset<T, ServiceViewCreateArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceViews.
     * @param {ServiceViewCreateManyArgs} args - Arguments to create many ServiceViews.
     * @example
     * // Create many ServiceViews
     * const serviceView = await prisma.serviceView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceViewCreateManyArgs>(args?: SelectSubset<T, ServiceViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceViews and returns the data saved in the database.
     * @param {ServiceViewCreateManyAndReturnArgs} args - Arguments to create many ServiceViews.
     * @example
     * // Create many ServiceViews
     * const serviceView = await prisma.serviceView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceViews and only return the `id`
     * const serviceViewWithIdOnly = await prisma.serviceView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceView.
     * @param {ServiceViewDeleteArgs} args - Arguments to delete one ServiceView.
     * @example
     * // Delete one ServiceView
     * const ServiceView = await prisma.serviceView.delete({
     *   where: {
     *     // ... filter to delete one ServiceView
     *   }
     * })
     * 
     */
    delete<T extends ServiceViewDeleteArgs>(args: SelectSubset<T, ServiceViewDeleteArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceView.
     * @param {ServiceViewUpdateArgs} args - Arguments to update one ServiceView.
     * @example
     * // Update one ServiceView
     * const serviceView = await prisma.serviceView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceViewUpdateArgs>(args: SelectSubset<T, ServiceViewUpdateArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceViews.
     * @param {ServiceViewDeleteManyArgs} args - Arguments to filter ServiceViews to delete.
     * @example
     * // Delete a few ServiceViews
     * const { count } = await prisma.serviceView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceViewDeleteManyArgs>(args?: SelectSubset<T, ServiceViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceViews
     * const serviceView = await prisma.serviceView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceViewUpdateManyArgs>(args: SelectSubset<T, ServiceViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceView.
     * @param {ServiceViewUpsertArgs} args - Arguments to update or create a ServiceView.
     * @example
     * // Update or create a ServiceView
     * const serviceView = await prisma.serviceView.upsert({
     *   create: {
     *     // ... data to create a ServiceView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceView we want to update
     *   }
     * })
     */
    upsert<T extends ServiceViewUpsertArgs>(args: SelectSubset<T, ServiceViewUpsertArgs<ExtArgs>>): Prisma__ServiceViewClient<$Result.GetResult<Prisma.$ServiceViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceViewCountArgs} args - Arguments to filter ServiceViews to count.
     * @example
     * // Count the number of ServiceViews
     * const count = await prisma.serviceView.count({
     *   where: {
     *     // ... the filter for the ServiceViews we want to count
     *   }
     * })
    **/
    count<T extends ServiceViewCountArgs>(
      args?: Subset<T, ServiceViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceViewAggregateArgs>(args: Subset<T, ServiceViewAggregateArgs>): Prisma.PrismaPromise<GetServiceViewAggregateType<T>>

    /**
     * Group by ServiceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceViewGroupByArgs['orderBy'] }
        : { orderBy?: ServiceViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceView model
   */
  readonly fields: ServiceViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends ServiceView$userArgs<ExtArgs> = {}>(args?: Subset<T, ServiceView$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceView model
   */ 
  interface ServiceViewFieldRefs {
    readonly id: FieldRef<"ServiceView", 'String'>
    readonly serviceId: FieldRef<"ServiceView", 'String'>
    readonly userId: FieldRef<"ServiceView", 'String'>
    readonly timestamp: FieldRef<"ServiceView", 'DateTime'>
    readonly duration: FieldRef<"ServiceView", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceView findUnique
   */
  export type ServiceViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * Filter, which ServiceView to fetch.
     */
    where: ServiceViewWhereUniqueInput
  }

  /**
   * ServiceView findUniqueOrThrow
   */
  export type ServiceViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * Filter, which ServiceView to fetch.
     */
    where: ServiceViewWhereUniqueInput
  }

  /**
   * ServiceView findFirst
   */
  export type ServiceViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * Filter, which ServiceView to fetch.
     */
    where?: ServiceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceViews to fetch.
     */
    orderBy?: ServiceViewOrderByWithRelationInput | ServiceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceViews.
     */
    cursor?: ServiceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceViews.
     */
    distinct?: ServiceViewScalarFieldEnum | ServiceViewScalarFieldEnum[]
  }

  /**
   * ServiceView findFirstOrThrow
   */
  export type ServiceViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * Filter, which ServiceView to fetch.
     */
    where?: ServiceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceViews to fetch.
     */
    orderBy?: ServiceViewOrderByWithRelationInput | ServiceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceViews.
     */
    cursor?: ServiceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceViews.
     */
    distinct?: ServiceViewScalarFieldEnum | ServiceViewScalarFieldEnum[]
  }

  /**
   * ServiceView findMany
   */
  export type ServiceViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * Filter, which ServiceViews to fetch.
     */
    where?: ServiceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceViews to fetch.
     */
    orderBy?: ServiceViewOrderByWithRelationInput | ServiceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceViews.
     */
    cursor?: ServiceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceViews.
     */
    skip?: number
    distinct?: ServiceViewScalarFieldEnum | ServiceViewScalarFieldEnum[]
  }

  /**
   * ServiceView create
   */
  export type ServiceViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceView.
     */
    data: XOR<ServiceViewCreateInput, ServiceViewUncheckedCreateInput>
  }

  /**
   * ServiceView createMany
   */
  export type ServiceViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceViews.
     */
    data: ServiceViewCreateManyInput | ServiceViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceView createManyAndReturn
   */
  export type ServiceViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceViews.
     */
    data: ServiceViewCreateManyInput | ServiceViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceView update
   */
  export type ServiceViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceView.
     */
    data: XOR<ServiceViewUpdateInput, ServiceViewUncheckedUpdateInput>
    /**
     * Choose, which ServiceView to update.
     */
    where: ServiceViewWhereUniqueInput
  }

  /**
   * ServiceView updateMany
   */
  export type ServiceViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceViews.
     */
    data: XOR<ServiceViewUpdateManyMutationInput, ServiceViewUncheckedUpdateManyInput>
    /**
     * Filter which ServiceViews to update
     */
    where?: ServiceViewWhereInput
  }

  /**
   * ServiceView upsert
   */
  export type ServiceViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceView to update in case it exists.
     */
    where: ServiceViewWhereUniqueInput
    /**
     * In case the ServiceView found by the `where` argument doesn't exist, create a new ServiceView with this data.
     */
    create: XOR<ServiceViewCreateInput, ServiceViewUncheckedCreateInput>
    /**
     * In case the ServiceView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceViewUpdateInput, ServiceViewUncheckedUpdateInput>
  }

  /**
   * ServiceView delete
   */
  export type ServiceViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
    /**
     * Filter which ServiceView to delete.
     */
    where: ServiceViewWhereUniqueInput
  }

  /**
   * ServiceView deleteMany
   */
  export type ServiceViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceViews to delete
     */
    where?: ServiceViewWhereInput
  }

  /**
   * ServiceView.user
   */
  export type ServiceView$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ServiceView without action
   */
  export type ServiceViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceView
     */
    select?: ServiceViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceViewInclude<ExtArgs> | null
  }


  /**
   * Model CustomerQuestion
   */

  export type AggregateCustomerQuestion = {
    _count: CustomerQuestionCountAggregateOutputType | null
    _avg: CustomerQuestionAvgAggregateOutputType | null
    _sum: CustomerQuestionSumAggregateOutputType | null
    _min: CustomerQuestionMinAggregateOutputType | null
    _max: CustomerQuestionMaxAggregateOutputType | null
  }

  export type CustomerQuestionAvgAggregateOutputType = {
    satisfaction: number | null
  }

  export type CustomerQuestionSumAggregateOutputType = {
    satisfaction: number | null
  }

  export type CustomerQuestionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    category: string | null
    satisfaction: number | null
    timestamp: Date | null
  }

  export type CustomerQuestionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    question: string | null
    category: string | null
    satisfaction: number | null
    timestamp: Date | null
  }

  export type CustomerQuestionCountAggregateOutputType = {
    id: number
    userId: number
    question: number
    category: number
    satisfaction: number
    timestamp: number
    _all: number
  }


  export type CustomerQuestionAvgAggregateInputType = {
    satisfaction?: true
  }

  export type CustomerQuestionSumAggregateInputType = {
    satisfaction?: true
  }

  export type CustomerQuestionMinAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    category?: true
    satisfaction?: true
    timestamp?: true
  }

  export type CustomerQuestionMaxAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    category?: true
    satisfaction?: true
    timestamp?: true
  }

  export type CustomerQuestionCountAggregateInputType = {
    id?: true
    userId?: true
    question?: true
    category?: true
    satisfaction?: true
    timestamp?: true
    _all?: true
  }

  export type CustomerQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerQuestion to aggregate.
     */
    where?: CustomerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQuestions to fetch.
     */
    orderBy?: CustomerQuestionOrderByWithRelationInput | CustomerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerQuestions
    **/
    _count?: true | CustomerQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerQuestionMaxAggregateInputType
  }

  export type GetCustomerQuestionAggregateType<T extends CustomerQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerQuestion[P]>
      : GetScalarType<T[P], AggregateCustomerQuestion[P]>
  }




  export type CustomerQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerQuestionWhereInput
    orderBy?: CustomerQuestionOrderByWithAggregationInput | CustomerQuestionOrderByWithAggregationInput[]
    by: CustomerQuestionScalarFieldEnum[] | CustomerQuestionScalarFieldEnum
    having?: CustomerQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerQuestionCountAggregateInputType | true
    _avg?: CustomerQuestionAvgAggregateInputType
    _sum?: CustomerQuestionSumAggregateInputType
    _min?: CustomerQuestionMinAggregateInputType
    _max?: CustomerQuestionMaxAggregateInputType
  }

  export type CustomerQuestionGroupByOutputType = {
    id: string
    userId: string | null
    question: string
    category: string | null
    satisfaction: number | null
    timestamp: Date
    _count: CustomerQuestionCountAggregateOutputType | null
    _avg: CustomerQuestionAvgAggregateOutputType | null
    _sum: CustomerQuestionSumAggregateOutputType | null
    _min: CustomerQuestionMinAggregateOutputType | null
    _max: CustomerQuestionMaxAggregateOutputType | null
  }

  type GetCustomerQuestionGroupByPayload<T extends CustomerQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerQuestionGroupByOutputType[P]>
        }
      >
    >


  export type CustomerQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    category?: boolean
    satisfaction?: boolean
    timestamp?: boolean
    user?: boolean | CustomerQuestion$userArgs<ExtArgs>
  }, ExtArgs["result"]["customerQuestion"]>

  export type CustomerQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    question?: boolean
    category?: boolean
    satisfaction?: boolean
    timestamp?: boolean
    user?: boolean | CustomerQuestion$userArgs<ExtArgs>
  }, ExtArgs["result"]["customerQuestion"]>

  export type CustomerQuestionSelectScalar = {
    id?: boolean
    userId?: boolean
    question?: boolean
    category?: boolean
    satisfaction?: boolean
    timestamp?: boolean
  }

  export type CustomerQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CustomerQuestion$userArgs<ExtArgs>
  }
  export type CustomerQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CustomerQuestion$userArgs<ExtArgs>
  }

  export type $CustomerQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerQuestion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      question: string
      category: string | null
      satisfaction: number | null
      timestamp: Date
    }, ExtArgs["result"]["customerQuestion"]>
    composites: {}
  }

  type CustomerQuestionGetPayload<S extends boolean | null | undefined | CustomerQuestionDefaultArgs> = $Result.GetResult<Prisma.$CustomerQuestionPayload, S>

  type CustomerQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerQuestionCountAggregateInputType | true
    }

  export interface CustomerQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerQuestion'], meta: { name: 'CustomerQuestion' } }
    /**
     * Find zero or one CustomerQuestion that matches the filter.
     * @param {CustomerQuestionFindUniqueArgs} args - Arguments to find a CustomerQuestion
     * @example
     * // Get one CustomerQuestion
     * const customerQuestion = await prisma.customerQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerQuestionFindUniqueArgs>(args: SelectSubset<T, CustomerQuestionFindUniqueArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerQuestionFindUniqueOrThrowArgs} args - Arguments to find a CustomerQuestion
     * @example
     * // Get one CustomerQuestion
     * const customerQuestion = await prisma.customerQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQuestionFindFirstArgs} args - Arguments to find a CustomerQuestion
     * @example
     * // Get one CustomerQuestion
     * const customerQuestion = await prisma.customerQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerQuestionFindFirstArgs>(args?: SelectSubset<T, CustomerQuestionFindFirstArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQuestionFindFirstOrThrowArgs} args - Arguments to find a CustomerQuestion
     * @example
     * // Get one CustomerQuestion
     * const customerQuestion = await prisma.customerQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerQuestions
     * const customerQuestions = await prisma.customerQuestion.findMany()
     * 
     * // Get first 10 CustomerQuestions
     * const customerQuestions = await prisma.customerQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerQuestionWithIdOnly = await prisma.customerQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerQuestionFindManyArgs>(args?: SelectSubset<T, CustomerQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerQuestion.
     * @param {CustomerQuestionCreateArgs} args - Arguments to create a CustomerQuestion.
     * @example
     * // Create one CustomerQuestion
     * const CustomerQuestion = await prisma.customerQuestion.create({
     *   data: {
     *     // ... data to create a CustomerQuestion
     *   }
     * })
     * 
     */
    create<T extends CustomerQuestionCreateArgs>(args: SelectSubset<T, CustomerQuestionCreateArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerQuestions.
     * @param {CustomerQuestionCreateManyArgs} args - Arguments to create many CustomerQuestions.
     * @example
     * // Create many CustomerQuestions
     * const customerQuestion = await prisma.customerQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerQuestionCreateManyArgs>(args?: SelectSubset<T, CustomerQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerQuestions and returns the data saved in the database.
     * @param {CustomerQuestionCreateManyAndReturnArgs} args - Arguments to create many CustomerQuestions.
     * @example
     * // Create many CustomerQuestions
     * const customerQuestion = await prisma.customerQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerQuestions and only return the `id`
     * const customerQuestionWithIdOnly = await prisma.customerQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerQuestion.
     * @param {CustomerQuestionDeleteArgs} args - Arguments to delete one CustomerQuestion.
     * @example
     * // Delete one CustomerQuestion
     * const CustomerQuestion = await prisma.customerQuestion.delete({
     *   where: {
     *     // ... filter to delete one CustomerQuestion
     *   }
     * })
     * 
     */
    delete<T extends CustomerQuestionDeleteArgs>(args: SelectSubset<T, CustomerQuestionDeleteArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerQuestion.
     * @param {CustomerQuestionUpdateArgs} args - Arguments to update one CustomerQuestion.
     * @example
     * // Update one CustomerQuestion
     * const customerQuestion = await prisma.customerQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerQuestionUpdateArgs>(args: SelectSubset<T, CustomerQuestionUpdateArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerQuestions.
     * @param {CustomerQuestionDeleteManyArgs} args - Arguments to filter CustomerQuestions to delete.
     * @example
     * // Delete a few CustomerQuestions
     * const { count } = await prisma.customerQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerQuestionDeleteManyArgs>(args?: SelectSubset<T, CustomerQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerQuestions
     * const customerQuestion = await prisma.customerQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerQuestionUpdateManyArgs>(args: SelectSubset<T, CustomerQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerQuestion.
     * @param {CustomerQuestionUpsertArgs} args - Arguments to update or create a CustomerQuestion.
     * @example
     * // Update or create a CustomerQuestion
     * const customerQuestion = await prisma.customerQuestion.upsert({
     *   create: {
     *     // ... data to create a CustomerQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerQuestion we want to update
     *   }
     * })
     */
    upsert<T extends CustomerQuestionUpsertArgs>(args: SelectSubset<T, CustomerQuestionUpsertArgs<ExtArgs>>): Prisma__CustomerQuestionClient<$Result.GetResult<Prisma.$CustomerQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQuestionCountArgs} args - Arguments to filter CustomerQuestions to count.
     * @example
     * // Count the number of CustomerQuestions
     * const count = await prisma.customerQuestion.count({
     *   where: {
     *     // ... the filter for the CustomerQuestions we want to count
     *   }
     * })
    **/
    count<T extends CustomerQuestionCountArgs>(
      args?: Subset<T, CustomerQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerQuestionAggregateArgs>(args: Subset<T, CustomerQuestionAggregateArgs>): Prisma.PrismaPromise<GetCustomerQuestionAggregateType<T>>

    /**
     * Group by CustomerQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerQuestionGroupByArgs['orderBy'] }
        : { orderBy?: CustomerQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerQuestion model
   */
  readonly fields: CustomerQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends CustomerQuestion$userArgs<ExtArgs> = {}>(args?: Subset<T, CustomerQuestion$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerQuestion model
   */ 
  interface CustomerQuestionFieldRefs {
    readonly id: FieldRef<"CustomerQuestion", 'String'>
    readonly userId: FieldRef<"CustomerQuestion", 'String'>
    readonly question: FieldRef<"CustomerQuestion", 'String'>
    readonly category: FieldRef<"CustomerQuestion", 'String'>
    readonly satisfaction: FieldRef<"CustomerQuestion", 'Int'>
    readonly timestamp: FieldRef<"CustomerQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerQuestion findUnique
   */
  export type CustomerQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerQuestion to fetch.
     */
    where: CustomerQuestionWhereUniqueInput
  }

  /**
   * CustomerQuestion findUniqueOrThrow
   */
  export type CustomerQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerQuestion to fetch.
     */
    where: CustomerQuestionWhereUniqueInput
  }

  /**
   * CustomerQuestion findFirst
   */
  export type CustomerQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerQuestion to fetch.
     */
    where?: CustomerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQuestions to fetch.
     */
    orderBy?: CustomerQuestionOrderByWithRelationInput | CustomerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerQuestions.
     */
    cursor?: CustomerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerQuestions.
     */
    distinct?: CustomerQuestionScalarFieldEnum | CustomerQuestionScalarFieldEnum[]
  }

  /**
   * CustomerQuestion findFirstOrThrow
   */
  export type CustomerQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerQuestion to fetch.
     */
    where?: CustomerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQuestions to fetch.
     */
    orderBy?: CustomerQuestionOrderByWithRelationInput | CustomerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerQuestions.
     */
    cursor?: CustomerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerQuestions.
     */
    distinct?: CustomerQuestionScalarFieldEnum | CustomerQuestionScalarFieldEnum[]
  }

  /**
   * CustomerQuestion findMany
   */
  export type CustomerQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerQuestions to fetch.
     */
    where?: CustomerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerQuestions to fetch.
     */
    orderBy?: CustomerQuestionOrderByWithRelationInput | CustomerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerQuestions.
     */
    cursor?: CustomerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerQuestions.
     */
    skip?: number
    distinct?: CustomerQuestionScalarFieldEnum | CustomerQuestionScalarFieldEnum[]
  }

  /**
   * CustomerQuestion create
   */
  export type CustomerQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerQuestion.
     */
    data: XOR<CustomerQuestionCreateInput, CustomerQuestionUncheckedCreateInput>
  }

  /**
   * CustomerQuestion createMany
   */
  export type CustomerQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerQuestions.
     */
    data: CustomerQuestionCreateManyInput | CustomerQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerQuestion createManyAndReturn
   */
  export type CustomerQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerQuestions.
     */
    data: CustomerQuestionCreateManyInput | CustomerQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerQuestion update
   */
  export type CustomerQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerQuestion.
     */
    data: XOR<CustomerQuestionUpdateInput, CustomerQuestionUncheckedUpdateInput>
    /**
     * Choose, which CustomerQuestion to update.
     */
    where: CustomerQuestionWhereUniqueInput
  }

  /**
   * CustomerQuestion updateMany
   */
  export type CustomerQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerQuestions.
     */
    data: XOR<CustomerQuestionUpdateManyMutationInput, CustomerQuestionUncheckedUpdateManyInput>
    /**
     * Filter which CustomerQuestions to update
     */
    where?: CustomerQuestionWhereInput
  }

  /**
   * CustomerQuestion upsert
   */
  export type CustomerQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerQuestion to update in case it exists.
     */
    where: CustomerQuestionWhereUniqueInput
    /**
     * In case the CustomerQuestion found by the `where` argument doesn't exist, create a new CustomerQuestion with this data.
     */
    create: XOR<CustomerQuestionCreateInput, CustomerQuestionUncheckedCreateInput>
    /**
     * In case the CustomerQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerQuestionUpdateInput, CustomerQuestionUncheckedUpdateInput>
  }

  /**
   * CustomerQuestion delete
   */
  export type CustomerQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
    /**
     * Filter which CustomerQuestion to delete.
     */
    where: CustomerQuestionWhereUniqueInput
  }

  /**
   * CustomerQuestion deleteMany
   */
  export type CustomerQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerQuestions to delete
     */
    where?: CustomerQuestionWhereInput
  }

  /**
   * CustomerQuestion.user
   */
  export type CustomerQuestion$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CustomerQuestion without action
   */
  export type CustomerQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerQuestion
     */
    select?: CustomerQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerQuestionInclude<ExtArgs> | null
  }


  /**
   * Model Technician
   */

  export type AggregateTechnician = {
    _count: TechnicianCountAggregateOutputType | null
    _min: TechnicianMinAggregateOutputType | null
    _max: TechnicianMaxAggregateOutputType | null
  }

  export type TechnicianMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    specialties: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type TechnicianMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    specialties: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type TechnicianCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    specialties: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type TechnicianMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    specialties?: true
    isActive?: true
    createdAt?: true
  }

  export type TechnicianMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    specialties?: true
    isActive?: true
    createdAt?: true
  }

  export type TechnicianCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    specialties?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type TechnicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Technician to aggregate.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Technicians
    **/
    _count?: true | TechnicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicianMaxAggregateInputType
  }

  export type GetTechnicianAggregateType<T extends TechnicianAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnician[P]>
      : GetScalarType<T[P], AggregateTechnician[P]>
  }




  export type TechnicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianWhereInput
    orderBy?: TechnicianOrderByWithAggregationInput | TechnicianOrderByWithAggregationInput[]
    by: TechnicianScalarFieldEnum[] | TechnicianScalarFieldEnum
    having?: TechnicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicianCountAggregateInputType | true
    _min?: TechnicianMinAggregateInputType
    _max?: TechnicianMaxAggregateInputType
  }

  export type TechnicianGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    specialties: string | null
    isActive: boolean
    createdAt: Date
    _count: TechnicianCountAggregateOutputType | null
    _min: TechnicianMinAggregateOutputType | null
    _max: TechnicianMaxAggregateOutputType | null
  }

  type GetTechnicianGroupByPayload<T extends TechnicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicianGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicianGroupByOutputType[P]>
        }
      >
    >


  export type TechnicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    specialties?: boolean
    isActive?: boolean
    createdAt?: boolean
    bookings?: boolean | Technician$bookingsArgs<ExtArgs>
    schedules?: boolean | Technician$schedulesArgs<ExtArgs>
    _count?: boolean | TechnicianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technician"]>

  export type TechnicianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    specialties?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["technician"]>

  export type TechnicianSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    specialties?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type TechnicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Technician$bookingsArgs<ExtArgs>
    schedules?: boolean | Technician$schedulesArgs<ExtArgs>
    _count?: boolean | TechnicianCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TechnicianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TechnicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Technician"
    objects: {
      bookings: Prisma.$ServiceBookingPayload<ExtArgs>[]
      schedules: Prisma.$TechnicianSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      specialties: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["technician"]>
    composites: {}
  }

  type TechnicianGetPayload<S extends boolean | null | undefined | TechnicianDefaultArgs> = $Result.GetResult<Prisma.$TechnicianPayload, S>

  type TechnicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TechnicianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TechnicianCountAggregateInputType | true
    }

  export interface TechnicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Technician'], meta: { name: 'Technician' } }
    /**
     * Find zero or one Technician that matches the filter.
     * @param {TechnicianFindUniqueArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicianFindUniqueArgs>(args: SelectSubset<T, TechnicianFindUniqueArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Technician that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TechnicianFindUniqueOrThrowArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicianFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Technician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianFindFirstArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicianFindFirstArgs>(args?: SelectSubset<T, TechnicianFindFirstArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Technician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianFindFirstOrThrowArgs} args - Arguments to find a Technician
     * @example
     * // Get one Technician
     * const technician = await prisma.technician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicianFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicianFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Technicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Technicians
     * const technicians = await prisma.technician.findMany()
     * 
     * // Get first 10 Technicians
     * const technicians = await prisma.technician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicianWithIdOnly = await prisma.technician.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicianFindManyArgs>(args?: SelectSubset<T, TechnicianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Technician.
     * @param {TechnicianCreateArgs} args - Arguments to create a Technician.
     * @example
     * // Create one Technician
     * const Technician = await prisma.technician.create({
     *   data: {
     *     // ... data to create a Technician
     *   }
     * })
     * 
     */
    create<T extends TechnicianCreateArgs>(args: SelectSubset<T, TechnicianCreateArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Technicians.
     * @param {TechnicianCreateManyArgs} args - Arguments to create many Technicians.
     * @example
     * // Create many Technicians
     * const technician = await prisma.technician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicianCreateManyArgs>(args?: SelectSubset<T, TechnicianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Technicians and returns the data saved in the database.
     * @param {TechnicianCreateManyAndReturnArgs} args - Arguments to create many Technicians.
     * @example
     * // Create many Technicians
     * const technician = await prisma.technician.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Technicians and only return the `id`
     * const technicianWithIdOnly = await prisma.technician.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicianCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Technician.
     * @param {TechnicianDeleteArgs} args - Arguments to delete one Technician.
     * @example
     * // Delete one Technician
     * const Technician = await prisma.technician.delete({
     *   where: {
     *     // ... filter to delete one Technician
     *   }
     * })
     * 
     */
    delete<T extends TechnicianDeleteArgs>(args: SelectSubset<T, TechnicianDeleteArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Technician.
     * @param {TechnicianUpdateArgs} args - Arguments to update one Technician.
     * @example
     * // Update one Technician
     * const technician = await prisma.technician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicianUpdateArgs>(args: SelectSubset<T, TechnicianUpdateArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Technicians.
     * @param {TechnicianDeleteManyArgs} args - Arguments to filter Technicians to delete.
     * @example
     * // Delete a few Technicians
     * const { count } = await prisma.technician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicianDeleteManyArgs>(args?: SelectSubset<T, TechnicianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Technicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Technicians
     * const technician = await prisma.technician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicianUpdateManyArgs>(args: SelectSubset<T, TechnicianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Technician.
     * @param {TechnicianUpsertArgs} args - Arguments to update or create a Technician.
     * @example
     * // Update or create a Technician
     * const technician = await prisma.technician.upsert({
     *   create: {
     *     // ... data to create a Technician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Technician we want to update
     *   }
     * })
     */
    upsert<T extends TechnicianUpsertArgs>(args: SelectSubset<T, TechnicianUpsertArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Technicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianCountArgs} args - Arguments to filter Technicians to count.
     * @example
     * // Count the number of Technicians
     * const count = await prisma.technician.count({
     *   where: {
     *     // ... the filter for the Technicians we want to count
     *   }
     * })
    **/
    count<T extends TechnicianCountArgs>(
      args?: Subset<T, TechnicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Technician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicianAggregateArgs>(args: Subset<T, TechnicianAggregateArgs>): Prisma.PrismaPromise<GetTechnicianAggregateType<T>>

    /**
     * Group by Technician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicianGroupByArgs['orderBy'] }
        : { orderBy?: TechnicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Technician model
   */
  readonly fields: TechnicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Technician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Technician$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Technician$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Technician$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Technician$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Technician model
   */ 
  interface TechnicianFieldRefs {
    readonly id: FieldRef<"Technician", 'String'>
    readonly name: FieldRef<"Technician", 'String'>
    readonly email: FieldRef<"Technician", 'String'>
    readonly phone: FieldRef<"Technician", 'String'>
    readonly specialties: FieldRef<"Technician", 'String'>
    readonly isActive: FieldRef<"Technician", 'Boolean'>
    readonly createdAt: FieldRef<"Technician", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Technician findUnique
   */
  export type TechnicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician findUniqueOrThrow
   */
  export type TechnicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician findFirst
   */
  export type TechnicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Technicians.
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Technicians.
     */
    distinct?: TechnicianScalarFieldEnum | TechnicianScalarFieldEnum[]
  }

  /**
   * Technician findFirstOrThrow
   */
  export type TechnicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technician to fetch.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Technicians.
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Technicians.
     */
    distinct?: TechnicianScalarFieldEnum | TechnicianScalarFieldEnum[]
  }

  /**
   * Technician findMany
   */
  export type TechnicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter, which Technicians to fetch.
     */
    where?: TechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technicians to fetch.
     */
    orderBy?: TechnicianOrderByWithRelationInput | TechnicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Technicians.
     */
    cursor?: TechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technicians.
     */
    skip?: number
    distinct?: TechnicianScalarFieldEnum | TechnicianScalarFieldEnum[]
  }

  /**
   * Technician create
   */
  export type TechnicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Technician.
     */
    data: XOR<TechnicianCreateInput, TechnicianUncheckedCreateInput>
  }

  /**
   * Technician createMany
   */
  export type TechnicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Technicians.
     */
    data: TechnicianCreateManyInput | TechnicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Technician createManyAndReturn
   */
  export type TechnicianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Technicians.
     */
    data: TechnicianCreateManyInput | TechnicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Technician update
   */
  export type TechnicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Technician.
     */
    data: XOR<TechnicianUpdateInput, TechnicianUncheckedUpdateInput>
    /**
     * Choose, which Technician to update.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician updateMany
   */
  export type TechnicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Technicians.
     */
    data: XOR<TechnicianUpdateManyMutationInput, TechnicianUncheckedUpdateManyInput>
    /**
     * Filter which Technicians to update
     */
    where?: TechnicianWhereInput
  }

  /**
   * Technician upsert
   */
  export type TechnicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Technician to update in case it exists.
     */
    where: TechnicianWhereUniqueInput
    /**
     * In case the Technician found by the `where` argument doesn't exist, create a new Technician with this data.
     */
    create: XOR<TechnicianCreateInput, TechnicianUncheckedCreateInput>
    /**
     * In case the Technician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicianUpdateInput, TechnicianUncheckedUpdateInput>
  }

  /**
   * Technician delete
   */
  export type TechnicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    /**
     * Filter which Technician to delete.
     */
    where: TechnicianWhereUniqueInput
  }

  /**
   * Technician deleteMany
   */
  export type TechnicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Technicians to delete
     */
    where?: TechnicianWhereInput
  }

  /**
   * Technician.bookings
   */
  export type Technician$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    cursor?: ServiceBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * Technician.schedules
   */
  export type Technician$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    where?: TechnicianScheduleWhereInput
    orderBy?: TechnicianScheduleOrderByWithRelationInput | TechnicianScheduleOrderByWithRelationInput[]
    cursor?: TechnicianScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicianScheduleScalarFieldEnum | TechnicianScheduleScalarFieldEnum[]
  }

  /**
   * Technician without action
   */
  export type TechnicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
  }


  /**
   * Model ServiceItem
   */

  export type AggregateServiceItem = {
    _count: ServiceItemCountAggregateOutputType | null
    _avg: ServiceItemAvgAggregateOutputType | null
    _sum: ServiceItemSumAggregateOutputType | null
    _min: ServiceItemMinAggregateOutputType | null
    _max: ServiceItemMaxAggregateOutputType | null
  }

  export type ServiceItemAvgAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type ServiceItemSumAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type ServiceItemMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    name: string | null
    price: number | null
    quantity: number | null
    createdAt: Date | null
  }

  export type ServiceItemMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    name: string | null
    price: number | null
    quantity: number | null
    createdAt: Date | null
  }

  export type ServiceItemCountAggregateOutputType = {
    id: number
    serviceId: number
    name: number
    price: number
    quantity: number
    createdAt: number
    _all: number
  }


  export type ServiceItemAvgAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type ServiceItemSumAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type ServiceItemMinAggregateInputType = {
    id?: true
    serviceId?: true
    name?: true
    price?: true
    quantity?: true
    createdAt?: true
  }

  export type ServiceItemMaxAggregateInputType = {
    id?: true
    serviceId?: true
    name?: true
    price?: true
    quantity?: true
    createdAt?: true
  }

  export type ServiceItemCountAggregateInputType = {
    id?: true
    serviceId?: true
    name?: true
    price?: true
    quantity?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceItem to aggregate.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceItems
    **/
    _count?: true | ServiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceItemMaxAggregateInputType
  }

  export type GetServiceItemAggregateType<T extends ServiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceItem[P]>
      : GetScalarType<T[P], AggregateServiceItem[P]>
  }




  export type ServiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceItemWhereInput
    orderBy?: ServiceItemOrderByWithAggregationInput | ServiceItemOrderByWithAggregationInput[]
    by: ServiceItemScalarFieldEnum[] | ServiceItemScalarFieldEnum
    having?: ServiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceItemCountAggregateInputType | true
    _avg?: ServiceItemAvgAggregateInputType
    _sum?: ServiceItemSumAggregateInputType
    _min?: ServiceItemMinAggregateInputType
    _max?: ServiceItemMaxAggregateInputType
  }

  export type ServiceItemGroupByOutputType = {
    id: string
    serviceId: string
    name: string
    price: number
    quantity: number
    createdAt: Date
    _count: ServiceItemCountAggregateOutputType | null
    _avg: ServiceItemAvgAggregateOutputType | null
    _sum: ServiceItemSumAggregateOutputType | null
    _min: ServiceItemMinAggregateOutputType | null
    _max: ServiceItemMaxAggregateOutputType | null
  }

  type GetServiceItemGroupByPayload<T extends ServiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceItemGroupByOutputType[P]>
        }
      >
    >


  export type ServiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
    bookingItems?: boolean | ServiceItem$bookingItemsArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    _count?: boolean | ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceItem"]>

  export type ServiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceItem"]>

  export type ServiceItemSelectScalar = {
    id?: boolean
    serviceId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
  }

  export type ServiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingItems?: boolean | ServiceItem$bookingItemsArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    _count?: boolean | ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceItem"
    objects: {
      bookingItems: Prisma.$ServiceBookingItemPayload<ExtArgs>[]
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      name: string
      price: number
      quantity: number
      createdAt: Date
    }, ExtArgs["result"]["serviceItem"]>
    composites: {}
  }

  type ServiceItemGetPayload<S extends boolean | null | undefined | ServiceItemDefaultArgs> = $Result.GetResult<Prisma.$ServiceItemPayload, S>

  type ServiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceItemCountAggregateInputType | true
    }

  export interface ServiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceItem'], meta: { name: 'ServiceItem' } }
    /**
     * Find zero or one ServiceItem that matches the filter.
     * @param {ServiceItemFindUniqueArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceItemFindUniqueArgs>(args: SelectSubset<T, ServiceItemFindUniqueArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceItemFindUniqueOrThrowArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindFirstArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceItemFindFirstArgs>(args?: SelectSubset<T, ServiceItemFindFirstArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindFirstOrThrowArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceItems
     * const serviceItems = await prisma.serviceItem.findMany()
     * 
     * // Get first 10 ServiceItems
     * const serviceItems = await prisma.serviceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceItemWithIdOnly = await prisma.serviceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceItemFindManyArgs>(args?: SelectSubset<T, ServiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceItem.
     * @param {ServiceItemCreateArgs} args - Arguments to create a ServiceItem.
     * @example
     * // Create one ServiceItem
     * const ServiceItem = await prisma.serviceItem.create({
     *   data: {
     *     // ... data to create a ServiceItem
     *   }
     * })
     * 
     */
    create<T extends ServiceItemCreateArgs>(args: SelectSubset<T, ServiceItemCreateArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceItems.
     * @param {ServiceItemCreateManyArgs} args - Arguments to create many ServiceItems.
     * @example
     * // Create many ServiceItems
     * const serviceItem = await prisma.serviceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceItemCreateManyArgs>(args?: SelectSubset<T, ServiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceItems and returns the data saved in the database.
     * @param {ServiceItemCreateManyAndReturnArgs} args - Arguments to create many ServiceItems.
     * @example
     * // Create many ServiceItems
     * const serviceItem = await prisma.serviceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceItems and only return the `id`
     * const serviceItemWithIdOnly = await prisma.serviceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceItem.
     * @param {ServiceItemDeleteArgs} args - Arguments to delete one ServiceItem.
     * @example
     * // Delete one ServiceItem
     * const ServiceItem = await prisma.serviceItem.delete({
     *   where: {
     *     // ... filter to delete one ServiceItem
     *   }
     * })
     * 
     */
    delete<T extends ServiceItemDeleteArgs>(args: SelectSubset<T, ServiceItemDeleteArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceItem.
     * @param {ServiceItemUpdateArgs} args - Arguments to update one ServiceItem.
     * @example
     * // Update one ServiceItem
     * const serviceItem = await prisma.serviceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceItemUpdateArgs>(args: SelectSubset<T, ServiceItemUpdateArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceItems.
     * @param {ServiceItemDeleteManyArgs} args - Arguments to filter ServiceItems to delete.
     * @example
     * // Delete a few ServiceItems
     * const { count } = await prisma.serviceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceItemDeleteManyArgs>(args?: SelectSubset<T, ServiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceItems
     * const serviceItem = await prisma.serviceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceItemUpdateManyArgs>(args: SelectSubset<T, ServiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceItem.
     * @param {ServiceItemUpsertArgs} args - Arguments to update or create a ServiceItem.
     * @example
     * // Update or create a ServiceItem
     * const serviceItem = await prisma.serviceItem.upsert({
     *   create: {
     *     // ... data to create a ServiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceItem we want to update
     *   }
     * })
     */
    upsert<T extends ServiceItemUpsertArgs>(args: SelectSubset<T, ServiceItemUpsertArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemCountArgs} args - Arguments to filter ServiceItems to count.
     * @example
     * // Count the number of ServiceItems
     * const count = await prisma.serviceItem.count({
     *   where: {
     *     // ... the filter for the ServiceItems we want to count
     *   }
     * })
    **/
    count<T extends ServiceItemCountArgs>(
      args?: Subset<T, ServiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceItemAggregateArgs>(args: Subset<T, ServiceItemAggregateArgs>): Prisma.PrismaPromise<GetServiceItemAggregateType<T>>

    /**
     * Group by ServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceItemGroupByArgs['orderBy'] }
        : { orderBy?: ServiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceItem model
   */
  readonly fields: ServiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingItems<T extends ServiceItem$bookingItemsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceItem$bookingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "findMany"> | Null>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceItem model
   */ 
  interface ServiceItemFieldRefs {
    readonly id: FieldRef<"ServiceItem", 'String'>
    readonly serviceId: FieldRef<"ServiceItem", 'String'>
    readonly name: FieldRef<"ServiceItem", 'String'>
    readonly price: FieldRef<"ServiceItem", 'Int'>
    readonly quantity: FieldRef<"ServiceItem", 'Int'>
    readonly createdAt: FieldRef<"ServiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceItem findUnique
   */
  export type ServiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem findUniqueOrThrow
   */
  export type ServiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem findFirst
   */
  export type ServiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceItems.
     */
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem findFirstOrThrow
   */
  export type ServiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceItems.
     */
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem findMany
   */
  export type ServiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItems to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem create
   */
  export type ServiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceItem.
     */
    data: XOR<ServiceItemCreateInput, ServiceItemUncheckedCreateInput>
  }

  /**
   * ServiceItem createMany
   */
  export type ServiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceItems.
     */
    data: ServiceItemCreateManyInput | ServiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceItem createManyAndReturn
   */
  export type ServiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceItems.
     */
    data: ServiceItemCreateManyInput | ServiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceItem update
   */
  export type ServiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceItem.
     */
    data: XOR<ServiceItemUpdateInput, ServiceItemUncheckedUpdateInput>
    /**
     * Choose, which ServiceItem to update.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem updateMany
   */
  export type ServiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceItems.
     */
    data: XOR<ServiceItemUpdateManyMutationInput, ServiceItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceItems to update
     */
    where?: ServiceItemWhereInput
  }

  /**
   * ServiceItem upsert
   */
  export type ServiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceItem to update in case it exists.
     */
    where: ServiceItemWhereUniqueInput
    /**
     * In case the ServiceItem found by the `where` argument doesn't exist, create a new ServiceItem with this data.
     */
    create: XOR<ServiceItemCreateInput, ServiceItemUncheckedCreateInput>
    /**
     * In case the ServiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceItemUpdateInput, ServiceItemUncheckedUpdateInput>
  }

  /**
   * ServiceItem delete
   */
  export type ServiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter which ServiceItem to delete.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem deleteMany
   */
  export type ServiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceItems to delete
     */
    where?: ServiceItemWhereInput
  }

  /**
   * ServiceItem.bookingItems
   */
  export type ServiceItem$bookingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    where?: ServiceBookingItemWhereInput
    orderBy?: ServiceBookingItemOrderByWithRelationInput | ServiceBookingItemOrderByWithRelationInput[]
    cursor?: ServiceBookingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingItemScalarFieldEnum | ServiceBookingItemScalarFieldEnum[]
  }

  /**
   * ServiceItem without action
   */
  export type ServiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
  }


  /**
   * Model ServiceBooking
   */

  export type AggregateServiceBooking = {
    _count: ServiceBookingCountAggregateOutputType | null
    _avg: ServiceBookingAvgAggregateOutputType | null
    _sum: ServiceBookingSumAggregateOutputType | null
    _min: ServiceBookingMinAggregateOutputType | null
    _max: ServiceBookingMaxAggregateOutputType | null
  }

  export type ServiceBookingAvgAggregateOutputType = {
    estimatedCosts: number | null
    actualCosts: number | null
  }

  export type ServiceBookingSumAggregateOutputType = {
    estimatedCosts: number | null
    actualCosts: number | null
  }

  export type ServiceBookingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    technicianId: string | null
    status: string | null
    scheduledAt: Date | null
    scheduledTime: string | null
    completedAt: Date | null
    notes: string | null
    estimatedCosts: number | null
    actualCosts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceBookingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    technicianId: string | null
    status: string | null
    scheduledAt: Date | null
    scheduledTime: string | null
    completedAt: Date | null
    notes: string | null
    estimatedCosts: number | null
    actualCosts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceBookingCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    technicianId: number
    status: number
    scheduledAt: number
    scheduledTime: number
    completedAt: number
    notes: number
    estimatedCosts: number
    actualCosts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceBookingAvgAggregateInputType = {
    estimatedCosts?: true
    actualCosts?: true
  }

  export type ServiceBookingSumAggregateInputType = {
    estimatedCosts?: true
    actualCosts?: true
  }

  export type ServiceBookingMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    technicianId?: true
    status?: true
    scheduledAt?: true
    scheduledTime?: true
    completedAt?: true
    notes?: true
    estimatedCosts?: true
    actualCosts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceBookingMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    technicianId?: true
    status?: true
    scheduledAt?: true
    scheduledTime?: true
    completedAt?: true
    notes?: true
    estimatedCosts?: true
    actualCosts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceBookingCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    technicianId?: true
    status?: true
    scheduledAt?: true
    scheduledTime?: true
    completedAt?: true
    notes?: true
    estimatedCosts?: true
    actualCosts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBooking to aggregate.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceBookings
    **/
    _count?: true | ServiceBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceBookingMaxAggregateInputType
  }

  export type GetServiceBookingAggregateType<T extends ServiceBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceBooking[P]>
      : GetScalarType<T[P], AggregateServiceBooking[P]>
  }




  export type ServiceBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingWhereInput
    orderBy?: ServiceBookingOrderByWithAggregationInput | ServiceBookingOrderByWithAggregationInput[]
    by: ServiceBookingScalarFieldEnum[] | ServiceBookingScalarFieldEnum
    having?: ServiceBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceBookingCountAggregateInputType | true
    _avg?: ServiceBookingAvgAggregateInputType
    _sum?: ServiceBookingSumAggregateInputType
    _min?: ServiceBookingMinAggregateInputType
    _max?: ServiceBookingMaxAggregateInputType
  }

  export type ServiceBookingGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    technicianId: string | null
    status: string
    scheduledAt: Date | null
    scheduledTime: string | null
    completedAt: Date | null
    notes: string | null
    estimatedCosts: number | null
    actualCosts: number | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceBookingCountAggregateOutputType | null
    _avg: ServiceBookingAvgAggregateOutputType | null
    _sum: ServiceBookingSumAggregateOutputType | null
    _min: ServiceBookingMinAggregateOutputType | null
    _max: ServiceBookingMaxAggregateOutputType | null
  }

  type GetServiceBookingGroupByPayload<T extends ServiceBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceBookingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceBookingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    technicianId?: boolean
    status?: boolean
    scheduledAt?: boolean
    scheduledTime?: boolean
    completedAt?: boolean
    notes?: boolean
    estimatedCosts?: boolean
    actualCosts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | ServiceBooking$itemsArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    technician?: boolean | ServiceBooking$technicianArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | ServiceBooking$paymentsArgs<ExtArgs>
    history?: boolean | ServiceBooking$historyArgs<ExtArgs>
    _count?: boolean | ServiceBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBooking"]>

  export type ServiceBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    technicianId?: boolean
    status?: boolean
    scheduledAt?: boolean
    scheduledTime?: boolean
    completedAt?: boolean
    notes?: boolean
    estimatedCosts?: boolean
    actualCosts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    technician?: boolean | ServiceBooking$technicianArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBooking"]>

  export type ServiceBookingSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    technicianId?: boolean
    status?: boolean
    scheduledAt?: boolean
    scheduledTime?: boolean
    completedAt?: boolean
    notes?: boolean
    estimatedCosts?: boolean
    actualCosts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ServiceBooking$itemsArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    technician?: boolean | ServiceBooking$technicianArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | ServiceBooking$paymentsArgs<ExtArgs>
    history?: boolean | ServiceBooking$historyArgs<ExtArgs>
    _count?: boolean | ServiceBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    technician?: boolean | ServiceBooking$technicianArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ServiceBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceBooking"
    objects: {
      items: Prisma.$ServiceBookingItemPayload<ExtArgs>[]
      service: Prisma.$ServicePayload<ExtArgs>
      technician: Prisma.$TechnicianPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$ServicePaymentPayload<ExtArgs>[]
      history: Prisma.$ServiceStatusHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceId: string
      technicianId: string | null
      status: string
      scheduledAt: Date | null
      scheduledTime: string | null
      completedAt: Date | null
      notes: string | null
      estimatedCosts: number | null
      actualCosts: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceBooking"]>
    composites: {}
  }

  type ServiceBookingGetPayload<S extends boolean | null | undefined | ServiceBookingDefaultArgs> = $Result.GetResult<Prisma.$ServiceBookingPayload, S>

  type ServiceBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceBookingCountAggregateInputType | true
    }

  export interface ServiceBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceBooking'], meta: { name: 'ServiceBooking' } }
    /**
     * Find zero or one ServiceBooking that matches the filter.
     * @param {ServiceBookingFindUniqueArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceBookingFindUniqueArgs>(args: SelectSubset<T, ServiceBookingFindUniqueArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceBookingFindUniqueOrThrowArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingFindFirstArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceBookingFindFirstArgs>(args?: SelectSubset<T, ServiceBookingFindFirstArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingFindFirstOrThrowArgs} args - Arguments to find a ServiceBooking
     * @example
     * // Get one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceBookings
     * const serviceBookings = await prisma.serviceBooking.findMany()
     * 
     * // Get first 10 ServiceBookings
     * const serviceBookings = await prisma.serviceBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceBookingWithIdOnly = await prisma.serviceBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceBookingFindManyArgs>(args?: SelectSubset<T, ServiceBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceBooking.
     * @param {ServiceBookingCreateArgs} args - Arguments to create a ServiceBooking.
     * @example
     * // Create one ServiceBooking
     * const ServiceBooking = await prisma.serviceBooking.create({
     *   data: {
     *     // ... data to create a ServiceBooking
     *   }
     * })
     * 
     */
    create<T extends ServiceBookingCreateArgs>(args: SelectSubset<T, ServiceBookingCreateArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceBookings.
     * @param {ServiceBookingCreateManyArgs} args - Arguments to create many ServiceBookings.
     * @example
     * // Create many ServiceBookings
     * const serviceBooking = await prisma.serviceBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceBookingCreateManyArgs>(args?: SelectSubset<T, ServiceBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceBookings and returns the data saved in the database.
     * @param {ServiceBookingCreateManyAndReturnArgs} args - Arguments to create many ServiceBookings.
     * @example
     * // Create many ServiceBookings
     * const serviceBooking = await prisma.serviceBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceBookings and only return the `id`
     * const serviceBookingWithIdOnly = await prisma.serviceBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceBooking.
     * @param {ServiceBookingDeleteArgs} args - Arguments to delete one ServiceBooking.
     * @example
     * // Delete one ServiceBooking
     * const ServiceBooking = await prisma.serviceBooking.delete({
     *   where: {
     *     // ... filter to delete one ServiceBooking
     *   }
     * })
     * 
     */
    delete<T extends ServiceBookingDeleteArgs>(args: SelectSubset<T, ServiceBookingDeleteArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceBooking.
     * @param {ServiceBookingUpdateArgs} args - Arguments to update one ServiceBooking.
     * @example
     * // Update one ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceBookingUpdateArgs>(args: SelectSubset<T, ServiceBookingUpdateArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceBookings.
     * @param {ServiceBookingDeleteManyArgs} args - Arguments to filter ServiceBookings to delete.
     * @example
     * // Delete a few ServiceBookings
     * const { count } = await prisma.serviceBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceBookingDeleteManyArgs>(args?: SelectSubset<T, ServiceBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceBookings
     * const serviceBooking = await prisma.serviceBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceBookingUpdateManyArgs>(args: SelectSubset<T, ServiceBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceBooking.
     * @param {ServiceBookingUpsertArgs} args - Arguments to update or create a ServiceBooking.
     * @example
     * // Update or create a ServiceBooking
     * const serviceBooking = await prisma.serviceBooking.upsert({
     *   create: {
     *     // ... data to create a ServiceBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceBooking we want to update
     *   }
     * })
     */
    upsert<T extends ServiceBookingUpsertArgs>(args: SelectSubset<T, ServiceBookingUpsertArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingCountArgs} args - Arguments to filter ServiceBookings to count.
     * @example
     * // Count the number of ServiceBookings
     * const count = await prisma.serviceBooking.count({
     *   where: {
     *     // ... the filter for the ServiceBookings we want to count
     *   }
     * })
    **/
    count<T extends ServiceBookingCountArgs>(
      args?: Subset<T, ServiceBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceBookingAggregateArgs>(args: Subset<T, ServiceBookingAggregateArgs>): Prisma.PrismaPromise<GetServiceBookingAggregateType<T>>

    /**
     * Group by ServiceBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceBookingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceBooking model
   */
  readonly fields: ServiceBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends ServiceBooking$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBooking$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "findMany"> | Null>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    technician<T extends ServiceBooking$technicianArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBooking$technicianArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends ServiceBooking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBooking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "findMany"> | Null>
    history<T extends ServiceBooking$historyArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBooking$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceBooking model
   */ 
  interface ServiceBookingFieldRefs {
    readonly id: FieldRef<"ServiceBooking", 'String'>
    readonly userId: FieldRef<"ServiceBooking", 'String'>
    readonly serviceId: FieldRef<"ServiceBooking", 'String'>
    readonly technicianId: FieldRef<"ServiceBooking", 'String'>
    readonly status: FieldRef<"ServiceBooking", 'String'>
    readonly scheduledAt: FieldRef<"ServiceBooking", 'DateTime'>
    readonly scheduledTime: FieldRef<"ServiceBooking", 'String'>
    readonly completedAt: FieldRef<"ServiceBooking", 'DateTime'>
    readonly notes: FieldRef<"ServiceBooking", 'String'>
    readonly estimatedCosts: FieldRef<"ServiceBooking", 'Int'>
    readonly actualCosts: FieldRef<"ServiceBooking", 'Int'>
    readonly createdAt: FieldRef<"ServiceBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceBooking findUnique
   */
  export type ServiceBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking findUniqueOrThrow
   */
  export type ServiceBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking findFirst
   */
  export type ServiceBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBookings.
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBookings.
     */
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * ServiceBooking findFirstOrThrow
   */
  export type ServiceBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBooking to fetch.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBookings.
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBookings.
     */
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * ServiceBooking findMany
   */
  export type ServiceBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBookings to fetch.
     */
    where?: ServiceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookings to fetch.
     */
    orderBy?: ServiceBookingOrderByWithRelationInput | ServiceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceBookings.
     */
    cursor?: ServiceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookings.
     */
    skip?: number
    distinct?: ServiceBookingScalarFieldEnum | ServiceBookingScalarFieldEnum[]
  }

  /**
   * ServiceBooking create
   */
  export type ServiceBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceBooking.
     */
    data: XOR<ServiceBookingCreateInput, ServiceBookingUncheckedCreateInput>
  }

  /**
   * ServiceBooking createMany
   */
  export type ServiceBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceBookings.
     */
    data: ServiceBookingCreateManyInput | ServiceBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceBooking createManyAndReturn
   */
  export type ServiceBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceBookings.
     */
    data: ServiceBookingCreateManyInput | ServiceBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceBooking update
   */
  export type ServiceBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceBooking.
     */
    data: XOR<ServiceBookingUpdateInput, ServiceBookingUncheckedUpdateInput>
    /**
     * Choose, which ServiceBooking to update.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking updateMany
   */
  export type ServiceBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceBookings.
     */
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceBookings to update
     */
    where?: ServiceBookingWhereInput
  }

  /**
   * ServiceBooking upsert
   */
  export type ServiceBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceBooking to update in case it exists.
     */
    where: ServiceBookingWhereUniqueInput
    /**
     * In case the ServiceBooking found by the `where` argument doesn't exist, create a new ServiceBooking with this data.
     */
    create: XOR<ServiceBookingCreateInput, ServiceBookingUncheckedCreateInput>
    /**
     * In case the ServiceBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceBookingUpdateInput, ServiceBookingUncheckedUpdateInput>
  }

  /**
   * ServiceBooking delete
   */
  export type ServiceBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
    /**
     * Filter which ServiceBooking to delete.
     */
    where: ServiceBookingWhereUniqueInput
  }

  /**
   * ServiceBooking deleteMany
   */
  export type ServiceBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBookings to delete
     */
    where?: ServiceBookingWhereInput
  }

  /**
   * ServiceBooking.items
   */
  export type ServiceBooking$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    where?: ServiceBookingItemWhereInput
    orderBy?: ServiceBookingItemOrderByWithRelationInput | ServiceBookingItemOrderByWithRelationInput[]
    cursor?: ServiceBookingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBookingItemScalarFieldEnum | ServiceBookingItemScalarFieldEnum[]
  }

  /**
   * ServiceBooking.technician
   */
  export type ServiceBooking$technicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technician
     */
    select?: TechnicianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianInclude<ExtArgs> | null
    where?: TechnicianWhereInput
  }

  /**
   * ServiceBooking.payments
   */
  export type ServiceBooking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    where?: ServicePaymentWhereInput
    orderBy?: ServicePaymentOrderByWithRelationInput | ServicePaymentOrderByWithRelationInput[]
    cursor?: ServicePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePaymentScalarFieldEnum | ServicePaymentScalarFieldEnum[]
  }

  /**
   * ServiceBooking.history
   */
  export type ServiceBooking$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    where?: ServiceStatusHistoryWhereInput
    orderBy?: ServiceStatusHistoryOrderByWithRelationInput | ServiceStatusHistoryOrderByWithRelationInput[]
    cursor?: ServiceStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[]
  }

  /**
   * ServiceBooking without action
   */
  export type ServiceBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBooking
     */
    select?: ServiceBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingInclude<ExtArgs> | null
  }


  /**
   * Model ServiceBookingItem
   */

  export type AggregateServiceBookingItem = {
    _count: ServiceBookingItemCountAggregateOutputType | null
    _avg: ServiceBookingItemAvgAggregateOutputType | null
    _sum: ServiceBookingItemSumAggregateOutputType | null
    _min: ServiceBookingItemMinAggregateOutputType | null
    _max: ServiceBookingItemMaxAggregateOutputType | null
  }

  export type ServiceBookingItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type ServiceBookingItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type ServiceBookingItemMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    serviceItemId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
  }

  export type ServiceBookingItemMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    serviceItemId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
  }

  export type ServiceBookingItemCountAggregateOutputType = {
    id: number
    bookingId: number
    serviceItemId: number
    quantity: number
    price: number
    createdAt: number
    _all: number
  }


  export type ServiceBookingItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type ServiceBookingItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type ServiceBookingItemMinAggregateInputType = {
    id?: true
    bookingId?: true
    serviceItemId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type ServiceBookingItemMaxAggregateInputType = {
    id?: true
    bookingId?: true
    serviceItemId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type ServiceBookingItemCountAggregateInputType = {
    id?: true
    bookingId?: true
    serviceItemId?: true
    quantity?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceBookingItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBookingItem to aggregate.
     */
    where?: ServiceBookingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookingItems to fetch.
     */
    orderBy?: ServiceBookingItemOrderByWithRelationInput | ServiceBookingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceBookingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceBookingItems
    **/
    _count?: true | ServiceBookingItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceBookingItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceBookingItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceBookingItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceBookingItemMaxAggregateInputType
  }

  export type GetServiceBookingItemAggregateType<T extends ServiceBookingItemAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceBookingItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceBookingItem[P]>
      : GetScalarType<T[P], AggregateServiceBookingItem[P]>
  }




  export type ServiceBookingItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBookingItemWhereInput
    orderBy?: ServiceBookingItemOrderByWithAggregationInput | ServiceBookingItemOrderByWithAggregationInput[]
    by: ServiceBookingItemScalarFieldEnum[] | ServiceBookingItemScalarFieldEnum
    having?: ServiceBookingItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceBookingItemCountAggregateInputType | true
    _avg?: ServiceBookingItemAvgAggregateInputType
    _sum?: ServiceBookingItemSumAggregateInputType
    _min?: ServiceBookingItemMinAggregateInputType
    _max?: ServiceBookingItemMaxAggregateInputType
  }

  export type ServiceBookingItemGroupByOutputType = {
    id: string
    bookingId: string
    serviceItemId: string
    quantity: number
    price: number
    createdAt: Date
    _count: ServiceBookingItemCountAggregateOutputType | null
    _avg: ServiceBookingItemAvgAggregateOutputType | null
    _sum: ServiceBookingItemSumAggregateOutputType | null
    _min: ServiceBookingItemMinAggregateOutputType | null
    _max: ServiceBookingItemMaxAggregateOutputType | null
  }

  type GetServiceBookingItemGroupByPayload<T extends ServiceBookingItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceBookingItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceBookingItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceBookingItemGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceBookingItemGroupByOutputType[P]>
        }
      >
    >


  export type ServiceBookingItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceItemId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBookingItem"]>

  export type ServiceBookingItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceItemId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBookingItem"]>

  export type ServiceBookingItemSelectScalar = {
    id?: boolean
    bookingId?: boolean
    serviceItemId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type ServiceBookingItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
  }
  export type ServiceBookingItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
  }

  export type $ServiceBookingItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceBookingItem"
    objects: {
      booking: Prisma.$ServiceBookingPayload<ExtArgs>
      serviceItem: Prisma.$ServiceItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      serviceItemId: string
      quantity: number
      price: number
      createdAt: Date
    }, ExtArgs["result"]["serviceBookingItem"]>
    composites: {}
  }

  type ServiceBookingItemGetPayload<S extends boolean | null | undefined | ServiceBookingItemDefaultArgs> = $Result.GetResult<Prisma.$ServiceBookingItemPayload, S>

  type ServiceBookingItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceBookingItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceBookingItemCountAggregateInputType | true
    }

  export interface ServiceBookingItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceBookingItem'], meta: { name: 'ServiceBookingItem' } }
    /**
     * Find zero or one ServiceBookingItem that matches the filter.
     * @param {ServiceBookingItemFindUniqueArgs} args - Arguments to find a ServiceBookingItem
     * @example
     * // Get one ServiceBookingItem
     * const serviceBookingItem = await prisma.serviceBookingItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceBookingItemFindUniqueArgs>(args: SelectSubset<T, ServiceBookingItemFindUniqueArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceBookingItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceBookingItemFindUniqueOrThrowArgs} args - Arguments to find a ServiceBookingItem
     * @example
     * // Get one ServiceBookingItem
     * const serviceBookingItem = await prisma.serviceBookingItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceBookingItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceBookingItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceBookingItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingItemFindFirstArgs} args - Arguments to find a ServiceBookingItem
     * @example
     * // Get one ServiceBookingItem
     * const serviceBookingItem = await prisma.serviceBookingItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceBookingItemFindFirstArgs>(args?: SelectSubset<T, ServiceBookingItemFindFirstArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceBookingItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingItemFindFirstOrThrowArgs} args - Arguments to find a ServiceBookingItem
     * @example
     * // Get one ServiceBookingItem
     * const serviceBookingItem = await prisma.serviceBookingItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceBookingItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceBookingItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceBookingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceBookingItems
     * const serviceBookingItems = await prisma.serviceBookingItem.findMany()
     * 
     * // Get first 10 ServiceBookingItems
     * const serviceBookingItems = await prisma.serviceBookingItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceBookingItemWithIdOnly = await prisma.serviceBookingItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceBookingItemFindManyArgs>(args?: SelectSubset<T, ServiceBookingItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceBookingItem.
     * @param {ServiceBookingItemCreateArgs} args - Arguments to create a ServiceBookingItem.
     * @example
     * // Create one ServiceBookingItem
     * const ServiceBookingItem = await prisma.serviceBookingItem.create({
     *   data: {
     *     // ... data to create a ServiceBookingItem
     *   }
     * })
     * 
     */
    create<T extends ServiceBookingItemCreateArgs>(args: SelectSubset<T, ServiceBookingItemCreateArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceBookingItems.
     * @param {ServiceBookingItemCreateManyArgs} args - Arguments to create many ServiceBookingItems.
     * @example
     * // Create many ServiceBookingItems
     * const serviceBookingItem = await prisma.serviceBookingItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceBookingItemCreateManyArgs>(args?: SelectSubset<T, ServiceBookingItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceBookingItems and returns the data saved in the database.
     * @param {ServiceBookingItemCreateManyAndReturnArgs} args - Arguments to create many ServiceBookingItems.
     * @example
     * // Create many ServiceBookingItems
     * const serviceBookingItem = await prisma.serviceBookingItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceBookingItems and only return the `id`
     * const serviceBookingItemWithIdOnly = await prisma.serviceBookingItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceBookingItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceBookingItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceBookingItem.
     * @param {ServiceBookingItemDeleteArgs} args - Arguments to delete one ServiceBookingItem.
     * @example
     * // Delete one ServiceBookingItem
     * const ServiceBookingItem = await prisma.serviceBookingItem.delete({
     *   where: {
     *     // ... filter to delete one ServiceBookingItem
     *   }
     * })
     * 
     */
    delete<T extends ServiceBookingItemDeleteArgs>(args: SelectSubset<T, ServiceBookingItemDeleteArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceBookingItem.
     * @param {ServiceBookingItemUpdateArgs} args - Arguments to update one ServiceBookingItem.
     * @example
     * // Update one ServiceBookingItem
     * const serviceBookingItem = await prisma.serviceBookingItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceBookingItemUpdateArgs>(args: SelectSubset<T, ServiceBookingItemUpdateArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceBookingItems.
     * @param {ServiceBookingItemDeleteManyArgs} args - Arguments to filter ServiceBookingItems to delete.
     * @example
     * // Delete a few ServiceBookingItems
     * const { count } = await prisma.serviceBookingItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceBookingItemDeleteManyArgs>(args?: SelectSubset<T, ServiceBookingItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceBookingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceBookingItems
     * const serviceBookingItem = await prisma.serviceBookingItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceBookingItemUpdateManyArgs>(args: SelectSubset<T, ServiceBookingItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceBookingItem.
     * @param {ServiceBookingItemUpsertArgs} args - Arguments to update or create a ServiceBookingItem.
     * @example
     * // Update or create a ServiceBookingItem
     * const serviceBookingItem = await prisma.serviceBookingItem.upsert({
     *   create: {
     *     // ... data to create a ServiceBookingItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceBookingItem we want to update
     *   }
     * })
     */
    upsert<T extends ServiceBookingItemUpsertArgs>(args: SelectSubset<T, ServiceBookingItemUpsertArgs<ExtArgs>>): Prisma__ServiceBookingItemClient<$Result.GetResult<Prisma.$ServiceBookingItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceBookingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingItemCountArgs} args - Arguments to filter ServiceBookingItems to count.
     * @example
     * // Count the number of ServiceBookingItems
     * const count = await prisma.serviceBookingItem.count({
     *   where: {
     *     // ... the filter for the ServiceBookingItems we want to count
     *   }
     * })
    **/
    count<T extends ServiceBookingItemCountArgs>(
      args?: Subset<T, ServiceBookingItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceBookingItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceBookingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceBookingItemAggregateArgs>(args: Subset<T, ServiceBookingItemAggregateArgs>): Prisma.PrismaPromise<GetServiceBookingItemAggregateType<T>>

    /**
     * Group by ServiceBookingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBookingItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceBookingItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceBookingItemGroupByArgs['orderBy'] }
        : { orderBy?: ServiceBookingItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceBookingItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceBookingItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceBookingItem model
   */
  readonly fields: ServiceBookingItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceBookingItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceBookingItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends ServiceBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBookingDefaultArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    serviceItem<T extends ServiceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceItemDefaultArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceBookingItem model
   */ 
  interface ServiceBookingItemFieldRefs {
    readonly id: FieldRef<"ServiceBookingItem", 'String'>
    readonly bookingId: FieldRef<"ServiceBookingItem", 'String'>
    readonly serviceItemId: FieldRef<"ServiceBookingItem", 'String'>
    readonly quantity: FieldRef<"ServiceBookingItem", 'Int'>
    readonly price: FieldRef<"ServiceBookingItem", 'Int'>
    readonly createdAt: FieldRef<"ServiceBookingItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceBookingItem findUnique
   */
  export type ServiceBookingItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBookingItem to fetch.
     */
    where: ServiceBookingItemWhereUniqueInput
  }

  /**
   * ServiceBookingItem findUniqueOrThrow
   */
  export type ServiceBookingItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBookingItem to fetch.
     */
    where: ServiceBookingItemWhereUniqueInput
  }

  /**
   * ServiceBookingItem findFirst
   */
  export type ServiceBookingItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBookingItem to fetch.
     */
    where?: ServiceBookingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookingItems to fetch.
     */
    orderBy?: ServiceBookingItemOrderByWithRelationInput | ServiceBookingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBookingItems.
     */
    cursor?: ServiceBookingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBookingItems.
     */
    distinct?: ServiceBookingItemScalarFieldEnum | ServiceBookingItemScalarFieldEnum[]
  }

  /**
   * ServiceBookingItem findFirstOrThrow
   */
  export type ServiceBookingItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBookingItem to fetch.
     */
    where?: ServiceBookingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookingItems to fetch.
     */
    orderBy?: ServiceBookingItemOrderByWithRelationInput | ServiceBookingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBookingItems.
     */
    cursor?: ServiceBookingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBookingItems.
     */
    distinct?: ServiceBookingItemScalarFieldEnum | ServiceBookingItemScalarFieldEnum[]
  }

  /**
   * ServiceBookingItem findMany
   */
  export type ServiceBookingItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBookingItems to fetch.
     */
    where?: ServiceBookingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBookingItems to fetch.
     */
    orderBy?: ServiceBookingItemOrderByWithRelationInput | ServiceBookingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceBookingItems.
     */
    cursor?: ServiceBookingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBookingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBookingItems.
     */
    skip?: number
    distinct?: ServiceBookingItemScalarFieldEnum | ServiceBookingItemScalarFieldEnum[]
  }

  /**
   * ServiceBookingItem create
   */
  export type ServiceBookingItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceBookingItem.
     */
    data: XOR<ServiceBookingItemCreateInput, ServiceBookingItemUncheckedCreateInput>
  }

  /**
   * ServiceBookingItem createMany
   */
  export type ServiceBookingItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceBookingItems.
     */
    data: ServiceBookingItemCreateManyInput | ServiceBookingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceBookingItem createManyAndReturn
   */
  export type ServiceBookingItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceBookingItems.
     */
    data: ServiceBookingItemCreateManyInput | ServiceBookingItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceBookingItem update
   */
  export type ServiceBookingItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceBookingItem.
     */
    data: XOR<ServiceBookingItemUpdateInput, ServiceBookingItemUncheckedUpdateInput>
    /**
     * Choose, which ServiceBookingItem to update.
     */
    where: ServiceBookingItemWhereUniqueInput
  }

  /**
   * ServiceBookingItem updateMany
   */
  export type ServiceBookingItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceBookingItems.
     */
    data: XOR<ServiceBookingItemUpdateManyMutationInput, ServiceBookingItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceBookingItems to update
     */
    where?: ServiceBookingItemWhereInput
  }

  /**
   * ServiceBookingItem upsert
   */
  export type ServiceBookingItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceBookingItem to update in case it exists.
     */
    where: ServiceBookingItemWhereUniqueInput
    /**
     * In case the ServiceBookingItem found by the `where` argument doesn't exist, create a new ServiceBookingItem with this data.
     */
    create: XOR<ServiceBookingItemCreateInput, ServiceBookingItemUncheckedCreateInput>
    /**
     * In case the ServiceBookingItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceBookingItemUpdateInput, ServiceBookingItemUncheckedUpdateInput>
  }

  /**
   * ServiceBookingItem delete
   */
  export type ServiceBookingItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
    /**
     * Filter which ServiceBookingItem to delete.
     */
    where: ServiceBookingItemWhereUniqueInput
  }

  /**
   * ServiceBookingItem deleteMany
   */
  export type ServiceBookingItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBookingItems to delete
     */
    where?: ServiceBookingItemWhereInput
  }

  /**
   * ServiceBookingItem without action
   */
  export type ServiceBookingItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBookingItem
     */
    select?: ServiceBookingItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBookingItemInclude<ExtArgs> | null
  }


  /**
   * Model TechnicianSchedule
   */

  export type AggregateTechnicianSchedule = {
    _count: TechnicianScheduleCountAggregateOutputType | null
    _min: TechnicianScheduleMinAggregateOutputType | null
    _max: TechnicianScheduleMaxAggregateOutputType | null
  }

  export type TechnicianScheduleMinAggregateOutputType = {
    id: string | null
    technicianId: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    createdAt: Date | null
  }

  export type TechnicianScheduleMaxAggregateOutputType = {
    id: string | null
    technicianId: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    createdAt: Date | null
  }

  export type TechnicianScheduleCountAggregateOutputType = {
    id: number
    technicianId: number
    date: number
    startTime: number
    endTime: number
    isAvailable: number
    createdAt: number
    _all: number
  }


  export type TechnicianScheduleMinAggregateInputType = {
    id?: true
    technicianId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    createdAt?: true
  }

  export type TechnicianScheduleMaxAggregateInputType = {
    id?: true
    technicianId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    createdAt?: true
  }

  export type TechnicianScheduleCountAggregateInputType = {
    id?: true
    technicianId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    createdAt?: true
    _all?: true
  }

  export type TechnicianScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicianSchedule to aggregate.
     */
    where?: TechnicianScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSchedules to fetch.
     */
    orderBy?: TechnicianScheduleOrderByWithRelationInput | TechnicianScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicianScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicianSchedules
    **/
    _count?: true | TechnicianScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicianScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicianScheduleMaxAggregateInputType
  }

  export type GetTechnicianScheduleAggregateType<T extends TechnicianScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicianSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicianSchedule[P]>
      : GetScalarType<T[P], AggregateTechnicianSchedule[P]>
  }




  export type TechnicianScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianScheduleWhereInput
    orderBy?: TechnicianScheduleOrderByWithAggregationInput | TechnicianScheduleOrderByWithAggregationInput[]
    by: TechnicianScheduleScalarFieldEnum[] | TechnicianScheduleScalarFieldEnum
    having?: TechnicianScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicianScheduleCountAggregateInputType | true
    _min?: TechnicianScheduleMinAggregateInputType
    _max?: TechnicianScheduleMaxAggregateInputType
  }

  export type TechnicianScheduleGroupByOutputType = {
    id: string
    technicianId: string
    date: Date
    startTime: string
    endTime: string
    isAvailable: boolean
    createdAt: Date
    _count: TechnicianScheduleCountAggregateOutputType | null
    _min: TechnicianScheduleMinAggregateOutputType | null
    _max: TechnicianScheduleMaxAggregateOutputType | null
  }

  type GetTechnicianScheduleGroupByPayload<T extends TechnicianScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicianScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicianScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicianScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicianScheduleGroupByOutputType[P]>
        }
      >
    >


  export type TechnicianScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    technicianId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    technician?: boolean | TechnicianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianSchedule"]>

  export type TechnicianScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    technicianId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    technician?: boolean | TechnicianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianSchedule"]>

  export type TechnicianScheduleSelectScalar = {
    id?: boolean
    technicianId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    createdAt?: boolean
  }

  export type TechnicianScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technician?: boolean | TechnicianDefaultArgs<ExtArgs>
  }
  export type TechnicianScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    technician?: boolean | TechnicianDefaultArgs<ExtArgs>
  }

  export type $TechnicianSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicianSchedule"
    objects: {
      technician: Prisma.$TechnicianPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      technicianId: string
      date: Date
      startTime: string
      endTime: string
      isAvailable: boolean
      createdAt: Date
    }, ExtArgs["result"]["technicianSchedule"]>
    composites: {}
  }

  type TechnicianScheduleGetPayload<S extends boolean | null | undefined | TechnicianScheduleDefaultArgs> = $Result.GetResult<Prisma.$TechnicianSchedulePayload, S>

  type TechnicianScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TechnicianScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TechnicianScheduleCountAggregateInputType | true
    }

  export interface TechnicianScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicianSchedule'], meta: { name: 'TechnicianSchedule' } }
    /**
     * Find zero or one TechnicianSchedule that matches the filter.
     * @param {TechnicianScheduleFindUniqueArgs} args - Arguments to find a TechnicianSchedule
     * @example
     * // Get one TechnicianSchedule
     * const technicianSchedule = await prisma.technicianSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicianScheduleFindUniqueArgs>(args: SelectSubset<T, TechnicianScheduleFindUniqueArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TechnicianSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TechnicianScheduleFindUniqueOrThrowArgs} args - Arguments to find a TechnicianSchedule
     * @example
     * // Get one TechnicianSchedule
     * const technicianSchedule = await prisma.technicianSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicianScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicianScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TechnicianSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianScheduleFindFirstArgs} args - Arguments to find a TechnicianSchedule
     * @example
     * // Get one TechnicianSchedule
     * const technicianSchedule = await prisma.technicianSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicianScheduleFindFirstArgs>(args?: SelectSubset<T, TechnicianScheduleFindFirstArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TechnicianSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianScheduleFindFirstOrThrowArgs} args - Arguments to find a TechnicianSchedule
     * @example
     * // Get one TechnicianSchedule
     * const technicianSchedule = await prisma.technicianSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicianScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicianScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TechnicianSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicianSchedules
     * const technicianSchedules = await prisma.technicianSchedule.findMany()
     * 
     * // Get first 10 TechnicianSchedules
     * const technicianSchedules = await prisma.technicianSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicianScheduleWithIdOnly = await prisma.technicianSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicianScheduleFindManyArgs>(args?: SelectSubset<T, TechnicianScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TechnicianSchedule.
     * @param {TechnicianScheduleCreateArgs} args - Arguments to create a TechnicianSchedule.
     * @example
     * // Create one TechnicianSchedule
     * const TechnicianSchedule = await prisma.technicianSchedule.create({
     *   data: {
     *     // ... data to create a TechnicianSchedule
     *   }
     * })
     * 
     */
    create<T extends TechnicianScheduleCreateArgs>(args: SelectSubset<T, TechnicianScheduleCreateArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TechnicianSchedules.
     * @param {TechnicianScheduleCreateManyArgs} args - Arguments to create many TechnicianSchedules.
     * @example
     * // Create many TechnicianSchedules
     * const technicianSchedule = await prisma.technicianSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicianScheduleCreateManyArgs>(args?: SelectSubset<T, TechnicianScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicianSchedules and returns the data saved in the database.
     * @param {TechnicianScheduleCreateManyAndReturnArgs} args - Arguments to create many TechnicianSchedules.
     * @example
     * // Create many TechnicianSchedules
     * const technicianSchedule = await prisma.technicianSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicianSchedules and only return the `id`
     * const technicianScheduleWithIdOnly = await prisma.technicianSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicianScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicianScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TechnicianSchedule.
     * @param {TechnicianScheduleDeleteArgs} args - Arguments to delete one TechnicianSchedule.
     * @example
     * // Delete one TechnicianSchedule
     * const TechnicianSchedule = await prisma.technicianSchedule.delete({
     *   where: {
     *     // ... filter to delete one TechnicianSchedule
     *   }
     * })
     * 
     */
    delete<T extends TechnicianScheduleDeleteArgs>(args: SelectSubset<T, TechnicianScheduleDeleteArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TechnicianSchedule.
     * @param {TechnicianScheduleUpdateArgs} args - Arguments to update one TechnicianSchedule.
     * @example
     * // Update one TechnicianSchedule
     * const technicianSchedule = await prisma.technicianSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicianScheduleUpdateArgs>(args: SelectSubset<T, TechnicianScheduleUpdateArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TechnicianSchedules.
     * @param {TechnicianScheduleDeleteManyArgs} args - Arguments to filter TechnicianSchedules to delete.
     * @example
     * // Delete a few TechnicianSchedules
     * const { count } = await prisma.technicianSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicianScheduleDeleteManyArgs>(args?: SelectSubset<T, TechnicianScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicianSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicianSchedules
     * const technicianSchedule = await prisma.technicianSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicianScheduleUpdateManyArgs>(args: SelectSubset<T, TechnicianScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TechnicianSchedule.
     * @param {TechnicianScheduleUpsertArgs} args - Arguments to update or create a TechnicianSchedule.
     * @example
     * // Update or create a TechnicianSchedule
     * const technicianSchedule = await prisma.technicianSchedule.upsert({
     *   create: {
     *     // ... data to create a TechnicianSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicianSchedule we want to update
     *   }
     * })
     */
    upsert<T extends TechnicianScheduleUpsertArgs>(args: SelectSubset<T, TechnicianScheduleUpsertArgs<ExtArgs>>): Prisma__TechnicianScheduleClient<$Result.GetResult<Prisma.$TechnicianSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TechnicianSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianScheduleCountArgs} args - Arguments to filter TechnicianSchedules to count.
     * @example
     * // Count the number of TechnicianSchedules
     * const count = await prisma.technicianSchedule.count({
     *   where: {
     *     // ... the filter for the TechnicianSchedules we want to count
     *   }
     * })
    **/
    count<T extends TechnicianScheduleCountArgs>(
      args?: Subset<T, TechnicianScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicianScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicianSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicianScheduleAggregateArgs>(args: Subset<T, TechnicianScheduleAggregateArgs>): Prisma.PrismaPromise<GetTechnicianScheduleAggregateType<T>>

    /**
     * Group by TechnicianSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicianScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicianScheduleGroupByArgs['orderBy'] }
        : { orderBy?: TechnicianScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicianScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicianScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicianSchedule model
   */
  readonly fields: TechnicianScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicianSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicianScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    technician<T extends TechnicianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TechnicianDefaultArgs<ExtArgs>>): Prisma__TechnicianClient<$Result.GetResult<Prisma.$TechnicianPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicianSchedule model
   */ 
  interface TechnicianScheduleFieldRefs {
    readonly id: FieldRef<"TechnicianSchedule", 'String'>
    readonly technicianId: FieldRef<"TechnicianSchedule", 'String'>
    readonly date: FieldRef<"TechnicianSchedule", 'DateTime'>
    readonly startTime: FieldRef<"TechnicianSchedule", 'String'>
    readonly endTime: FieldRef<"TechnicianSchedule", 'String'>
    readonly isAvailable: FieldRef<"TechnicianSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"TechnicianSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TechnicianSchedule findUnique
   */
  export type TechnicianScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSchedule to fetch.
     */
    where: TechnicianScheduleWhereUniqueInput
  }

  /**
   * TechnicianSchedule findUniqueOrThrow
   */
  export type TechnicianScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSchedule to fetch.
     */
    where: TechnicianScheduleWhereUniqueInput
  }

  /**
   * TechnicianSchedule findFirst
   */
  export type TechnicianScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSchedule to fetch.
     */
    where?: TechnicianScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSchedules to fetch.
     */
    orderBy?: TechnicianScheduleOrderByWithRelationInput | TechnicianScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicianSchedules.
     */
    cursor?: TechnicianScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicianSchedules.
     */
    distinct?: TechnicianScheduleScalarFieldEnum | TechnicianScheduleScalarFieldEnum[]
  }

  /**
   * TechnicianSchedule findFirstOrThrow
   */
  export type TechnicianScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSchedule to fetch.
     */
    where?: TechnicianScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSchedules to fetch.
     */
    orderBy?: TechnicianScheduleOrderByWithRelationInput | TechnicianScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicianSchedules.
     */
    cursor?: TechnicianScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicianSchedules.
     */
    distinct?: TechnicianScheduleScalarFieldEnum | TechnicianScheduleScalarFieldEnum[]
  }

  /**
   * TechnicianSchedule findMany
   */
  export type TechnicianScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSchedules to fetch.
     */
    where?: TechnicianScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSchedules to fetch.
     */
    orderBy?: TechnicianScheduleOrderByWithRelationInput | TechnicianScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicianSchedules.
     */
    cursor?: TechnicianScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSchedules.
     */
    skip?: number
    distinct?: TechnicianScheduleScalarFieldEnum | TechnicianScheduleScalarFieldEnum[]
  }

  /**
   * TechnicianSchedule create
   */
  export type TechnicianScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicianSchedule.
     */
    data: XOR<TechnicianScheduleCreateInput, TechnicianScheduleUncheckedCreateInput>
  }

  /**
   * TechnicianSchedule createMany
   */
  export type TechnicianScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicianSchedules.
     */
    data: TechnicianScheduleCreateManyInput | TechnicianScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicianSchedule createManyAndReturn
   */
  export type TechnicianScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TechnicianSchedules.
     */
    data: TechnicianScheduleCreateManyInput | TechnicianScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicianSchedule update
   */
  export type TechnicianScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicianSchedule.
     */
    data: XOR<TechnicianScheduleUpdateInput, TechnicianScheduleUncheckedUpdateInput>
    /**
     * Choose, which TechnicianSchedule to update.
     */
    where: TechnicianScheduleWhereUniqueInput
  }

  /**
   * TechnicianSchedule updateMany
   */
  export type TechnicianScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicianSchedules.
     */
    data: XOR<TechnicianScheduleUpdateManyMutationInput, TechnicianScheduleUncheckedUpdateManyInput>
    /**
     * Filter which TechnicianSchedules to update
     */
    where?: TechnicianScheduleWhereInput
  }

  /**
   * TechnicianSchedule upsert
   */
  export type TechnicianScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicianSchedule to update in case it exists.
     */
    where: TechnicianScheduleWhereUniqueInput
    /**
     * In case the TechnicianSchedule found by the `where` argument doesn't exist, create a new TechnicianSchedule with this data.
     */
    create: XOR<TechnicianScheduleCreateInput, TechnicianScheduleUncheckedCreateInput>
    /**
     * In case the TechnicianSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicianScheduleUpdateInput, TechnicianScheduleUncheckedUpdateInput>
  }

  /**
   * TechnicianSchedule delete
   */
  export type TechnicianScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
    /**
     * Filter which TechnicianSchedule to delete.
     */
    where: TechnicianScheduleWhereUniqueInput
  }

  /**
   * TechnicianSchedule deleteMany
   */
  export type TechnicianScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicianSchedules to delete
     */
    where?: TechnicianScheduleWhereInput
  }

  /**
   * TechnicianSchedule without action
   */
  export type TechnicianScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSchedule
     */
    select?: TechnicianScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ServiceStatusHistory
   */

  export type AggregateServiceStatusHistory = {
    _count: ServiceStatusHistoryCountAggregateOutputType | null
    _min: ServiceStatusHistoryMinAggregateOutputType | null
    _max: ServiceStatusHistoryMaxAggregateOutputType | null
  }

  export type ServiceStatusHistoryMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    status: string | null
    newStatus: string | null
    note: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type ServiceStatusHistoryMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    status: string | null
    newStatus: string | null
    note: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type ServiceStatusHistoryCountAggregateOutputType = {
    id: number
    bookingId: number
    status: number
    newStatus: number
    note: number
    changedBy: number
    createdAt: number
    _all: number
  }


  export type ServiceStatusHistoryMinAggregateInputType = {
    id?: true
    bookingId?: true
    status?: true
    newStatus?: true
    note?: true
    changedBy?: true
    createdAt?: true
  }

  export type ServiceStatusHistoryMaxAggregateInputType = {
    id?: true
    bookingId?: true
    status?: true
    newStatus?: true
    note?: true
    changedBy?: true
    createdAt?: true
  }

  export type ServiceStatusHistoryCountAggregateInputType = {
    id?: true
    bookingId?: true
    status?: true
    newStatus?: true
    note?: true
    changedBy?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatusHistory to aggregate.
     */
    where?: ServiceStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?: ServiceStatusHistoryOrderByWithRelationInput | ServiceStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceStatusHistories
    **/
    _count?: true | ServiceStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceStatusHistoryMaxAggregateInputType
  }

  export type GetServiceStatusHistoryAggregateType<T extends ServiceStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceStatusHistory[P]>
      : GetScalarType<T[P], AggregateServiceStatusHistory[P]>
  }




  export type ServiceStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatusHistoryWhereInput
    orderBy?: ServiceStatusHistoryOrderByWithAggregationInput | ServiceStatusHistoryOrderByWithAggregationInput[]
    by: ServiceStatusHistoryScalarFieldEnum[] | ServiceStatusHistoryScalarFieldEnum
    having?: ServiceStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceStatusHistoryCountAggregateInputType | true
    _min?: ServiceStatusHistoryMinAggregateInputType
    _max?: ServiceStatusHistoryMaxAggregateInputType
  }

  export type ServiceStatusHistoryGroupByOutputType = {
    id: string
    bookingId: string
    status: string
    newStatus: string
    note: string | null
    changedBy: string | null
    createdAt: Date
    _count: ServiceStatusHistoryCountAggregateOutputType | null
    _min: ServiceStatusHistoryMinAggregateOutputType | null
    _max: ServiceStatusHistoryMaxAggregateOutputType | null
  }

  type GetServiceStatusHistoryGroupByPayload<T extends ServiceStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    status?: boolean
    newStatus?: boolean
    note?: boolean
    changedBy?: boolean
    createdAt?: boolean
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatusHistory"]>

  export type ServiceStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    status?: boolean
    newStatus?: boolean
    note?: boolean
    changedBy?: boolean
    createdAt?: boolean
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatusHistory"]>

  export type ServiceStatusHistorySelectScalar = {
    id?: boolean
    bookingId?: boolean
    status?: boolean
    newStatus?: boolean
    note?: boolean
    changedBy?: boolean
    createdAt?: boolean
  }

  export type ServiceStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }
  export type ServiceStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }

  export type $ServiceStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceStatusHistory"
    objects: {
      booking: Prisma.$ServiceBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      status: string
      newStatus: string
      note: string | null
      changedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["serviceStatusHistory"]>
    composites: {}
  }

  type ServiceStatusHistoryGetPayload<S extends boolean | null | undefined | ServiceStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceStatusHistoryPayload, S>

  type ServiceStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceStatusHistoryCountAggregateInputType | true
    }

  export interface ServiceStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceStatusHistory'], meta: { name: 'ServiceStatusHistory' } }
    /**
     * Find zero or one ServiceStatusHistory that matches the filter.
     * @param {ServiceStatusHistoryFindUniqueArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceStatusHistoryFindUniqueArgs>(args: SelectSubset<T, ServiceStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceStatusHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryFindFirstArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceStatusHistoryFindFirstArgs>(args?: SelectSubset<T, ServiceStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a ServiceStatusHistory
     * @example
     * // Get one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceStatusHistories
     * const serviceStatusHistories = await prisma.serviceStatusHistory.findMany()
     * 
     * // Get first 10 ServiceStatusHistories
     * const serviceStatusHistories = await prisma.serviceStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceStatusHistoryWithIdOnly = await prisma.serviceStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceStatusHistoryFindManyArgs>(args?: SelectSubset<T, ServiceStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceStatusHistory.
     * @param {ServiceStatusHistoryCreateArgs} args - Arguments to create a ServiceStatusHistory.
     * @example
     * // Create one ServiceStatusHistory
     * const ServiceStatusHistory = await prisma.serviceStatusHistory.create({
     *   data: {
     *     // ... data to create a ServiceStatusHistory
     *   }
     * })
     * 
     */
    create<T extends ServiceStatusHistoryCreateArgs>(args: SelectSubset<T, ServiceStatusHistoryCreateArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceStatusHistories.
     * @param {ServiceStatusHistoryCreateManyArgs} args - Arguments to create many ServiceStatusHistories.
     * @example
     * // Create many ServiceStatusHistories
     * const serviceStatusHistory = await prisma.serviceStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceStatusHistoryCreateManyArgs>(args?: SelectSubset<T, ServiceStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceStatusHistories and returns the data saved in the database.
     * @param {ServiceStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many ServiceStatusHistories.
     * @example
     * // Create many ServiceStatusHistories
     * const serviceStatusHistory = await prisma.serviceStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceStatusHistories and only return the `id`
     * const serviceStatusHistoryWithIdOnly = await prisma.serviceStatusHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceStatusHistory.
     * @param {ServiceStatusHistoryDeleteArgs} args - Arguments to delete one ServiceStatusHistory.
     * @example
     * // Delete one ServiceStatusHistory
     * const ServiceStatusHistory = await prisma.serviceStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one ServiceStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends ServiceStatusHistoryDeleteArgs>(args: SelectSubset<T, ServiceStatusHistoryDeleteArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceStatusHistory.
     * @param {ServiceStatusHistoryUpdateArgs} args - Arguments to update one ServiceStatusHistory.
     * @example
     * // Update one ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceStatusHistoryUpdateArgs>(args: SelectSubset<T, ServiceStatusHistoryUpdateArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceStatusHistories.
     * @param {ServiceStatusHistoryDeleteManyArgs} args - Arguments to filter ServiceStatusHistories to delete.
     * @example
     * // Delete a few ServiceStatusHistories
     * const { count } = await prisma.serviceStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, ServiceStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceStatusHistories
     * const serviceStatusHistory = await prisma.serviceStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceStatusHistoryUpdateManyArgs>(args: SelectSubset<T, ServiceStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceStatusHistory.
     * @param {ServiceStatusHistoryUpsertArgs} args - Arguments to update or create a ServiceStatusHistory.
     * @example
     * // Update or create a ServiceStatusHistory
     * const serviceStatusHistory = await prisma.serviceStatusHistory.upsert({
     *   create: {
     *     // ... data to create a ServiceStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceStatusHistoryUpsertArgs>(args: SelectSubset<T, ServiceStatusHistoryUpsertArgs<ExtArgs>>): Prisma__ServiceStatusHistoryClient<$Result.GetResult<Prisma.$ServiceStatusHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryCountArgs} args - Arguments to filter ServiceStatusHistories to count.
     * @example
     * // Count the number of ServiceStatusHistories
     * const count = await prisma.serviceStatusHistory.count({
     *   where: {
     *     // ... the filter for the ServiceStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends ServiceStatusHistoryCountArgs>(
      args?: Subset<T, ServiceStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceStatusHistoryAggregateArgs>(args: Subset<T, ServiceStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetServiceStatusHistoryAggregateType<T>>

    /**
     * Group by ServiceStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceStatusHistory model
   */
  readonly fields: ServiceStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends ServiceBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBookingDefaultArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceStatusHistory model
   */ 
  interface ServiceStatusHistoryFieldRefs {
    readonly id: FieldRef<"ServiceStatusHistory", 'String'>
    readonly bookingId: FieldRef<"ServiceStatusHistory", 'String'>
    readonly status: FieldRef<"ServiceStatusHistory", 'String'>
    readonly newStatus: FieldRef<"ServiceStatusHistory", 'String'>
    readonly note: FieldRef<"ServiceStatusHistory", 'String'>
    readonly changedBy: FieldRef<"ServiceStatusHistory", 'String'>
    readonly createdAt: FieldRef<"ServiceStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceStatusHistory findUnique
   */
  export type ServiceStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where: ServiceStatusHistoryWhereUniqueInput
  }

  /**
   * ServiceStatusHistory findUniqueOrThrow
   */
  export type ServiceStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where: ServiceStatusHistoryWhereUniqueInput
  }

  /**
   * ServiceStatusHistory findFirst
   */
  export type ServiceStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where?: ServiceStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?: ServiceStatusHistoryOrderByWithRelationInput | ServiceStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatusHistories.
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatusHistories.
     */
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[]
  }

  /**
   * ServiceStatusHistory findFirstOrThrow
   */
  export type ServiceStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatusHistory to fetch.
     */
    where?: ServiceStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?: ServiceStatusHistoryOrderByWithRelationInput | ServiceStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatusHistories.
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatusHistories.
     */
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[]
  }

  /**
   * ServiceStatusHistory findMany
   */
  export type ServiceStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatusHistories to fetch.
     */
    where?: ServiceStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatusHistories to fetch.
     */
    orderBy?: ServiceStatusHistoryOrderByWithRelationInput | ServiceStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceStatusHistories.
     */
    cursor?: ServiceStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatusHistories.
     */
    skip?: number
    distinct?: ServiceStatusHistoryScalarFieldEnum | ServiceStatusHistoryScalarFieldEnum[]
  }

  /**
   * ServiceStatusHistory create
   */
  export type ServiceStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceStatusHistory.
     */
    data: XOR<ServiceStatusHistoryCreateInput, ServiceStatusHistoryUncheckedCreateInput>
  }

  /**
   * ServiceStatusHistory createMany
   */
  export type ServiceStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceStatusHistories.
     */
    data: ServiceStatusHistoryCreateManyInput | ServiceStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceStatusHistory createManyAndReturn
   */
  export type ServiceStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceStatusHistories.
     */
    data: ServiceStatusHistoryCreateManyInput | ServiceStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceStatusHistory update
   */
  export type ServiceStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceStatusHistory.
     */
    data: XOR<ServiceStatusHistoryUpdateInput, ServiceStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceStatusHistory to update.
     */
    where: ServiceStatusHistoryWhereUniqueInput
  }

  /**
   * ServiceStatusHistory updateMany
   */
  export type ServiceStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceStatusHistories.
     */
    data: XOR<ServiceStatusHistoryUpdateManyMutationInput, ServiceStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceStatusHistories to update
     */
    where?: ServiceStatusHistoryWhereInput
  }

  /**
   * ServiceStatusHistory upsert
   */
  export type ServiceStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceStatusHistory to update in case it exists.
     */
    where: ServiceStatusHistoryWhereUniqueInput
    /**
     * In case the ServiceStatusHistory found by the `where` argument doesn't exist, create a new ServiceStatusHistory with this data.
     */
    create: XOR<ServiceStatusHistoryCreateInput, ServiceStatusHistoryUncheckedCreateInput>
    /**
     * In case the ServiceStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceStatusHistoryUpdateInput, ServiceStatusHistoryUncheckedUpdateInput>
  }

  /**
   * ServiceStatusHistory delete
   */
  export type ServiceStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceStatusHistory to delete.
     */
    where: ServiceStatusHistoryWhereUniqueInput
  }

  /**
   * ServiceStatusHistory deleteMany
   */
  export type ServiceStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatusHistories to delete
     */
    where?: ServiceStatusHistoryWhereInput
  }

  /**
   * ServiceStatusHistory without action
   */
  export type ServiceStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusHistory
     */
    select?: ServiceStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ServicePayment
   */

  export type AggregateServicePayment = {
    _count: ServicePaymentCountAggregateOutputType | null
    _avg: ServicePaymentAvgAggregateOutputType | null
    _sum: ServicePaymentSumAggregateOutputType | null
    _min: ServicePaymentMinAggregateOutputType | null
    _max: ServicePaymentMaxAggregateOutputType | null
  }

  export type ServicePaymentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type ServicePaymentSumAggregateOutputType = {
    amountCents: number | null
  }

  export type ServicePaymentMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    provider: string | null
    amountCents: number | null
    status: string | null
    transactionId: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type ServicePaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    provider: string | null
    amountCents: number | null
    status: string | null
    transactionId: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type ServicePaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    provider: number
    amountCents: number
    status: number
    transactionId: number
    paidAt: number
    createdAt: number
    _all: number
  }


  export type ServicePaymentAvgAggregateInputType = {
    amountCents?: true
  }

  export type ServicePaymentSumAggregateInputType = {
    amountCents?: true
  }

  export type ServicePaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    provider?: true
    amountCents?: true
    status?: true
    transactionId?: true
    paidAt?: true
    createdAt?: true
  }

  export type ServicePaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    provider?: true
    amountCents?: true
    status?: true
    transactionId?: true
    paidAt?: true
    createdAt?: true
  }

  export type ServicePaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    provider?: true
    amountCents?: true
    status?: true
    transactionId?: true
    paidAt?: true
    createdAt?: true
    _all?: true
  }

  export type ServicePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePayment to aggregate.
     */
    where?: ServicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePayments to fetch.
     */
    orderBy?: ServicePaymentOrderByWithRelationInput | ServicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePayments
    **/
    _count?: true | ServicePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePaymentMaxAggregateInputType
  }

  export type GetServicePaymentAggregateType<T extends ServicePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePayment[P]>
      : GetScalarType<T[P], AggregateServicePayment[P]>
  }




  export type ServicePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePaymentWhereInput
    orderBy?: ServicePaymentOrderByWithAggregationInput | ServicePaymentOrderByWithAggregationInput[]
    by: ServicePaymentScalarFieldEnum[] | ServicePaymentScalarFieldEnum
    having?: ServicePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePaymentCountAggregateInputType | true
    _avg?: ServicePaymentAvgAggregateInputType
    _sum?: ServicePaymentSumAggregateInputType
    _min?: ServicePaymentMinAggregateInputType
    _max?: ServicePaymentMaxAggregateInputType
  }

  export type ServicePaymentGroupByOutputType = {
    id: string
    bookingId: string
    provider: string
    amountCents: number
    status: string
    transactionId: string | null
    paidAt: Date | null
    createdAt: Date
    _count: ServicePaymentCountAggregateOutputType | null
    _avg: ServicePaymentAvgAggregateOutputType | null
    _sum: ServicePaymentSumAggregateOutputType | null
    _min: ServicePaymentMinAggregateOutputType | null
    _max: ServicePaymentMaxAggregateOutputType | null
  }

  type GetServicePaymentGroupByPayload<T extends ServicePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePaymentGroupByOutputType[P]>
        }
      >
    >


  export type ServicePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    transactionId?: boolean
    paidAt?: boolean
    createdAt?: boolean
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePayment"]>

  export type ServicePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    transactionId?: boolean
    paidAt?: boolean
    createdAt?: boolean
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePayment"]>

  export type ServicePaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    transactionId?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }

  export type ServicePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }
  export type ServicePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ServiceBookingDefaultArgs<ExtArgs>
  }

  export type $ServicePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePayment"
    objects: {
      booking: Prisma.$ServiceBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      provider: string
      amountCents: number
      status: string
      transactionId: string | null
      paidAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["servicePayment"]>
    composites: {}
  }

  type ServicePaymentGetPayload<S extends boolean | null | undefined | ServicePaymentDefaultArgs> = $Result.GetResult<Prisma.$ServicePaymentPayload, S>

  type ServicePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicePaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicePaymentCountAggregateInputType | true
    }

  export interface ServicePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePayment'], meta: { name: 'ServicePayment' } }
    /**
     * Find zero or one ServicePayment that matches the filter.
     * @param {ServicePaymentFindUniqueArgs} args - Arguments to find a ServicePayment
     * @example
     * // Get one ServicePayment
     * const servicePayment = await prisma.servicePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePaymentFindUniqueArgs>(args: SelectSubset<T, ServicePaymentFindUniqueArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServicePayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicePaymentFindUniqueOrThrowArgs} args - Arguments to find a ServicePayment
     * @example
     * // Get one ServicePayment
     * const servicePayment = await prisma.servicePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServicePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePaymentFindFirstArgs} args - Arguments to find a ServicePayment
     * @example
     * // Get one ServicePayment
     * const servicePayment = await prisma.servicePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePaymentFindFirstArgs>(args?: SelectSubset<T, ServicePaymentFindFirstArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServicePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePaymentFindFirstOrThrowArgs} args - Arguments to find a ServicePayment
     * @example
     * // Get one ServicePayment
     * const servicePayment = await prisma.servicePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServicePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePayments
     * const servicePayments = await prisma.servicePayment.findMany()
     * 
     * // Get first 10 ServicePayments
     * const servicePayments = await prisma.servicePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePaymentWithIdOnly = await prisma.servicePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePaymentFindManyArgs>(args?: SelectSubset<T, ServicePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServicePayment.
     * @param {ServicePaymentCreateArgs} args - Arguments to create a ServicePayment.
     * @example
     * // Create one ServicePayment
     * const ServicePayment = await prisma.servicePayment.create({
     *   data: {
     *     // ... data to create a ServicePayment
     *   }
     * })
     * 
     */
    create<T extends ServicePaymentCreateArgs>(args: SelectSubset<T, ServicePaymentCreateArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServicePayments.
     * @param {ServicePaymentCreateManyArgs} args - Arguments to create many ServicePayments.
     * @example
     * // Create many ServicePayments
     * const servicePayment = await prisma.servicePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePaymentCreateManyArgs>(args?: SelectSubset<T, ServicePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicePayments and returns the data saved in the database.
     * @param {ServicePaymentCreateManyAndReturnArgs} args - Arguments to create many ServicePayments.
     * @example
     * // Create many ServicePayments
     * const servicePayment = await prisma.servicePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicePayments and only return the `id`
     * const servicePaymentWithIdOnly = await prisma.servicePayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServicePayment.
     * @param {ServicePaymentDeleteArgs} args - Arguments to delete one ServicePayment.
     * @example
     * // Delete one ServicePayment
     * const ServicePayment = await prisma.servicePayment.delete({
     *   where: {
     *     // ... filter to delete one ServicePayment
     *   }
     * })
     * 
     */
    delete<T extends ServicePaymentDeleteArgs>(args: SelectSubset<T, ServicePaymentDeleteArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServicePayment.
     * @param {ServicePaymentUpdateArgs} args - Arguments to update one ServicePayment.
     * @example
     * // Update one ServicePayment
     * const servicePayment = await prisma.servicePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePaymentUpdateArgs>(args: SelectSubset<T, ServicePaymentUpdateArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServicePayments.
     * @param {ServicePaymentDeleteManyArgs} args - Arguments to filter ServicePayments to delete.
     * @example
     * // Delete a few ServicePayments
     * const { count } = await prisma.servicePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePaymentDeleteManyArgs>(args?: SelectSubset<T, ServicePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePayments
     * const servicePayment = await prisma.servicePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePaymentUpdateManyArgs>(args: SelectSubset<T, ServicePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicePayment.
     * @param {ServicePaymentUpsertArgs} args - Arguments to update or create a ServicePayment.
     * @example
     * // Update or create a ServicePayment
     * const servicePayment = await prisma.servicePayment.upsert({
     *   create: {
     *     // ... data to create a ServicePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePayment we want to update
     *   }
     * })
     */
    upsert<T extends ServicePaymentUpsertArgs>(args: SelectSubset<T, ServicePaymentUpsertArgs<ExtArgs>>): Prisma__ServicePaymentClient<$Result.GetResult<Prisma.$ServicePaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePaymentCountArgs} args - Arguments to filter ServicePayments to count.
     * @example
     * // Count the number of ServicePayments
     * const count = await prisma.servicePayment.count({
     *   where: {
     *     // ... the filter for the ServicePayments we want to count
     *   }
     * })
    **/
    count<T extends ServicePaymentCountArgs>(
      args?: Subset<T, ServicePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePaymentAggregateArgs>(args: Subset<T, ServicePaymentAggregateArgs>): Prisma.PrismaPromise<GetServicePaymentAggregateType<T>>

    /**
     * Group by ServicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePaymentGroupByArgs['orderBy'] }
        : { orderBy?: ServicePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePayment model
   */
  readonly fields: ServicePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends ServiceBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceBookingDefaultArgs<ExtArgs>>): Prisma__ServiceBookingClient<$Result.GetResult<Prisma.$ServiceBookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePayment model
   */ 
  interface ServicePaymentFieldRefs {
    readonly id: FieldRef<"ServicePayment", 'String'>
    readonly bookingId: FieldRef<"ServicePayment", 'String'>
    readonly provider: FieldRef<"ServicePayment", 'String'>
    readonly amountCents: FieldRef<"ServicePayment", 'Int'>
    readonly status: FieldRef<"ServicePayment", 'String'>
    readonly transactionId: FieldRef<"ServicePayment", 'String'>
    readonly paidAt: FieldRef<"ServicePayment", 'DateTime'>
    readonly createdAt: FieldRef<"ServicePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicePayment findUnique
   */
  export type ServicePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which ServicePayment to fetch.
     */
    where: ServicePaymentWhereUniqueInput
  }

  /**
   * ServicePayment findUniqueOrThrow
   */
  export type ServicePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which ServicePayment to fetch.
     */
    where: ServicePaymentWhereUniqueInput
  }

  /**
   * ServicePayment findFirst
   */
  export type ServicePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which ServicePayment to fetch.
     */
    where?: ServicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePayments to fetch.
     */
    orderBy?: ServicePaymentOrderByWithRelationInput | ServicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePayments.
     */
    cursor?: ServicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePayments.
     */
    distinct?: ServicePaymentScalarFieldEnum | ServicePaymentScalarFieldEnum[]
  }

  /**
   * ServicePayment findFirstOrThrow
   */
  export type ServicePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which ServicePayment to fetch.
     */
    where?: ServicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePayments to fetch.
     */
    orderBy?: ServicePaymentOrderByWithRelationInput | ServicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePayments.
     */
    cursor?: ServicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePayments.
     */
    distinct?: ServicePaymentScalarFieldEnum | ServicePaymentScalarFieldEnum[]
  }

  /**
   * ServicePayment findMany
   */
  export type ServicePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which ServicePayments to fetch.
     */
    where?: ServicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePayments to fetch.
     */
    orderBy?: ServicePaymentOrderByWithRelationInput | ServicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePayments.
     */
    cursor?: ServicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePayments.
     */
    skip?: number
    distinct?: ServicePaymentScalarFieldEnum | ServicePaymentScalarFieldEnum[]
  }

  /**
   * ServicePayment create
   */
  export type ServicePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePayment.
     */
    data: XOR<ServicePaymentCreateInput, ServicePaymentUncheckedCreateInput>
  }

  /**
   * ServicePayment createMany
   */
  export type ServicePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePayments.
     */
    data: ServicePaymentCreateManyInput | ServicePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePayment createManyAndReturn
   */
  export type ServicePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServicePayments.
     */
    data: ServicePaymentCreateManyInput | ServicePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePayment update
   */
  export type ServicePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePayment.
     */
    data: XOR<ServicePaymentUpdateInput, ServicePaymentUncheckedUpdateInput>
    /**
     * Choose, which ServicePayment to update.
     */
    where: ServicePaymentWhereUniqueInput
  }

  /**
   * ServicePayment updateMany
   */
  export type ServicePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePayments.
     */
    data: XOR<ServicePaymentUpdateManyMutationInput, ServicePaymentUncheckedUpdateManyInput>
    /**
     * Filter which ServicePayments to update
     */
    where?: ServicePaymentWhereInput
  }

  /**
   * ServicePayment upsert
   */
  export type ServicePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePayment to update in case it exists.
     */
    where: ServicePaymentWhereUniqueInput
    /**
     * In case the ServicePayment found by the `where` argument doesn't exist, create a new ServicePayment with this data.
     */
    create: XOR<ServicePaymentCreateInput, ServicePaymentUncheckedCreateInput>
    /**
     * In case the ServicePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePaymentUpdateInput, ServicePaymentUncheckedUpdateInput>
  }

  /**
   * ServicePayment delete
   */
  export type ServicePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
    /**
     * Filter which ServicePayment to delete.
     */
    where: ServicePaymentWhereUniqueInput
  }

  /**
   * ServicePayment deleteMany
   */
  export type ServicePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePayments to delete
     */
    where?: ServicePaymentWhereInput
  }

  /**
   * ServicePayment without action
   */
  export type ServicePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePayment
     */
    select?: ServicePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePaymentInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    value: number | null
  }

  export type PromotionSumAggregateOutputType = {
    value: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    value: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    value: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    type: number
    value: number
    isActive: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    value?: true
  }

  export type PromotionSumAggregateInputType = {
    value?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    value?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    value?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    value?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    type: string
    value: number
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    value?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }


  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      type: string
      value: number
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */ 
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly code: FieldRef<"Promotion", 'String'>
    readonly name: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly type: FieldRef<"Promotion", 'String'>
    readonly value: FieldRef<"Promotion", 'Int'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly expiresAt: FieldRef<"Promotion", 'DateTime'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    position: number | null
  }

  export type BannerSumAggregateOutputType = {
    position: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    imageUrl: string | null
    mobileImageUrl: string | null
    linkUrl: string | null
    buttonLabel: string | null
    page: string | null
    locale: string | null
    position: number | null
    isActive: boolean | null
    startAt: Date | null
    endAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    imageUrl: string | null
    mobileImageUrl: string | null
    linkUrl: string | null
    buttonLabel: string | null
    page: string | null
    locale: string | null
    position: number | null
    isActive: boolean | null
    startAt: Date | null
    endAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    description: number
    imageUrl: number
    mobileImageUrl: number
    linkUrl: number
    buttonLabel: number
    page: number
    locale: number
    position: number
    isActive: number
    startAt: number
    endAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    position?: true
  }

  export type BannerSumAggregateInputType = {
    position?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    imageUrl?: true
    mobileImageUrl?: true
    linkUrl?: true
    buttonLabel?: true
    page?: true
    locale?: true
    position?: true
    isActive?: true
    startAt?: true
    endAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    imageUrl?: true
    mobileImageUrl?: true
    linkUrl?: true
    buttonLabel?: true
    page?: true
    locale?: true
    position?: true
    isActive?: true
    startAt?: true
    endAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    imageUrl?: true
    mobileImageUrl?: true
    linkUrl?: true
    buttonLabel?: true
    page?: true
    locale?: true
    position?: true
    isActive?: true
    startAt?: true
    endAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    title: string
    subtitle: string | null
    description: string | null
    imageUrl: string
    mobileImageUrl: string | null
    linkUrl: string | null
    buttonLabel: string | null
    page: string
    locale: string | null
    position: number
    isActive: boolean
    startAt: Date | null
    endAt: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    imageUrl?: boolean
    mobileImageUrl?: boolean
    linkUrl?: boolean
    buttonLabel?: boolean
    page?: boolean
    locale?: boolean
    position?: boolean
    isActive?: boolean
    startAt?: boolean
    endAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    imageUrl?: boolean
    mobileImageUrl?: boolean
    linkUrl?: boolean
    buttonLabel?: boolean
    page?: boolean
    locale?: boolean
    position?: boolean
    isActive?: boolean
    startAt?: boolean
    endAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    imageUrl?: boolean
    mobileImageUrl?: boolean
    linkUrl?: boolean
    buttonLabel?: boolean
    page?: boolean
    locale?: boolean
    position?: boolean
    isActive?: boolean
    startAt?: boolean
    endAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string | null
      description: string | null
      imageUrl: string
      mobileImageUrl: string | null
      linkUrl: string | null
      buttonLabel: string | null
      page: string
      locale: string | null
      position: number
      isActive: boolean
      startAt: Date | null
      endAt: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banners and returns the data saved in the database.
     * @param {BannerCreateManyAndReturnArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */ 
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly title: FieldRef<"Banner", 'String'>
    readonly subtitle: FieldRef<"Banner", 'String'>
    readonly description: FieldRef<"Banner", 'String'>
    readonly imageUrl: FieldRef<"Banner", 'String'>
    readonly mobileImageUrl: FieldRef<"Banner", 'String'>
    readonly linkUrl: FieldRef<"Banner", 'String'>
    readonly buttonLabel: FieldRef<"Banner", 'String'>
    readonly page: FieldRef<"Banner", 'String'>
    readonly locale: FieldRef<"Banner", 'String'>
    readonly position: FieldRef<"Banner", 'Int'>
    readonly isActive: FieldRef<"Banner", 'Boolean'>
    readonly startAt: FieldRef<"Banner", 'DateTime'>
    readonly endAt: FieldRef<"Banner", 'DateTime'>
    readonly isDeleted: FieldRef<"Banner", 'Boolean'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner createManyAndReturn
   */
  export type BannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */ 
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly type: FieldRef<"SystemConfig", 'String'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
  }


  /**
   * Model LoyaltyAccount
   */

  export type AggregateLoyaltyAccount = {
    _count: LoyaltyAccountCountAggregateOutputType | null
    _avg: LoyaltyAccountAvgAggregateOutputType | null
    _sum: LoyaltyAccountSumAggregateOutputType | null
    _min: LoyaltyAccountMinAggregateOutputType | null
    _max: LoyaltyAccountMaxAggregateOutputType | null
  }

  export type LoyaltyAccountAvgAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyAccountSumAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    tier: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    tier: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyAccountCountAggregateOutputType = {
    id: number
    userId: number
    points: number
    tier: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyAccountAvgAggregateInputType = {
    points?: true
  }

  export type LoyaltyAccountSumAggregateInputType = {
    points?: true
  }

  export type LoyaltyAccountMinAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    tier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    tier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyAccountCountAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    tier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyAccount to aggregate.
     */
    where?: LoyaltyAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyAccounts to fetch.
     */
    orderBy?: LoyaltyAccountOrderByWithRelationInput | LoyaltyAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyAccounts
    **/
    _count?: true | LoyaltyAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyAccountMaxAggregateInputType
  }

  export type GetLoyaltyAccountAggregateType<T extends LoyaltyAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyAccount[P]>
      : GetScalarType<T[P], AggregateLoyaltyAccount[P]>
  }




  export type LoyaltyAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyAccountWhereInput
    orderBy?: LoyaltyAccountOrderByWithAggregationInput | LoyaltyAccountOrderByWithAggregationInput[]
    by: LoyaltyAccountScalarFieldEnum[] | LoyaltyAccountScalarFieldEnum
    having?: LoyaltyAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyAccountCountAggregateInputType | true
    _avg?: LoyaltyAccountAvgAggregateInputType
    _sum?: LoyaltyAccountSumAggregateInputType
    _min?: LoyaltyAccountMinAggregateInputType
    _max?: LoyaltyAccountMaxAggregateInputType
  }

  export type LoyaltyAccountGroupByOutputType = {
    id: string
    userId: string
    points: number
    tier: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyAccountCountAggregateOutputType | null
    _avg: LoyaltyAccountAvgAggregateOutputType | null
    _sum: LoyaltyAccountSumAggregateOutputType | null
    _min: LoyaltyAccountMinAggregateOutputType | null
    _max: LoyaltyAccountMaxAggregateOutputType | null
  }

  type GetLoyaltyAccountGroupByPayload<T extends LoyaltyAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyAccountGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyAccountGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    points?: boolean
    tier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | LoyaltyAccount$transactionsArgs<ExtArgs>
    redemptions?: boolean | LoyaltyAccount$redemptionsArgs<ExtArgs>
    _count?: boolean | LoyaltyAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyAccount"]>

  export type LoyaltyAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    points?: boolean
    tier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyAccount"]>

  export type LoyaltyAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    points?: boolean
    tier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | LoyaltyAccount$transactionsArgs<ExtArgs>
    redemptions?: boolean | LoyaltyAccount$redemptionsArgs<ExtArgs>
    _count?: boolean | LoyaltyAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoyaltyAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LoyaltyAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$PointTransactionPayload<ExtArgs>[]
      redemptions: Prisma.$RedemptionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      points: number
      tier: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loyaltyAccount"]>
    composites: {}
  }

  type LoyaltyAccountGetPayload<S extends boolean | null | undefined | LoyaltyAccountDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyAccountPayload, S>

  type LoyaltyAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoyaltyAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoyaltyAccountCountAggregateInputType | true
    }

  export interface LoyaltyAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyAccount'], meta: { name: 'LoyaltyAccount' } }
    /**
     * Find zero or one LoyaltyAccount that matches the filter.
     * @param {LoyaltyAccountFindUniqueArgs} args - Arguments to find a LoyaltyAccount
     * @example
     * // Get one LoyaltyAccount
     * const loyaltyAccount = await prisma.loyaltyAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyAccountFindUniqueArgs>(args: SelectSubset<T, LoyaltyAccountFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoyaltyAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoyaltyAccountFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyAccount
     * @example
     * // Get one LoyaltyAccount
     * const loyaltyAccount = await prisma.loyaltyAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoyaltyAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyAccountFindFirstArgs} args - Arguments to find a LoyaltyAccount
     * @example
     * // Get one LoyaltyAccount
     * const loyaltyAccount = await prisma.loyaltyAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyAccountFindFirstArgs>(args?: SelectSubset<T, LoyaltyAccountFindFirstArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoyaltyAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyAccountFindFirstOrThrowArgs} args - Arguments to find a LoyaltyAccount
     * @example
     * // Get one LoyaltyAccount
     * const loyaltyAccount = await prisma.loyaltyAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoyaltyAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyAccounts
     * const loyaltyAccounts = await prisma.loyaltyAccount.findMany()
     * 
     * // Get first 10 LoyaltyAccounts
     * const loyaltyAccounts = await prisma.loyaltyAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyAccountWithIdOnly = await prisma.loyaltyAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyAccountFindManyArgs>(args?: SelectSubset<T, LoyaltyAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoyaltyAccount.
     * @param {LoyaltyAccountCreateArgs} args - Arguments to create a LoyaltyAccount.
     * @example
     * // Create one LoyaltyAccount
     * const LoyaltyAccount = await prisma.loyaltyAccount.create({
     *   data: {
     *     // ... data to create a LoyaltyAccount
     *   }
     * })
     * 
     */
    create<T extends LoyaltyAccountCreateArgs>(args: SelectSubset<T, LoyaltyAccountCreateArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoyaltyAccounts.
     * @param {LoyaltyAccountCreateManyArgs} args - Arguments to create many LoyaltyAccounts.
     * @example
     * // Create many LoyaltyAccounts
     * const loyaltyAccount = await prisma.loyaltyAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyAccountCreateManyArgs>(args?: SelectSubset<T, LoyaltyAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyAccounts and returns the data saved in the database.
     * @param {LoyaltyAccountCreateManyAndReturnArgs} args - Arguments to create many LoyaltyAccounts.
     * @example
     * // Create many LoyaltyAccounts
     * const loyaltyAccount = await prisma.loyaltyAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyAccounts and only return the `id`
     * const loyaltyAccountWithIdOnly = await prisma.loyaltyAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoyaltyAccount.
     * @param {LoyaltyAccountDeleteArgs} args - Arguments to delete one LoyaltyAccount.
     * @example
     * // Delete one LoyaltyAccount
     * const LoyaltyAccount = await prisma.loyaltyAccount.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyAccount
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyAccountDeleteArgs>(args: SelectSubset<T, LoyaltyAccountDeleteArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoyaltyAccount.
     * @param {LoyaltyAccountUpdateArgs} args - Arguments to update one LoyaltyAccount.
     * @example
     * // Update one LoyaltyAccount
     * const loyaltyAccount = await prisma.loyaltyAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyAccountUpdateArgs>(args: SelectSubset<T, LoyaltyAccountUpdateArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoyaltyAccounts.
     * @param {LoyaltyAccountDeleteManyArgs} args - Arguments to filter LoyaltyAccounts to delete.
     * @example
     * // Delete a few LoyaltyAccounts
     * const { count } = await prisma.loyaltyAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyAccountDeleteManyArgs>(args?: SelectSubset<T, LoyaltyAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyAccounts
     * const loyaltyAccount = await prisma.loyaltyAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyAccountUpdateManyArgs>(args: SelectSubset<T, LoyaltyAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoyaltyAccount.
     * @param {LoyaltyAccountUpsertArgs} args - Arguments to update or create a LoyaltyAccount.
     * @example
     * // Update or create a LoyaltyAccount
     * const loyaltyAccount = await prisma.loyaltyAccount.upsert({
     *   create: {
     *     // ... data to create a LoyaltyAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyAccount we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyAccountUpsertArgs>(args: SelectSubset<T, LoyaltyAccountUpsertArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoyaltyAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyAccountCountArgs} args - Arguments to filter LoyaltyAccounts to count.
     * @example
     * // Count the number of LoyaltyAccounts
     * const count = await prisma.loyaltyAccount.count({
     *   where: {
     *     // ... the filter for the LoyaltyAccounts we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyAccountCountArgs>(
      args?: Subset<T, LoyaltyAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyAccountAggregateArgs>(args: Subset<T, LoyaltyAccountAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyAccountAggregateType<T>>

    /**
     * Group by LoyaltyAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyAccountGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyAccount model
   */
  readonly fields: LoyaltyAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends LoyaltyAccount$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyAccount$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    redemptions<T extends LoyaltyAccount$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyAccount$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyAccount model
   */ 
  interface LoyaltyAccountFieldRefs {
    readonly id: FieldRef<"LoyaltyAccount", 'String'>
    readonly userId: FieldRef<"LoyaltyAccount", 'String'>
    readonly points: FieldRef<"LoyaltyAccount", 'Int'>
    readonly tier: FieldRef<"LoyaltyAccount", 'String'>
    readonly isActive: FieldRef<"LoyaltyAccount", 'Boolean'>
    readonly createdAt: FieldRef<"LoyaltyAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"LoyaltyAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyAccount findUnique
   */
  export type LoyaltyAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyAccount to fetch.
     */
    where: LoyaltyAccountWhereUniqueInput
  }

  /**
   * LoyaltyAccount findUniqueOrThrow
   */
  export type LoyaltyAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyAccount to fetch.
     */
    where: LoyaltyAccountWhereUniqueInput
  }

  /**
   * LoyaltyAccount findFirst
   */
  export type LoyaltyAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyAccount to fetch.
     */
    where?: LoyaltyAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyAccounts to fetch.
     */
    orderBy?: LoyaltyAccountOrderByWithRelationInput | LoyaltyAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyAccounts.
     */
    cursor?: LoyaltyAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyAccounts.
     */
    distinct?: LoyaltyAccountScalarFieldEnum | LoyaltyAccountScalarFieldEnum[]
  }

  /**
   * LoyaltyAccount findFirstOrThrow
   */
  export type LoyaltyAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyAccount to fetch.
     */
    where?: LoyaltyAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyAccounts to fetch.
     */
    orderBy?: LoyaltyAccountOrderByWithRelationInput | LoyaltyAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyAccounts.
     */
    cursor?: LoyaltyAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyAccounts.
     */
    distinct?: LoyaltyAccountScalarFieldEnum | LoyaltyAccountScalarFieldEnum[]
  }

  /**
   * LoyaltyAccount findMany
   */
  export type LoyaltyAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyAccounts to fetch.
     */
    where?: LoyaltyAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyAccounts to fetch.
     */
    orderBy?: LoyaltyAccountOrderByWithRelationInput | LoyaltyAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyAccounts.
     */
    cursor?: LoyaltyAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyAccounts.
     */
    skip?: number
    distinct?: LoyaltyAccountScalarFieldEnum | LoyaltyAccountScalarFieldEnum[]
  }

  /**
   * LoyaltyAccount create
   */
  export type LoyaltyAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyAccount.
     */
    data: XOR<LoyaltyAccountCreateInput, LoyaltyAccountUncheckedCreateInput>
  }

  /**
   * LoyaltyAccount createMany
   */
  export type LoyaltyAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyAccounts.
     */
    data: LoyaltyAccountCreateManyInput | LoyaltyAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyAccount createManyAndReturn
   */
  export type LoyaltyAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoyaltyAccounts.
     */
    data: LoyaltyAccountCreateManyInput | LoyaltyAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyAccount update
   */
  export type LoyaltyAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyAccount.
     */
    data: XOR<LoyaltyAccountUpdateInput, LoyaltyAccountUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyAccount to update.
     */
    where: LoyaltyAccountWhereUniqueInput
  }

  /**
   * LoyaltyAccount updateMany
   */
  export type LoyaltyAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyAccounts.
     */
    data: XOR<LoyaltyAccountUpdateManyMutationInput, LoyaltyAccountUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyAccounts to update
     */
    where?: LoyaltyAccountWhereInput
  }

  /**
   * LoyaltyAccount upsert
   */
  export type LoyaltyAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyAccount to update in case it exists.
     */
    where: LoyaltyAccountWhereUniqueInput
    /**
     * In case the LoyaltyAccount found by the `where` argument doesn't exist, create a new LoyaltyAccount with this data.
     */
    create: XOR<LoyaltyAccountCreateInput, LoyaltyAccountUncheckedCreateInput>
    /**
     * In case the LoyaltyAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyAccountUpdateInput, LoyaltyAccountUncheckedUpdateInput>
  }

  /**
   * LoyaltyAccount delete
   */
  export type LoyaltyAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyAccount to delete.
     */
    where: LoyaltyAccountWhereUniqueInput
  }

  /**
   * LoyaltyAccount deleteMany
   */
  export type LoyaltyAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyAccounts to delete
     */
    where?: LoyaltyAccountWhereInput
  }

  /**
   * LoyaltyAccount.transactions
   */
  export type LoyaltyAccount$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    cursor?: PointTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyAccount.redemptions
   */
  export type LoyaltyAccount$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    where?: RedemptionHistoryWhereInput
    orderBy?: RedemptionHistoryOrderByWithRelationInput | RedemptionHistoryOrderByWithRelationInput[]
    cursor?: RedemptionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedemptionHistoryScalarFieldEnum | RedemptionHistoryScalarFieldEnum[]
  }

  /**
   * LoyaltyAccount without action
   */
  export type LoyaltyAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyAccount
     */
    select?: LoyaltyAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyAccountInclude<ExtArgs> | null
  }


  /**
   * Model PointTransaction
   */

  export type AggregatePointTransaction = {
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  export type PointTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type PointTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type PointTransactionMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    amount: number | null
    type: string | null
    description: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PointTransactionMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    amount: number | null
    type: string | null
    description: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PointTransactionCountAggregateOutputType = {
    id: number
    accountId: number
    amount: number
    type: number
    description: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PointTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type PointTransactionSumAggregateInputType = {
    amount?: true
  }

  export type PointTransactionMinAggregateInputType = {
    id?: true
    accountId?: true
    amount?: true
    type?: true
    description?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PointTransactionMaxAggregateInputType = {
    id?: true
    accountId?: true
    amount?: true
    type?: true
    description?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PointTransactionCountAggregateInputType = {
    id?: true
    accountId?: true
    amount?: true
    type?: true
    description?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PointTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransaction to aggregate.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointTransactions
    **/
    _count?: true | PointTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointTransactionMaxAggregateInputType
  }

  export type GetPointTransactionAggregateType<T extends PointTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePointTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointTransaction[P]>
      : GetScalarType<T[P], AggregatePointTransaction[P]>
  }




  export type PointTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithAggregationInput | PointTransactionOrderByWithAggregationInput[]
    by: PointTransactionScalarFieldEnum[] | PointTransactionScalarFieldEnum
    having?: PointTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointTransactionCountAggregateInputType | true
    _avg?: PointTransactionAvgAggregateInputType
    _sum?: PointTransactionSumAggregateInputType
    _min?: PointTransactionMinAggregateInputType
    _max?: PointTransactionMaxAggregateInputType
  }

  export type PointTransactionGroupByOutputType = {
    id: string
    accountId: string
    amount: number
    type: string
    description: string | null
    expiresAt: Date | null
    createdAt: Date
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  type GetPointTransactionGroupByPayload<T extends PointTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PointTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectScalar = {
    id?: boolean
    accountId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type PointTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
  }
  export type PointTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
  }

  export type $PointTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointTransaction"
    objects: {
      account: Prisma.$LoyaltyAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      amount: number
      type: string
      description: string | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["pointTransaction"]>
    composites: {}
  }

  type PointTransactionGetPayload<S extends boolean | null | undefined | PointTransactionDefaultArgs> = $Result.GetResult<Prisma.$PointTransactionPayload, S>

  type PointTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PointTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PointTransactionCountAggregateInputType | true
    }

  export interface PointTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointTransaction'], meta: { name: 'PointTransaction' } }
    /**
     * Find zero or one PointTransaction that matches the filter.
     * @param {PointTransactionFindUniqueArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointTransactionFindUniqueArgs>(args: SelectSubset<T, PointTransactionFindUniqueArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PointTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PointTransactionFindUniqueOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PointTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PointTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointTransactionFindFirstArgs>(args?: SelectSubset<T, PointTransactionFindFirstArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PointTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PointTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PointTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany()
     * 
     * // Get first 10 PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointTransactionFindManyArgs>(args?: SelectSubset<T, PointTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PointTransaction.
     * @param {PointTransactionCreateArgs} args - Arguments to create a PointTransaction.
     * @example
     * // Create one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.create({
     *   data: {
     *     // ... data to create a PointTransaction
     *   }
     * })
     * 
     */
    create<T extends PointTransactionCreateArgs>(args: SelectSubset<T, PointTransactionCreateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PointTransactions.
     * @param {PointTransactionCreateManyArgs} args - Arguments to create many PointTransactions.
     * @example
     * // Create many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointTransactionCreateManyArgs>(args?: SelectSubset<T, PointTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointTransactions and returns the data saved in the database.
     * @param {PointTransactionCreateManyAndReturnArgs} args - Arguments to create many PointTransactions.
     * @example
     * // Create many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointTransactions and only return the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PointTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PointTransaction.
     * @param {PointTransactionDeleteArgs} args - Arguments to delete one PointTransaction.
     * @example
     * // Delete one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.delete({
     *   where: {
     *     // ... filter to delete one PointTransaction
     *   }
     * })
     * 
     */
    delete<T extends PointTransactionDeleteArgs>(args: SelectSubset<T, PointTransactionDeleteArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PointTransaction.
     * @param {PointTransactionUpdateArgs} args - Arguments to update one PointTransaction.
     * @example
     * // Update one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointTransactionUpdateArgs>(args: SelectSubset<T, PointTransactionUpdateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PointTransactions.
     * @param {PointTransactionDeleteManyArgs} args - Arguments to filter PointTransactions to delete.
     * @example
     * // Delete a few PointTransactions
     * const { count } = await prisma.pointTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointTransactionDeleteManyArgs>(args?: SelectSubset<T, PointTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointTransactionUpdateManyArgs>(args: SelectSubset<T, PointTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointTransaction.
     * @param {PointTransactionUpsertArgs} args - Arguments to update or create a PointTransaction.
     * @example
     * // Update or create a PointTransaction
     * const pointTransaction = await prisma.pointTransaction.upsert({
     *   create: {
     *     // ... data to create a PointTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PointTransactionUpsertArgs>(args: SelectSubset<T, PointTransactionUpsertArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionCountArgs} args - Arguments to filter PointTransactions to count.
     * @example
     * // Count the number of PointTransactions
     * const count = await prisma.pointTransaction.count({
     *   where: {
     *     // ... the filter for the PointTransactions we want to count
     *   }
     * })
    **/
    count<T extends PointTransactionCountArgs>(
      args?: Subset<T, PointTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointTransactionAggregateArgs>(args: Subset<T, PointTransactionAggregateArgs>): Prisma.PrismaPromise<GetPointTransactionAggregateType<T>>

    /**
     * Group by PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PointTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointTransaction model
   */
  readonly fields: PointTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends LoyaltyAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyAccountDefaultArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointTransaction model
   */ 
  interface PointTransactionFieldRefs {
    readonly id: FieldRef<"PointTransaction", 'String'>
    readonly accountId: FieldRef<"PointTransaction", 'String'>
    readonly amount: FieldRef<"PointTransaction", 'Int'>
    readonly type: FieldRef<"PointTransaction", 'String'>
    readonly description: FieldRef<"PointTransaction", 'String'>
    readonly expiresAt: FieldRef<"PointTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"PointTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointTransaction findUnique
   */
  export type PointTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findUniqueOrThrow
   */
  export type PointTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findFirst
   */
  export type PointTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findFirstOrThrow
   */
  export type PointTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findMany
   */
  export type PointTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransactions to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction create
   */
  export type PointTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PointTransaction.
     */
    data: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
  }

  /**
   * PointTransaction createMany
   */
  export type PointTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointTransactions.
     */
    data: PointTransactionCreateManyInput | PointTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointTransaction createManyAndReturn
   */
  export type PointTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PointTransactions.
     */
    data: PointTransactionCreateManyInput | PointTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointTransaction update
   */
  export type PointTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PointTransaction.
     */
    data: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
    /**
     * Choose, which PointTransaction to update.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction updateMany
   */
  export type PointTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointTransactions.
     */
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PointTransactions to update
     */
    where?: PointTransactionWhereInput
  }

  /**
   * PointTransaction upsert
   */
  export type PointTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PointTransaction to update in case it exists.
     */
    where: PointTransactionWhereUniqueInput
    /**
     * In case the PointTransaction found by the `where` argument doesn't exist, create a new PointTransaction with this data.
     */
    create: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
    /**
     * In case the PointTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
  }

  /**
   * PointTransaction delete
   */
  export type PointTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter which PointTransaction to delete.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction deleteMany
   */
  export type PointTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransactions to delete
     */
    where?: PointTransactionWhereInput
  }

  /**
   * PointTransaction without action
   */
  export type PointTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
  }


  /**
   * Model RedemptionHistory
   */

  export type AggregateRedemptionHistory = {
    _count: RedemptionHistoryCountAggregateOutputType | null
    _avg: RedemptionHistoryAvgAggregateOutputType | null
    _sum: RedemptionHistorySumAggregateOutputType | null
    _min: RedemptionHistoryMinAggregateOutputType | null
    _max: RedemptionHistoryMaxAggregateOutputType | null
  }

  export type RedemptionHistoryAvgAggregateOutputType = {
    pointsUsed: number | null
  }

  export type RedemptionHistorySumAggregateOutputType = {
    pointsUsed: number | null
  }

  export type RedemptionHistoryMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    rewardId: string | null
    pointsUsed: number | null
    status: string | null
    createdAt: Date | null
  }

  export type RedemptionHistoryMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    rewardId: string | null
    pointsUsed: number | null
    status: string | null
    createdAt: Date | null
  }

  export type RedemptionHistoryCountAggregateOutputType = {
    id: number
    accountId: number
    rewardId: number
    pointsUsed: number
    status: number
    createdAt: number
    _all: number
  }


  export type RedemptionHistoryAvgAggregateInputType = {
    pointsUsed?: true
  }

  export type RedemptionHistorySumAggregateInputType = {
    pointsUsed?: true
  }

  export type RedemptionHistoryMinAggregateInputType = {
    id?: true
    accountId?: true
    rewardId?: true
    pointsUsed?: true
    status?: true
    createdAt?: true
  }

  export type RedemptionHistoryMaxAggregateInputType = {
    id?: true
    accountId?: true
    rewardId?: true
    pointsUsed?: true
    status?: true
    createdAt?: true
  }

  export type RedemptionHistoryCountAggregateInputType = {
    id?: true
    accountId?: true
    rewardId?: true
    pointsUsed?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type RedemptionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedemptionHistory to aggregate.
     */
    where?: RedemptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedemptionHistories to fetch.
     */
    orderBy?: RedemptionHistoryOrderByWithRelationInput | RedemptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedemptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedemptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedemptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RedemptionHistories
    **/
    _count?: true | RedemptionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedemptionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedemptionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedemptionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedemptionHistoryMaxAggregateInputType
  }

  export type GetRedemptionHistoryAggregateType<T extends RedemptionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRedemptionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedemptionHistory[P]>
      : GetScalarType<T[P], AggregateRedemptionHistory[P]>
  }




  export type RedemptionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedemptionHistoryWhereInput
    orderBy?: RedemptionHistoryOrderByWithAggregationInput | RedemptionHistoryOrderByWithAggregationInput[]
    by: RedemptionHistoryScalarFieldEnum[] | RedemptionHistoryScalarFieldEnum
    having?: RedemptionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedemptionHistoryCountAggregateInputType | true
    _avg?: RedemptionHistoryAvgAggregateInputType
    _sum?: RedemptionHistorySumAggregateInputType
    _min?: RedemptionHistoryMinAggregateInputType
    _max?: RedemptionHistoryMaxAggregateInputType
  }

  export type RedemptionHistoryGroupByOutputType = {
    id: string
    accountId: string
    rewardId: string
    pointsUsed: number
    status: string
    createdAt: Date
    _count: RedemptionHistoryCountAggregateOutputType | null
    _avg: RedemptionHistoryAvgAggregateOutputType | null
    _sum: RedemptionHistorySumAggregateOutputType | null
    _min: RedemptionHistoryMinAggregateOutputType | null
    _max: RedemptionHistoryMaxAggregateOutputType | null
  }

  type GetRedemptionHistoryGroupByPayload<T extends RedemptionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedemptionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedemptionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedemptionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RedemptionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RedemptionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    rewardId?: boolean
    pointsUsed?: boolean
    status?: boolean
    createdAt?: boolean
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
    reward?: boolean | LoyaltyRewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redemptionHistory"]>

  export type RedemptionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    rewardId?: boolean
    pointsUsed?: boolean
    status?: boolean
    createdAt?: boolean
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
    reward?: boolean | LoyaltyRewardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redemptionHistory"]>

  export type RedemptionHistorySelectScalar = {
    id?: boolean
    accountId?: boolean
    rewardId?: boolean
    pointsUsed?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type RedemptionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
    reward?: boolean | LoyaltyRewardDefaultArgs<ExtArgs>
  }
  export type RedemptionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | LoyaltyAccountDefaultArgs<ExtArgs>
    reward?: boolean | LoyaltyRewardDefaultArgs<ExtArgs>
  }

  export type $RedemptionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RedemptionHistory"
    objects: {
      account: Prisma.$LoyaltyAccountPayload<ExtArgs>
      reward: Prisma.$LoyaltyRewardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      rewardId: string
      pointsUsed: number
      status: string
      createdAt: Date
    }, ExtArgs["result"]["redemptionHistory"]>
    composites: {}
  }

  type RedemptionHistoryGetPayload<S extends boolean | null | undefined | RedemptionHistoryDefaultArgs> = $Result.GetResult<Prisma.$RedemptionHistoryPayload, S>

  type RedemptionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RedemptionHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RedemptionHistoryCountAggregateInputType | true
    }

  export interface RedemptionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RedemptionHistory'], meta: { name: 'RedemptionHistory' } }
    /**
     * Find zero or one RedemptionHistory that matches the filter.
     * @param {RedemptionHistoryFindUniqueArgs} args - Arguments to find a RedemptionHistory
     * @example
     * // Get one RedemptionHistory
     * const redemptionHistory = await prisma.redemptionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedemptionHistoryFindUniqueArgs>(args: SelectSubset<T, RedemptionHistoryFindUniqueArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RedemptionHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RedemptionHistoryFindUniqueOrThrowArgs} args - Arguments to find a RedemptionHistory
     * @example
     * // Get one RedemptionHistory
     * const redemptionHistory = await prisma.redemptionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedemptionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RedemptionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RedemptionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionHistoryFindFirstArgs} args - Arguments to find a RedemptionHistory
     * @example
     * // Get one RedemptionHistory
     * const redemptionHistory = await prisma.redemptionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedemptionHistoryFindFirstArgs>(args?: SelectSubset<T, RedemptionHistoryFindFirstArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RedemptionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionHistoryFindFirstOrThrowArgs} args - Arguments to find a RedemptionHistory
     * @example
     * // Get one RedemptionHistory
     * const redemptionHistory = await prisma.redemptionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedemptionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RedemptionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RedemptionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RedemptionHistories
     * const redemptionHistories = await prisma.redemptionHistory.findMany()
     * 
     * // Get first 10 RedemptionHistories
     * const redemptionHistories = await prisma.redemptionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redemptionHistoryWithIdOnly = await prisma.redemptionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedemptionHistoryFindManyArgs>(args?: SelectSubset<T, RedemptionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RedemptionHistory.
     * @param {RedemptionHistoryCreateArgs} args - Arguments to create a RedemptionHistory.
     * @example
     * // Create one RedemptionHistory
     * const RedemptionHistory = await prisma.redemptionHistory.create({
     *   data: {
     *     // ... data to create a RedemptionHistory
     *   }
     * })
     * 
     */
    create<T extends RedemptionHistoryCreateArgs>(args: SelectSubset<T, RedemptionHistoryCreateArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RedemptionHistories.
     * @param {RedemptionHistoryCreateManyArgs} args - Arguments to create many RedemptionHistories.
     * @example
     * // Create many RedemptionHistories
     * const redemptionHistory = await prisma.redemptionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedemptionHistoryCreateManyArgs>(args?: SelectSubset<T, RedemptionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RedemptionHistories and returns the data saved in the database.
     * @param {RedemptionHistoryCreateManyAndReturnArgs} args - Arguments to create many RedemptionHistories.
     * @example
     * // Create many RedemptionHistories
     * const redemptionHistory = await prisma.redemptionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RedemptionHistories and only return the `id`
     * const redemptionHistoryWithIdOnly = await prisma.redemptionHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedemptionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RedemptionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RedemptionHistory.
     * @param {RedemptionHistoryDeleteArgs} args - Arguments to delete one RedemptionHistory.
     * @example
     * // Delete one RedemptionHistory
     * const RedemptionHistory = await prisma.redemptionHistory.delete({
     *   where: {
     *     // ... filter to delete one RedemptionHistory
     *   }
     * })
     * 
     */
    delete<T extends RedemptionHistoryDeleteArgs>(args: SelectSubset<T, RedemptionHistoryDeleteArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RedemptionHistory.
     * @param {RedemptionHistoryUpdateArgs} args - Arguments to update one RedemptionHistory.
     * @example
     * // Update one RedemptionHistory
     * const redemptionHistory = await prisma.redemptionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedemptionHistoryUpdateArgs>(args: SelectSubset<T, RedemptionHistoryUpdateArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RedemptionHistories.
     * @param {RedemptionHistoryDeleteManyArgs} args - Arguments to filter RedemptionHistories to delete.
     * @example
     * // Delete a few RedemptionHistories
     * const { count } = await prisma.redemptionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedemptionHistoryDeleteManyArgs>(args?: SelectSubset<T, RedemptionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedemptionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RedemptionHistories
     * const redemptionHistory = await prisma.redemptionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedemptionHistoryUpdateManyArgs>(args: SelectSubset<T, RedemptionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RedemptionHistory.
     * @param {RedemptionHistoryUpsertArgs} args - Arguments to update or create a RedemptionHistory.
     * @example
     * // Update or create a RedemptionHistory
     * const redemptionHistory = await prisma.redemptionHistory.upsert({
     *   create: {
     *     // ... data to create a RedemptionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RedemptionHistory we want to update
     *   }
     * })
     */
    upsert<T extends RedemptionHistoryUpsertArgs>(args: SelectSubset<T, RedemptionHistoryUpsertArgs<ExtArgs>>): Prisma__RedemptionHistoryClient<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RedemptionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionHistoryCountArgs} args - Arguments to filter RedemptionHistories to count.
     * @example
     * // Count the number of RedemptionHistories
     * const count = await prisma.redemptionHistory.count({
     *   where: {
     *     // ... the filter for the RedemptionHistories we want to count
     *   }
     * })
    **/
    count<T extends RedemptionHistoryCountArgs>(
      args?: Subset<T, RedemptionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedemptionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RedemptionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedemptionHistoryAggregateArgs>(args: Subset<T, RedemptionHistoryAggregateArgs>): Prisma.PrismaPromise<GetRedemptionHistoryAggregateType<T>>

    /**
     * Group by RedemptionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedemptionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedemptionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedemptionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RedemptionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedemptionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedemptionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RedemptionHistory model
   */
  readonly fields: RedemptionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RedemptionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedemptionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends LoyaltyAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyAccountDefaultArgs<ExtArgs>>): Prisma__LoyaltyAccountClient<$Result.GetResult<Prisma.$LoyaltyAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reward<T extends LoyaltyRewardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyRewardDefaultArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RedemptionHistory model
   */ 
  interface RedemptionHistoryFieldRefs {
    readonly id: FieldRef<"RedemptionHistory", 'String'>
    readonly accountId: FieldRef<"RedemptionHistory", 'String'>
    readonly rewardId: FieldRef<"RedemptionHistory", 'String'>
    readonly pointsUsed: FieldRef<"RedemptionHistory", 'Int'>
    readonly status: FieldRef<"RedemptionHistory", 'String'>
    readonly createdAt: FieldRef<"RedemptionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RedemptionHistory findUnique
   */
  export type RedemptionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RedemptionHistory to fetch.
     */
    where: RedemptionHistoryWhereUniqueInput
  }

  /**
   * RedemptionHistory findUniqueOrThrow
   */
  export type RedemptionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RedemptionHistory to fetch.
     */
    where: RedemptionHistoryWhereUniqueInput
  }

  /**
   * RedemptionHistory findFirst
   */
  export type RedemptionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RedemptionHistory to fetch.
     */
    where?: RedemptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedemptionHistories to fetch.
     */
    orderBy?: RedemptionHistoryOrderByWithRelationInput | RedemptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedemptionHistories.
     */
    cursor?: RedemptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedemptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedemptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedemptionHistories.
     */
    distinct?: RedemptionHistoryScalarFieldEnum | RedemptionHistoryScalarFieldEnum[]
  }

  /**
   * RedemptionHistory findFirstOrThrow
   */
  export type RedemptionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RedemptionHistory to fetch.
     */
    where?: RedemptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedemptionHistories to fetch.
     */
    orderBy?: RedemptionHistoryOrderByWithRelationInput | RedemptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedemptionHistories.
     */
    cursor?: RedemptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedemptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedemptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedemptionHistories.
     */
    distinct?: RedemptionHistoryScalarFieldEnum | RedemptionHistoryScalarFieldEnum[]
  }

  /**
   * RedemptionHistory findMany
   */
  export type RedemptionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RedemptionHistories to fetch.
     */
    where?: RedemptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedemptionHistories to fetch.
     */
    orderBy?: RedemptionHistoryOrderByWithRelationInput | RedemptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RedemptionHistories.
     */
    cursor?: RedemptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedemptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedemptionHistories.
     */
    skip?: number
    distinct?: RedemptionHistoryScalarFieldEnum | RedemptionHistoryScalarFieldEnum[]
  }

  /**
   * RedemptionHistory create
   */
  export type RedemptionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RedemptionHistory.
     */
    data: XOR<RedemptionHistoryCreateInput, RedemptionHistoryUncheckedCreateInput>
  }

  /**
   * RedemptionHistory createMany
   */
  export type RedemptionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RedemptionHistories.
     */
    data: RedemptionHistoryCreateManyInput | RedemptionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedemptionHistory createManyAndReturn
   */
  export type RedemptionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RedemptionHistories.
     */
    data: RedemptionHistoryCreateManyInput | RedemptionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedemptionHistory update
   */
  export type RedemptionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RedemptionHistory.
     */
    data: XOR<RedemptionHistoryUpdateInput, RedemptionHistoryUncheckedUpdateInput>
    /**
     * Choose, which RedemptionHistory to update.
     */
    where: RedemptionHistoryWhereUniqueInput
  }

  /**
   * RedemptionHistory updateMany
   */
  export type RedemptionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RedemptionHistories.
     */
    data: XOR<RedemptionHistoryUpdateManyMutationInput, RedemptionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RedemptionHistories to update
     */
    where?: RedemptionHistoryWhereInput
  }

  /**
   * RedemptionHistory upsert
   */
  export type RedemptionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RedemptionHistory to update in case it exists.
     */
    where: RedemptionHistoryWhereUniqueInput
    /**
     * In case the RedemptionHistory found by the `where` argument doesn't exist, create a new RedemptionHistory with this data.
     */
    create: XOR<RedemptionHistoryCreateInput, RedemptionHistoryUncheckedCreateInput>
    /**
     * In case the RedemptionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedemptionHistoryUpdateInput, RedemptionHistoryUncheckedUpdateInput>
  }

  /**
   * RedemptionHistory delete
   */
  export type RedemptionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    /**
     * Filter which RedemptionHistory to delete.
     */
    where: RedemptionHistoryWhereUniqueInput
  }

  /**
   * RedemptionHistory deleteMany
   */
  export type RedemptionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedemptionHistories to delete
     */
    where?: RedemptionHistoryWhereInput
  }

  /**
   * RedemptionHistory without action
   */
  export type RedemptionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyReward
   */

  export type AggregateLoyaltyReward = {
    _count: LoyaltyRewardCountAggregateOutputType | null
    _avg: LoyaltyRewardAvgAggregateOutputType | null
    _sum: LoyaltyRewardSumAggregateOutputType | null
    _min: LoyaltyRewardMinAggregateOutputType | null
    _max: LoyaltyRewardMaxAggregateOutputType | null
  }

  export type LoyaltyRewardAvgAggregateOutputType = {
    pointsCost: number | null
    value: number | null
  }

  export type LoyaltyRewardSumAggregateOutputType = {
    pointsCost: number | null
    value: number | null
  }

  export type LoyaltyRewardMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsCost: number | null
    value: number | null
    type: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type LoyaltyRewardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsCost: number | null
    value: number | null
    type: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type LoyaltyRewardCountAggregateOutputType = {
    id: number
    name: number
    description: number
    pointsCost: number
    value: number
    type: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type LoyaltyRewardAvgAggregateInputType = {
    pointsCost?: true
    value?: true
  }

  export type LoyaltyRewardSumAggregateInputType = {
    pointsCost?: true
    value?: true
  }

  export type LoyaltyRewardMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsCost?: true
    value?: true
    type?: true
    isActive?: true
    createdAt?: true
  }

  export type LoyaltyRewardMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsCost?: true
    value?: true
    type?: true
    isActive?: true
    createdAt?: true
  }

  export type LoyaltyRewardCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsCost?: true
    value?: true
    type?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type LoyaltyRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyReward to aggregate.
     */
    where?: LoyaltyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyRewards to fetch.
     */
    orderBy?: LoyaltyRewardOrderByWithRelationInput | LoyaltyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyRewards
    **/
    _count?: true | LoyaltyRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyRewardMaxAggregateInputType
  }

  export type GetLoyaltyRewardAggregateType<T extends LoyaltyRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyReward[P]>
      : GetScalarType<T[P], AggregateLoyaltyReward[P]>
  }




  export type LoyaltyRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyRewardWhereInput
    orderBy?: LoyaltyRewardOrderByWithAggregationInput | LoyaltyRewardOrderByWithAggregationInput[]
    by: LoyaltyRewardScalarFieldEnum[] | LoyaltyRewardScalarFieldEnum
    having?: LoyaltyRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyRewardCountAggregateInputType | true
    _avg?: LoyaltyRewardAvgAggregateInputType
    _sum?: LoyaltyRewardSumAggregateInputType
    _min?: LoyaltyRewardMinAggregateInputType
    _max?: LoyaltyRewardMaxAggregateInputType
  }

  export type LoyaltyRewardGroupByOutputType = {
    id: string
    name: string
    description: string | null
    pointsCost: number
    value: number
    type: string
    isActive: boolean
    createdAt: Date
    _count: LoyaltyRewardCountAggregateOutputType | null
    _avg: LoyaltyRewardAvgAggregateOutputType | null
    _sum: LoyaltyRewardSumAggregateOutputType | null
    _min: LoyaltyRewardMinAggregateOutputType | null
    _max: LoyaltyRewardMaxAggregateOutputType | null
  }

  type GetLoyaltyRewardGroupByPayload<T extends LoyaltyRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyRewardGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyRewardGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsCost?: boolean
    value?: boolean
    type?: boolean
    isActive?: boolean
    createdAt?: boolean
    redemptions?: boolean | LoyaltyReward$redemptionsArgs<ExtArgs>
    _count?: boolean | LoyaltyRewardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyReward"]>

  export type LoyaltyRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsCost?: boolean
    value?: boolean
    type?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["loyaltyReward"]>

  export type LoyaltyRewardSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    pointsCost?: boolean
    value?: boolean
    type?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type LoyaltyRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | LoyaltyReward$redemptionsArgs<ExtArgs>
    _count?: boolean | LoyaltyRewardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoyaltyRewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LoyaltyRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyReward"
    objects: {
      redemptions: Prisma.$RedemptionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      pointsCost: number
      value: number
      type: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["loyaltyReward"]>
    composites: {}
  }

  type LoyaltyRewardGetPayload<S extends boolean | null | undefined | LoyaltyRewardDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyRewardPayload, S>

  type LoyaltyRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoyaltyRewardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoyaltyRewardCountAggregateInputType | true
    }

  export interface LoyaltyRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyReward'], meta: { name: 'LoyaltyReward' } }
    /**
     * Find zero or one LoyaltyReward that matches the filter.
     * @param {LoyaltyRewardFindUniqueArgs} args - Arguments to find a LoyaltyReward
     * @example
     * // Get one LoyaltyReward
     * const loyaltyReward = await prisma.loyaltyReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyRewardFindUniqueArgs>(args: SelectSubset<T, LoyaltyRewardFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoyaltyReward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoyaltyRewardFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyReward
     * @example
     * // Get one LoyaltyReward
     * const loyaltyReward = await prisma.loyaltyReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoyaltyReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyRewardFindFirstArgs} args - Arguments to find a LoyaltyReward
     * @example
     * // Get one LoyaltyReward
     * const loyaltyReward = await prisma.loyaltyReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyRewardFindFirstArgs>(args?: SelectSubset<T, LoyaltyRewardFindFirstArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoyaltyReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyRewardFindFirstOrThrowArgs} args - Arguments to find a LoyaltyReward
     * @example
     * // Get one LoyaltyReward
     * const loyaltyReward = await prisma.loyaltyReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoyaltyRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyRewards
     * const loyaltyRewards = await prisma.loyaltyReward.findMany()
     * 
     * // Get first 10 LoyaltyRewards
     * const loyaltyRewards = await prisma.loyaltyReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyRewardWithIdOnly = await prisma.loyaltyReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyRewardFindManyArgs>(args?: SelectSubset<T, LoyaltyRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoyaltyReward.
     * @param {LoyaltyRewardCreateArgs} args - Arguments to create a LoyaltyReward.
     * @example
     * // Create one LoyaltyReward
     * const LoyaltyReward = await prisma.loyaltyReward.create({
     *   data: {
     *     // ... data to create a LoyaltyReward
     *   }
     * })
     * 
     */
    create<T extends LoyaltyRewardCreateArgs>(args: SelectSubset<T, LoyaltyRewardCreateArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoyaltyRewards.
     * @param {LoyaltyRewardCreateManyArgs} args - Arguments to create many LoyaltyRewards.
     * @example
     * // Create many LoyaltyRewards
     * const loyaltyReward = await prisma.loyaltyReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyRewardCreateManyArgs>(args?: SelectSubset<T, LoyaltyRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyRewards and returns the data saved in the database.
     * @param {LoyaltyRewardCreateManyAndReturnArgs} args - Arguments to create many LoyaltyRewards.
     * @example
     * // Create many LoyaltyRewards
     * const loyaltyReward = await prisma.loyaltyReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyRewards and only return the `id`
     * const loyaltyRewardWithIdOnly = await prisma.loyaltyReward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoyaltyReward.
     * @param {LoyaltyRewardDeleteArgs} args - Arguments to delete one LoyaltyReward.
     * @example
     * // Delete one LoyaltyReward
     * const LoyaltyReward = await prisma.loyaltyReward.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyReward
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyRewardDeleteArgs>(args: SelectSubset<T, LoyaltyRewardDeleteArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoyaltyReward.
     * @param {LoyaltyRewardUpdateArgs} args - Arguments to update one LoyaltyReward.
     * @example
     * // Update one LoyaltyReward
     * const loyaltyReward = await prisma.loyaltyReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyRewardUpdateArgs>(args: SelectSubset<T, LoyaltyRewardUpdateArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoyaltyRewards.
     * @param {LoyaltyRewardDeleteManyArgs} args - Arguments to filter LoyaltyRewards to delete.
     * @example
     * // Delete a few LoyaltyRewards
     * const { count } = await prisma.loyaltyReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyRewardDeleteManyArgs>(args?: SelectSubset<T, LoyaltyRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyRewards
     * const loyaltyReward = await prisma.loyaltyReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyRewardUpdateManyArgs>(args: SelectSubset<T, LoyaltyRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoyaltyReward.
     * @param {LoyaltyRewardUpsertArgs} args - Arguments to update or create a LoyaltyReward.
     * @example
     * // Update or create a LoyaltyReward
     * const loyaltyReward = await prisma.loyaltyReward.upsert({
     *   create: {
     *     // ... data to create a LoyaltyReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyReward we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyRewardUpsertArgs>(args: SelectSubset<T, LoyaltyRewardUpsertArgs<ExtArgs>>): Prisma__LoyaltyRewardClient<$Result.GetResult<Prisma.$LoyaltyRewardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoyaltyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyRewardCountArgs} args - Arguments to filter LoyaltyRewards to count.
     * @example
     * // Count the number of LoyaltyRewards
     * const count = await prisma.loyaltyReward.count({
     *   where: {
     *     // ... the filter for the LoyaltyRewards we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyRewardCountArgs>(
      args?: Subset<T, LoyaltyRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyRewardAggregateArgs>(args: Subset<T, LoyaltyRewardAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyRewardAggregateType<T>>

    /**
     * Group by LoyaltyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyRewardGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyReward model
   */
  readonly fields: LoyaltyRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redemptions<T extends LoyaltyReward$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyReward$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedemptionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyReward model
   */ 
  interface LoyaltyRewardFieldRefs {
    readonly id: FieldRef<"LoyaltyReward", 'String'>
    readonly name: FieldRef<"LoyaltyReward", 'String'>
    readonly description: FieldRef<"LoyaltyReward", 'String'>
    readonly pointsCost: FieldRef<"LoyaltyReward", 'Int'>
    readonly value: FieldRef<"LoyaltyReward", 'Int'>
    readonly type: FieldRef<"LoyaltyReward", 'String'>
    readonly isActive: FieldRef<"LoyaltyReward", 'Boolean'>
    readonly createdAt: FieldRef<"LoyaltyReward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyReward findUnique
   */
  export type LoyaltyRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyReward to fetch.
     */
    where: LoyaltyRewardWhereUniqueInput
  }

  /**
   * LoyaltyReward findUniqueOrThrow
   */
  export type LoyaltyRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyReward to fetch.
     */
    where: LoyaltyRewardWhereUniqueInput
  }

  /**
   * LoyaltyReward findFirst
   */
  export type LoyaltyRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyReward to fetch.
     */
    where?: LoyaltyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyRewards to fetch.
     */
    orderBy?: LoyaltyRewardOrderByWithRelationInput | LoyaltyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyRewards.
     */
    cursor?: LoyaltyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyRewards.
     */
    distinct?: LoyaltyRewardScalarFieldEnum | LoyaltyRewardScalarFieldEnum[]
  }

  /**
   * LoyaltyReward findFirstOrThrow
   */
  export type LoyaltyRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyReward to fetch.
     */
    where?: LoyaltyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyRewards to fetch.
     */
    orderBy?: LoyaltyRewardOrderByWithRelationInput | LoyaltyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyRewards.
     */
    cursor?: LoyaltyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyRewards.
     */
    distinct?: LoyaltyRewardScalarFieldEnum | LoyaltyRewardScalarFieldEnum[]
  }

  /**
   * LoyaltyReward findMany
   */
  export type LoyaltyRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyRewards to fetch.
     */
    where?: LoyaltyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyRewards to fetch.
     */
    orderBy?: LoyaltyRewardOrderByWithRelationInput | LoyaltyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyRewards.
     */
    cursor?: LoyaltyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyRewards.
     */
    skip?: number
    distinct?: LoyaltyRewardScalarFieldEnum | LoyaltyRewardScalarFieldEnum[]
  }

  /**
   * LoyaltyReward create
   */
  export type LoyaltyRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyReward.
     */
    data: XOR<LoyaltyRewardCreateInput, LoyaltyRewardUncheckedCreateInput>
  }

  /**
   * LoyaltyReward createMany
   */
  export type LoyaltyRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyRewards.
     */
    data: LoyaltyRewardCreateManyInput | LoyaltyRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyReward createManyAndReturn
   */
  export type LoyaltyRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoyaltyRewards.
     */
    data: LoyaltyRewardCreateManyInput | LoyaltyRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyReward update
   */
  export type LoyaltyRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyReward.
     */
    data: XOR<LoyaltyRewardUpdateInput, LoyaltyRewardUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyReward to update.
     */
    where: LoyaltyRewardWhereUniqueInput
  }

  /**
   * LoyaltyReward updateMany
   */
  export type LoyaltyRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyRewards.
     */
    data: XOR<LoyaltyRewardUpdateManyMutationInput, LoyaltyRewardUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyRewards to update
     */
    where?: LoyaltyRewardWhereInput
  }

  /**
   * LoyaltyReward upsert
   */
  export type LoyaltyRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyReward to update in case it exists.
     */
    where: LoyaltyRewardWhereUniqueInput
    /**
     * In case the LoyaltyReward found by the `where` argument doesn't exist, create a new LoyaltyReward with this data.
     */
    create: XOR<LoyaltyRewardCreateInput, LoyaltyRewardUncheckedCreateInput>
    /**
     * In case the LoyaltyReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyRewardUpdateInput, LoyaltyRewardUncheckedUpdateInput>
  }

  /**
   * LoyaltyReward delete
   */
  export type LoyaltyRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyReward to delete.
     */
    where: LoyaltyRewardWhereUniqueInput
  }

  /**
   * LoyaltyReward deleteMany
   */
  export type LoyaltyRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyRewards to delete
     */
    where?: LoyaltyRewardWhereInput
  }

  /**
   * LoyaltyReward.redemptions
   */
  export type LoyaltyReward$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedemptionHistory
     */
    select?: RedemptionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedemptionHistoryInclude<ExtArgs> | null
    where?: RedemptionHistoryWhereInput
    orderBy?: RedemptionHistoryOrderByWithRelationInput | RedemptionHistoryOrderByWithRelationInput[]
    cursor?: RedemptionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedemptionHistoryScalarFieldEnum | RedemptionHistoryScalarFieldEnum[]
  }

  /**
   * LoyaltyReward without action
   */
  export type LoyaltyRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyReward
     */
    select?: LoyaltyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyRewardInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    url: string | null
    secret: string | null
    events: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    url: string | null
    secret: string | null
    events: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    url: number
    secret: number
    events: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type WebhookMinAggregateInputType = {
    id?: true
    url?: true
    secret?: true
    events?: true
    isActive?: true
    createdAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    url?: true
    secret?: true
    events?: true
    isActive?: true
    createdAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    url?: true
    secret?: true
    events?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    url: string
    secret: string
    events: string
    isActive: boolean
    createdAt: Date
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    createdAt?: boolean
  }


  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      secret: string
      events: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */ 
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
  }


  /**
   * Model KnowledgeBaseEntry
   */

  export type AggregateKnowledgeBaseEntry = {
    _count: KnowledgeBaseEntryCountAggregateOutputType | null
    _min: KnowledgeBaseEntryMinAggregateOutputType | null
    _max: KnowledgeBaseEntryMaxAggregateOutputType | null
  }

  export type KnowledgeBaseEntryMinAggregateOutputType = {
    id: string | null
    kind: string | null
    title: string | null
    content: string | null
    productId: string | null
    tags: string | null
    embedding: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseEntryMaxAggregateOutputType = {
    id: string | null
    kind: string | null
    title: string | null
    content: string | null
    productId: string | null
    tags: string | null
    embedding: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseEntryCountAggregateOutputType = {
    id: number
    kind: number
    title: number
    content: number
    productId: number
    tags: number
    embedding: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeBaseEntryMinAggregateInputType = {
    id?: true
    kind?: true
    title?: true
    content?: true
    productId?: true
    tags?: true
    embedding?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseEntryMaxAggregateInputType = {
    id?: true
    kind?: true
    title?: true
    content?: true
    productId?: true
    tags?: true
    embedding?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseEntryCountAggregateInputType = {
    id?: true
    kind?: true
    title?: true
    content?: true
    productId?: true
    tags?: true
    embedding?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeBaseEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseEntry to aggregate.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBaseEntries
    **/
    _count?: true | KnowledgeBaseEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseEntryMaxAggregateInputType
  }

  export type GetKnowledgeBaseEntryAggregateType<T extends KnowledgeBaseEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBaseEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBaseEntry[P]>
      : GetScalarType<T[P], AggregateKnowledgeBaseEntry[P]>
  }




  export type KnowledgeBaseEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseEntryWhereInput
    orderBy?: KnowledgeBaseEntryOrderByWithAggregationInput | KnowledgeBaseEntryOrderByWithAggregationInput[]
    by: KnowledgeBaseEntryScalarFieldEnum[] | KnowledgeBaseEntryScalarFieldEnum
    having?: KnowledgeBaseEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseEntryCountAggregateInputType | true
    _min?: KnowledgeBaseEntryMinAggregateInputType
    _max?: KnowledgeBaseEntryMaxAggregateInputType
  }

  export type KnowledgeBaseEntryGroupByOutputType = {
    id: string
    kind: string
    title: string
    content: string
    productId: string | null
    tags: string | null
    embedding: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeBaseEntryCountAggregateOutputType | null
    _min: KnowledgeBaseEntryMinAggregateOutputType | null
    _max: KnowledgeBaseEntryMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseEntryGroupByPayload<T extends KnowledgeBaseEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseEntryGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseEntryGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    title?: boolean
    content?: boolean
    productId?: boolean
    tags?: boolean
    embedding?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | KnowledgeBaseEntry$productArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBaseEntry"]>

  export type KnowledgeBaseEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    title?: boolean
    content?: boolean
    productId?: boolean
    tags?: boolean
    embedding?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | KnowledgeBaseEntry$productArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBaseEntry"]>

  export type KnowledgeBaseEntrySelectScalar = {
    id?: boolean
    kind?: boolean
    title?: boolean
    content?: boolean
    productId?: boolean
    tags?: boolean
    embedding?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeBaseEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | KnowledgeBaseEntry$productArgs<ExtArgs>
  }
  export type KnowledgeBaseEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | KnowledgeBaseEntry$productArgs<ExtArgs>
  }

  export type $KnowledgeBaseEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBaseEntry"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kind: string
      title: string
      content: string
      productId: string | null
      tags: string | null
      embedding: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeBaseEntry"]>
    composites: {}
  }

  type KnowledgeBaseEntryGetPayload<S extends boolean | null | undefined | KnowledgeBaseEntryDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBaseEntryPayload, S>

  type KnowledgeBaseEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeBaseEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeBaseEntryCountAggregateInputType | true
    }

  export interface KnowledgeBaseEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBaseEntry'], meta: { name: 'KnowledgeBaseEntry' } }
    /**
     * Find zero or one KnowledgeBaseEntry that matches the filter.
     * @param {KnowledgeBaseEntryFindUniqueArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseEntryFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseEntryFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeBaseEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeBaseEntryFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeBaseEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryFindFirstArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseEntryFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseEntryFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeBaseEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBaseEntry
     * @example
     * // Get one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeBaseEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBaseEntries
     * const knowledgeBaseEntries = await prisma.knowledgeBaseEntry.findMany()
     * 
     * // Get first 10 KnowledgeBaseEntries
     * const knowledgeBaseEntries = await prisma.knowledgeBaseEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseEntryWithIdOnly = await prisma.knowledgeBaseEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseEntryFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryCreateArgs} args - Arguments to create a KnowledgeBaseEntry.
     * @example
     * // Create one KnowledgeBaseEntry
     * const KnowledgeBaseEntry = await prisma.knowledgeBaseEntry.create({
     *   data: {
     *     // ... data to create a KnowledgeBaseEntry
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseEntryCreateArgs>(args: SelectSubset<T, KnowledgeBaseEntryCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeBaseEntries.
     * @param {KnowledgeBaseEntryCreateManyArgs} args - Arguments to create many KnowledgeBaseEntries.
     * @example
     * // Create many KnowledgeBaseEntries
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseEntryCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeBaseEntries and returns the data saved in the database.
     * @param {KnowledgeBaseEntryCreateManyAndReturnArgs} args - Arguments to create many KnowledgeBaseEntries.
     * @example
     * // Create many KnowledgeBaseEntries
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeBaseEntries and only return the `id`
     * const knowledgeBaseEntryWithIdOnly = await prisma.knowledgeBaseEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeBaseEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeBaseEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryDeleteArgs} args - Arguments to delete one KnowledgeBaseEntry.
     * @example
     * // Delete one KnowledgeBaseEntry
     * const KnowledgeBaseEntry = await prisma.knowledgeBaseEntry.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBaseEntry
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseEntryDeleteArgs>(args: SelectSubset<T, KnowledgeBaseEntryDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryUpdateArgs} args - Arguments to update one KnowledgeBaseEntry.
     * @example
     * // Update one KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseEntryUpdateArgs>(args: SelectSubset<T, KnowledgeBaseEntryUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeBaseEntries.
     * @param {KnowledgeBaseEntryDeleteManyArgs} args - Arguments to filter KnowledgeBaseEntries to delete.
     * @example
     * // Delete a few KnowledgeBaseEntries
     * const { count } = await prisma.knowledgeBaseEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseEntryDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBaseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBaseEntries
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseEntryUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeBaseEntry.
     * @param {KnowledgeBaseEntryUpsertArgs} args - Arguments to update or create a KnowledgeBaseEntry.
     * @example
     * // Update or create a KnowledgeBaseEntry
     * const knowledgeBaseEntry = await prisma.knowledgeBaseEntry.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBaseEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBaseEntry we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseEntryUpsertArgs>(args: SelectSubset<T, KnowledgeBaseEntryUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseEntryClient<$Result.GetResult<Prisma.$KnowledgeBaseEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeBaseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryCountArgs} args - Arguments to filter KnowledgeBaseEntries to count.
     * @example
     * // Count the number of KnowledgeBaseEntries
     * const count = await prisma.knowledgeBaseEntry.count({
     *   where: {
     *     // ... the filter for the KnowledgeBaseEntries we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseEntryCountArgs>(
      args?: Subset<T, KnowledgeBaseEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBaseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseEntryAggregateArgs>(args: Subset<T, KnowledgeBaseEntryAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseEntryAggregateType<T>>

    /**
     * Group by KnowledgeBaseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseEntryGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBaseEntry model
   */
  readonly fields: KnowledgeBaseEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBaseEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends KnowledgeBaseEntry$productArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseEntry$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBaseEntry model
   */ 
  interface KnowledgeBaseEntryFieldRefs {
    readonly id: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly kind: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly title: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly content: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly productId: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly tags: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly embedding: FieldRef<"KnowledgeBaseEntry", 'String'>
    readonly isActive: FieldRef<"KnowledgeBaseEntry", 'Boolean'>
    readonly createdAt: FieldRef<"KnowledgeBaseEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeBaseEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBaseEntry findUnique
   */
  export type KnowledgeBaseEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry findUniqueOrThrow
   */
  export type KnowledgeBaseEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry findFirst
   */
  export type KnowledgeBaseEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseEntries.
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseEntries.
     */
    distinct?: KnowledgeBaseEntryScalarFieldEnum | KnowledgeBaseEntryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseEntry findFirstOrThrow
   */
  export type KnowledgeBaseEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntry to fetch.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseEntries.
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseEntries.
     */
    distinct?: KnowledgeBaseEntryScalarFieldEnum | KnowledgeBaseEntryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseEntry findMany
   */
  export type KnowledgeBaseEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseEntries to fetch.
     */
    where?: KnowledgeBaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseEntries to fetch.
     */
    orderBy?: KnowledgeBaseEntryOrderByWithRelationInput | KnowledgeBaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBaseEntries.
     */
    cursor?: KnowledgeBaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseEntries.
     */
    skip?: number
    distinct?: KnowledgeBaseEntryScalarFieldEnum | KnowledgeBaseEntryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseEntry create
   */
  export type KnowledgeBaseEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBaseEntry.
     */
    data: XOR<KnowledgeBaseEntryCreateInput, KnowledgeBaseEntryUncheckedCreateInput>
  }

  /**
   * KnowledgeBaseEntry createMany
   */
  export type KnowledgeBaseEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBaseEntries.
     */
    data: KnowledgeBaseEntryCreateManyInput | KnowledgeBaseEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBaseEntry createManyAndReturn
   */
  export type KnowledgeBaseEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KnowledgeBaseEntries.
     */
    data: KnowledgeBaseEntryCreateManyInput | KnowledgeBaseEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeBaseEntry update
   */
  export type KnowledgeBaseEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBaseEntry.
     */
    data: XOR<KnowledgeBaseEntryUpdateInput, KnowledgeBaseEntryUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBaseEntry to update.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry updateMany
   */
  export type KnowledgeBaseEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBaseEntries.
     */
    data: XOR<KnowledgeBaseEntryUpdateManyMutationInput, KnowledgeBaseEntryUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBaseEntries to update
     */
    where?: KnowledgeBaseEntryWhereInput
  }

  /**
   * KnowledgeBaseEntry upsert
   */
  export type KnowledgeBaseEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBaseEntry to update in case it exists.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
    /**
     * In case the KnowledgeBaseEntry found by the `where` argument doesn't exist, create a new KnowledgeBaseEntry with this data.
     */
    create: XOR<KnowledgeBaseEntryCreateInput, KnowledgeBaseEntryUncheckedCreateInput>
    /**
     * In case the KnowledgeBaseEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseEntryUpdateInput, KnowledgeBaseEntryUncheckedUpdateInput>
  }

  /**
   * KnowledgeBaseEntry delete
   */
  export type KnowledgeBaseEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeBaseEntry to delete.
     */
    where: KnowledgeBaseEntryWhereUniqueInput
  }

  /**
   * KnowledgeBaseEntry deleteMany
   */
  export type KnowledgeBaseEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseEntries to delete
     */
    where?: KnowledgeBaseEntryWhereInput
  }

  /**
   * KnowledgeBaseEntry.product
   */
  export type KnowledgeBaseEntry$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * KnowledgeBaseEntry without action
   */
  export type KnowledgeBaseEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseEntry
     */
    select?: KnowledgeBaseEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseEntryInclude<ExtArgs> | null
  }


  /**
   * Model PaymentIntent
   */

  export type AggregatePaymentIntent = {
    _count: PaymentIntentCountAggregateOutputType | null
    _avg: PaymentIntentAvgAggregateOutputType | null
    _sum: PaymentIntentSumAggregateOutputType | null
    _min: PaymentIntentMinAggregateOutputType | null
    _max: PaymentIntentMaxAggregateOutputType | null
  }

  export type PaymentIntentAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type PaymentIntentSumAggregateOutputType = {
    amountCents: number | null
  }

  export type PaymentIntentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: string | null
    amountCents: number | null
    status: string | null
    clientSecret: string | null
    returnUrl: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentIntentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: string | null
    amountCents: number | null
    status: string | null
    clientSecret: string | null
    returnUrl: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentIntentCountAggregateOutputType = {
    id: number
    orderId: number
    provider: number
    amountCents: number
    status: number
    clientSecret: number
    returnUrl: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentIntentAvgAggregateInputType = {
    amountCents?: true
  }

  export type PaymentIntentSumAggregateInputType = {
    amountCents?: true
  }

  export type PaymentIntentMinAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    amountCents?: true
    status?: true
    clientSecret?: true
    returnUrl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentIntentMaxAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    amountCents?: true
    status?: true
    clientSecret?: true
    returnUrl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentIntentCountAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    amountCents?: true
    status?: true
    clientSecret?: true
    returnUrl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentIntentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentIntent to aggregate.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentIntents
    **/
    _count?: true | PaymentIntentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentIntentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentIntentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentIntentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentIntentMaxAggregateInputType
  }

  export type GetPaymentIntentAggregateType<T extends PaymentIntentAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentIntent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentIntent[P]>
      : GetScalarType<T[P], AggregatePaymentIntent[P]>
  }




  export type PaymentIntentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentIntentWhereInput
    orderBy?: PaymentIntentOrderByWithAggregationInput | PaymentIntentOrderByWithAggregationInput[]
    by: PaymentIntentScalarFieldEnum[] | PaymentIntentScalarFieldEnum
    having?: PaymentIntentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentIntentCountAggregateInputType | true
    _avg?: PaymentIntentAvgAggregateInputType
    _sum?: PaymentIntentSumAggregateInputType
    _min?: PaymentIntentMinAggregateInputType
    _max?: PaymentIntentMaxAggregateInputType
  }

  export type PaymentIntentGroupByOutputType = {
    id: string
    orderId: string
    provider: string
    amountCents: number
    status: string
    clientSecret: string | null
    returnUrl: string | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentIntentCountAggregateOutputType | null
    _avg: PaymentIntentAvgAggregateOutputType | null
    _sum: PaymentIntentSumAggregateOutputType | null
    _min: PaymentIntentMinAggregateOutputType | null
    _max: PaymentIntentMaxAggregateOutputType | null
  }

  type GetPaymentIntentGroupByPayload<T extends PaymentIntentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentIntentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentIntentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentIntentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentIntentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentIntentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    clientSecret?: boolean
    returnUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    payments?: boolean | PaymentIntent$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentIntentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentIntent"]>

  export type PaymentIntentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    clientSecret?: boolean
    returnUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentIntent"]>

  export type PaymentIntentSelectScalar = {
    id?: boolean
    orderId?: boolean
    provider?: boolean
    amountCents?: boolean
    status?: boolean
    clientSecret?: boolean
    returnUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentIntentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    payments?: boolean | PaymentIntent$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentIntentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIntentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentIntentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentIntent"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      provider: string
      amountCents: number
      status: string
      clientSecret: string | null
      returnUrl: string | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentIntent"]>
    composites: {}
  }

  type PaymentIntentGetPayload<S extends boolean | null | undefined | PaymentIntentDefaultArgs> = $Result.GetResult<Prisma.$PaymentIntentPayload, S>

  type PaymentIntentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentIntentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentIntentCountAggregateInputType | true
    }

  export interface PaymentIntentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentIntent'], meta: { name: 'PaymentIntent' } }
    /**
     * Find zero or one PaymentIntent that matches the filter.
     * @param {PaymentIntentFindUniqueArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentIntentFindUniqueArgs>(args: SelectSubset<T, PaymentIntentFindUniqueArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentIntent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentIntentFindUniqueOrThrowArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentIntentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentIntentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentIntent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentFindFirstArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentIntentFindFirstArgs>(args?: SelectSubset<T, PaymentIntentFindFirstArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentIntent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentFindFirstOrThrowArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentIntentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentIntentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentIntents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentIntents
     * const paymentIntents = await prisma.paymentIntent.findMany()
     * 
     * // Get first 10 PaymentIntents
     * const paymentIntents = await prisma.paymentIntent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentIntentWithIdOnly = await prisma.paymentIntent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentIntentFindManyArgs>(args?: SelectSubset<T, PaymentIntentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentIntent.
     * @param {PaymentIntentCreateArgs} args - Arguments to create a PaymentIntent.
     * @example
     * // Create one PaymentIntent
     * const PaymentIntent = await prisma.paymentIntent.create({
     *   data: {
     *     // ... data to create a PaymentIntent
     *   }
     * })
     * 
     */
    create<T extends PaymentIntentCreateArgs>(args: SelectSubset<T, PaymentIntentCreateArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentIntents.
     * @param {PaymentIntentCreateManyArgs} args - Arguments to create many PaymentIntents.
     * @example
     * // Create many PaymentIntents
     * const paymentIntent = await prisma.paymentIntent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentIntentCreateManyArgs>(args?: SelectSubset<T, PaymentIntentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentIntents and returns the data saved in the database.
     * @param {PaymentIntentCreateManyAndReturnArgs} args - Arguments to create many PaymentIntents.
     * @example
     * // Create many PaymentIntents
     * const paymentIntent = await prisma.paymentIntent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentIntents and only return the `id`
     * const paymentIntentWithIdOnly = await prisma.paymentIntent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentIntentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentIntentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentIntent.
     * @param {PaymentIntentDeleteArgs} args - Arguments to delete one PaymentIntent.
     * @example
     * // Delete one PaymentIntent
     * const PaymentIntent = await prisma.paymentIntent.delete({
     *   where: {
     *     // ... filter to delete one PaymentIntent
     *   }
     * })
     * 
     */
    delete<T extends PaymentIntentDeleteArgs>(args: SelectSubset<T, PaymentIntentDeleteArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentIntent.
     * @param {PaymentIntentUpdateArgs} args - Arguments to update one PaymentIntent.
     * @example
     * // Update one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentIntentUpdateArgs>(args: SelectSubset<T, PaymentIntentUpdateArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentIntents.
     * @param {PaymentIntentDeleteManyArgs} args - Arguments to filter PaymentIntents to delete.
     * @example
     * // Delete a few PaymentIntents
     * const { count } = await prisma.paymentIntent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentIntentDeleteManyArgs>(args?: SelectSubset<T, PaymentIntentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentIntents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentIntents
     * const paymentIntent = await prisma.paymentIntent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentIntentUpdateManyArgs>(args: SelectSubset<T, PaymentIntentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentIntent.
     * @param {PaymentIntentUpsertArgs} args - Arguments to update or create a PaymentIntent.
     * @example
     * // Update or create a PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.upsert({
     *   create: {
     *     // ... data to create a PaymentIntent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentIntent we want to update
     *   }
     * })
     */
    upsert<T extends PaymentIntentUpsertArgs>(args: SelectSubset<T, PaymentIntentUpsertArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentIntents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentCountArgs} args - Arguments to filter PaymentIntents to count.
     * @example
     * // Count the number of PaymentIntents
     * const count = await prisma.paymentIntent.count({
     *   where: {
     *     // ... the filter for the PaymentIntents we want to count
     *   }
     * })
    **/
    count<T extends PaymentIntentCountArgs>(
      args?: Subset<T, PaymentIntentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentIntentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentIntent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentIntentAggregateArgs>(args: Subset<T, PaymentIntentAggregateArgs>): Prisma.PrismaPromise<GetPaymentIntentAggregateType<T>>

    /**
     * Group by PaymentIntent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentIntentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentIntentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentIntentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentIntentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentIntentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentIntent model
   */
  readonly fields: PaymentIntentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentIntent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentIntentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends PaymentIntent$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentIntent$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentIntent model
   */ 
  interface PaymentIntentFieldRefs {
    readonly id: FieldRef<"PaymentIntent", 'String'>
    readonly orderId: FieldRef<"PaymentIntent", 'String'>
    readonly provider: FieldRef<"PaymentIntent", 'String'>
    readonly amountCents: FieldRef<"PaymentIntent", 'Int'>
    readonly status: FieldRef<"PaymentIntent", 'String'>
    readonly clientSecret: FieldRef<"PaymentIntent", 'String'>
    readonly returnUrl: FieldRef<"PaymentIntent", 'String'>
    readonly metadata: FieldRef<"PaymentIntent", 'String'>
    readonly createdAt: FieldRef<"PaymentIntent", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentIntent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentIntent findUnique
   */
  export type PaymentIntentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent findUniqueOrThrow
   */
  export type PaymentIntentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent findFirst
   */
  export type PaymentIntentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentIntents.
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentIntents.
     */
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * PaymentIntent findFirstOrThrow
   */
  export type PaymentIntentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentIntents.
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentIntents.
     */
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * PaymentIntent findMany
   */
  export type PaymentIntentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntents to fetch.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentIntents.
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * PaymentIntent create
   */
  export type PaymentIntentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentIntent.
     */
    data: XOR<PaymentIntentCreateInput, PaymentIntentUncheckedCreateInput>
  }

  /**
   * PaymentIntent createMany
   */
  export type PaymentIntentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentIntents.
     */
    data: PaymentIntentCreateManyInput | PaymentIntentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentIntent createManyAndReturn
   */
  export type PaymentIntentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentIntents.
     */
    data: PaymentIntentCreateManyInput | PaymentIntentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentIntent update
   */
  export type PaymentIntentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentIntent.
     */
    data: XOR<PaymentIntentUpdateInput, PaymentIntentUncheckedUpdateInput>
    /**
     * Choose, which PaymentIntent to update.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent updateMany
   */
  export type PaymentIntentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentIntents.
     */
    data: XOR<PaymentIntentUpdateManyMutationInput, PaymentIntentUncheckedUpdateManyInput>
    /**
     * Filter which PaymentIntents to update
     */
    where?: PaymentIntentWhereInput
  }

  /**
   * PaymentIntent upsert
   */
  export type PaymentIntentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentIntent to update in case it exists.
     */
    where: PaymentIntentWhereUniqueInput
    /**
     * In case the PaymentIntent found by the `where` argument doesn't exist, create a new PaymentIntent with this data.
     */
    create: XOR<PaymentIntentCreateInput, PaymentIntentUncheckedCreateInput>
    /**
     * In case the PaymentIntent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentIntentUpdateInput, PaymentIntentUncheckedUpdateInput>
  }

  /**
   * PaymentIntent delete
   */
  export type PaymentIntentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter which PaymentIntent to delete.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent deleteMany
   */
  export type PaymentIntentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentIntents to delete
     */
    where?: PaymentIntentWhereInput
  }

  /**
   * PaymentIntent.payments
   */
  export type PaymentIntent$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PaymentIntent without action
   */
  export type PaymentIntentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    teamSize: number | null
    displayOrder: number | null
    viewCount: number | null
  }

  export type ProjectSumAggregateOutputType = {
    teamSize: number | null
    displayOrder: number | null
    viewCount: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    client: string | null
    clientLogo: string | null
    category: string | null
    technologies: string | null
    features: string | null
    images: string | null
    thumbnailImage: string | null
    coverImage: string | null
    youtubeVideoId: string | null
    youtubeVideoUrl: string | null
    demoUrl: string | null
    githubUrl: string | null
    liveUrl: string | null
    startDate: Date | null
    endDate: Date | null
    duration: string | null
    teamSize: number | null
    budget: string | null
    status: string | null
    isActive: boolean | null
    isFeatured: boolean | null
    displayOrder: number | null
    viewCount: number | null
    userId: string | null
    tags: string | null
    testimonial: string | null
    results: string | null
    challenges: string | null
    solutions: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    structuredData: string | null
    canonicalUrl: string | null
    content: string | null
    galleryImages: string | null
    clientLogoUrl: string | null
    projectDate: Date | null
    completionDate: Date | null
    featured: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    client: string | null
    clientLogo: string | null
    category: string | null
    technologies: string | null
    features: string | null
    images: string | null
    thumbnailImage: string | null
    coverImage: string | null
    youtubeVideoId: string | null
    youtubeVideoUrl: string | null
    demoUrl: string | null
    githubUrl: string | null
    liveUrl: string | null
    startDate: Date | null
    endDate: Date | null
    duration: string | null
    teamSize: number | null
    budget: string | null
    status: string | null
    isActive: boolean | null
    isFeatured: boolean | null
    displayOrder: number | null
    viewCount: number | null
    userId: string | null
    tags: string | null
    testimonial: string | null
    results: string | null
    challenges: string | null
    solutions: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    structuredData: string | null
    canonicalUrl: string | null
    content: string | null
    galleryImages: string | null
    clientLogoUrl: string | null
    projectDate: Date | null
    completionDate: Date | null
    featured: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    shortDescription: number
    client: number
    clientLogo: number
    category: number
    technologies: number
    features: number
    images: number
    thumbnailImage: number
    coverImage: number
    youtubeVideoId: number
    youtubeVideoUrl: number
    demoUrl: number
    githubUrl: number
    liveUrl: number
    startDate: number
    endDate: number
    duration: number
    teamSize: number
    budget: number
    status: number
    isActive: number
    isFeatured: number
    displayOrder: number
    viewCount: number
    userId: number
    tags: number
    testimonial: number
    results: number
    challenges: number
    solutions: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    ogTitle: number
    ogDescription: number
    ogImage: number
    structuredData: number
    canonicalUrl: number
    content: number
    galleryImages: number
    clientLogoUrl: number
    projectDate: number
    completionDate: number
    featured: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    teamSize?: true
    displayOrder?: true
    viewCount?: true
  }

  export type ProjectSumAggregateInputType = {
    teamSize?: true
    displayOrder?: true
    viewCount?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    client?: true
    clientLogo?: true
    category?: true
    technologies?: true
    features?: true
    images?: true
    thumbnailImage?: true
    coverImage?: true
    youtubeVideoId?: true
    youtubeVideoUrl?: true
    demoUrl?: true
    githubUrl?: true
    liveUrl?: true
    startDate?: true
    endDate?: true
    duration?: true
    teamSize?: true
    budget?: true
    status?: true
    isActive?: true
    isFeatured?: true
    displayOrder?: true
    viewCount?: true
    userId?: true
    tags?: true
    testimonial?: true
    results?: true
    challenges?: true
    solutions?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    structuredData?: true
    canonicalUrl?: true
    content?: true
    galleryImages?: true
    clientLogoUrl?: true
    projectDate?: true
    completionDate?: true
    featured?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    client?: true
    clientLogo?: true
    category?: true
    technologies?: true
    features?: true
    images?: true
    thumbnailImage?: true
    coverImage?: true
    youtubeVideoId?: true
    youtubeVideoUrl?: true
    demoUrl?: true
    githubUrl?: true
    liveUrl?: true
    startDate?: true
    endDate?: true
    duration?: true
    teamSize?: true
    budget?: true
    status?: true
    isActive?: true
    isFeatured?: true
    displayOrder?: true
    viewCount?: true
    userId?: true
    tags?: true
    testimonial?: true
    results?: true
    challenges?: true
    solutions?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    structuredData?: true
    canonicalUrl?: true
    content?: true
    galleryImages?: true
    clientLogoUrl?: true
    projectDate?: true
    completionDate?: true
    featured?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    client?: true
    clientLogo?: true
    category?: true
    technologies?: true
    features?: true
    images?: true
    thumbnailImage?: true
    coverImage?: true
    youtubeVideoId?: true
    youtubeVideoUrl?: true
    demoUrl?: true
    githubUrl?: true
    liveUrl?: true
    startDate?: true
    endDate?: true
    duration?: true
    teamSize?: true
    budget?: true
    status?: true
    isActive?: true
    isFeatured?: true
    displayOrder?: true
    viewCount?: true
    userId?: true
    tags?: true
    testimonial?: true
    results?: true
    challenges?: true
    solutions?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    ogTitle?: true
    ogDescription?: true
    ogImage?: true
    structuredData?: true
    canonicalUrl?: true
    content?: true
    galleryImages?: true
    clientLogoUrl?: true
    projectDate?: true
    completionDate?: true
    featured?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    shortDescription: string | null
    client: string | null
    clientLogo: string | null
    category: string | null
    technologies: string | null
    features: string | null
    images: string | null
    thumbnailImage: string | null
    coverImage: string | null
    youtubeVideoId: string | null
    youtubeVideoUrl: string | null
    demoUrl: string | null
    githubUrl: string | null
    liveUrl: string | null
    startDate: Date | null
    endDate: Date | null
    duration: string | null
    teamSize: number | null
    budget: string | null
    status: string
    isActive: boolean
    isFeatured: boolean
    displayOrder: number
    viewCount: number
    userId: string
    tags: string | null
    testimonial: string | null
    results: string | null
    challenges: string | null
    solutions: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    ogTitle: string | null
    ogDescription: string | null
    ogImage: string | null
    structuredData: string | null
    canonicalUrl: string | null
    content: string | null
    galleryImages: string | null
    clientLogoUrl: string | null
    projectDate: Date | null
    completionDate: Date | null
    featured: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    client?: boolean
    clientLogo?: boolean
    category?: boolean
    technologies?: boolean
    features?: boolean
    images?: boolean
    thumbnailImage?: boolean
    coverImage?: boolean
    youtubeVideoId?: boolean
    youtubeVideoUrl?: boolean
    demoUrl?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    teamSize?: boolean
    budget?: boolean
    status?: boolean
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: boolean
    viewCount?: boolean
    userId?: boolean
    tags?: boolean
    testimonial?: boolean
    results?: boolean
    challenges?: boolean
    solutions?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    structuredData?: boolean
    canonicalUrl?: boolean
    content?: boolean
    galleryImages?: boolean
    clientLogoUrl?: boolean
    projectDate?: boolean
    completionDate?: boolean
    featured?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    client?: boolean
    clientLogo?: boolean
    category?: boolean
    technologies?: boolean
    features?: boolean
    images?: boolean
    thumbnailImage?: boolean
    coverImage?: boolean
    youtubeVideoId?: boolean
    youtubeVideoUrl?: boolean
    demoUrl?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    teamSize?: boolean
    budget?: boolean
    status?: boolean
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: boolean
    viewCount?: boolean
    userId?: boolean
    tags?: boolean
    testimonial?: boolean
    results?: boolean
    challenges?: boolean
    solutions?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    structuredData?: boolean
    canonicalUrl?: boolean
    content?: boolean
    galleryImages?: boolean
    clientLogoUrl?: boolean
    projectDate?: boolean
    completionDate?: boolean
    featured?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    client?: boolean
    clientLogo?: boolean
    category?: boolean
    technologies?: boolean
    features?: boolean
    images?: boolean
    thumbnailImage?: boolean
    coverImage?: boolean
    youtubeVideoId?: boolean
    youtubeVideoUrl?: boolean
    demoUrl?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    teamSize?: boolean
    budget?: boolean
    status?: boolean
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: boolean
    viewCount?: boolean
    userId?: boolean
    tags?: boolean
    testimonial?: boolean
    results?: boolean
    challenges?: boolean
    solutions?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    ogTitle?: boolean
    ogDescription?: boolean
    ogImage?: boolean
    structuredData?: boolean
    canonicalUrl?: boolean
    content?: boolean
    galleryImages?: boolean
    clientLogoUrl?: boolean
    projectDate?: boolean
    completionDate?: boolean
    featured?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      shortDescription: string | null
      client: string | null
      clientLogo: string | null
      category: string | null
      technologies: string | null
      features: string | null
      images: string | null
      thumbnailImage: string | null
      coverImage: string | null
      youtubeVideoId: string | null
      youtubeVideoUrl: string | null
      demoUrl: string | null
      githubUrl: string | null
      liveUrl: string | null
      startDate: Date | null
      endDate: Date | null
      duration: string | null
      teamSize: number | null
      budget: string | null
      status: string
      isActive: boolean
      isFeatured: boolean
      displayOrder: number
      viewCount: number
      userId: string
      tags: string | null
      testimonial: string | null
      results: string | null
      challenges: string | null
      solutions: string | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
      ogTitle: string | null
      ogDescription: string | null
      ogImage: string | null
      structuredData: string | null
      canonicalUrl: string | null
      content: string | null
      galleryImages: string | null
      clientLogoUrl: string | null
      projectDate: Date | null
      completionDate: Date | null
      featured: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly slug: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly shortDescription: FieldRef<"Project", 'String'>
    readonly client: FieldRef<"Project", 'String'>
    readonly clientLogo: FieldRef<"Project", 'String'>
    readonly category: FieldRef<"Project", 'String'>
    readonly technologies: FieldRef<"Project", 'String'>
    readonly features: FieldRef<"Project", 'String'>
    readonly images: FieldRef<"Project", 'String'>
    readonly thumbnailImage: FieldRef<"Project", 'String'>
    readonly coverImage: FieldRef<"Project", 'String'>
    readonly youtubeVideoId: FieldRef<"Project", 'String'>
    readonly youtubeVideoUrl: FieldRef<"Project", 'String'>
    readonly demoUrl: FieldRef<"Project", 'String'>
    readonly githubUrl: FieldRef<"Project", 'String'>
    readonly liveUrl: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly duration: FieldRef<"Project", 'String'>
    readonly teamSize: FieldRef<"Project", 'Int'>
    readonly budget: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly isActive: FieldRef<"Project", 'Boolean'>
    readonly isFeatured: FieldRef<"Project", 'Boolean'>
    readonly displayOrder: FieldRef<"Project", 'Int'>
    readonly viewCount: FieldRef<"Project", 'Int'>
    readonly userId: FieldRef<"Project", 'String'>
    readonly tags: FieldRef<"Project", 'String'>
    readonly testimonial: FieldRef<"Project", 'String'>
    readonly results: FieldRef<"Project", 'String'>
    readonly challenges: FieldRef<"Project", 'String'>
    readonly solutions: FieldRef<"Project", 'String'>
    readonly metaTitle: FieldRef<"Project", 'String'>
    readonly metaDescription: FieldRef<"Project", 'String'>
    readonly metaKeywords: FieldRef<"Project", 'String'>
    readonly ogTitle: FieldRef<"Project", 'String'>
    readonly ogDescription: FieldRef<"Project", 'String'>
    readonly ogImage: FieldRef<"Project", 'String'>
    readonly structuredData: FieldRef<"Project", 'String'>
    readonly canonicalUrl: FieldRef<"Project", 'String'>
    readonly content: FieldRef<"Project", 'String'>
    readonly galleryImages: FieldRef<"Project", 'String'>
    readonly clientLogoUrl: FieldRef<"Project", 'String'>
    readonly projectDate: FieldRef<"Project", 'DateTime'>
    readonly completionDate: FieldRef<"Project", 'DateTime'>
    readonly featured: FieldRef<"Project", 'Boolean'>
    readonly isDeleted: FieldRef<"Project", 'Boolean'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    statusCode: number | null
    duration: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    statusCode: number | null
    duration: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    method: string | null
    url: string | null
    statusCode: number | null
    duration: number | null
    category: string | null
    severity: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    method: string | null
    url: string | null
    statusCode: number | null
    duration: number | null
    category: string | null
    severity: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    method: number
    url: number
    statusCode: number
    duration: number
    category: number
    severity: number
    createdAt: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    statusCode?: true
    duration?: true
  }

  export type ActivityLogSumAggregateInputType = {
    statusCode?: true
    duration?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    method?: true
    url?: true
    statusCode?: true
    duration?: true
    category?: true
    severity?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    method?: true
    url?: true
    statusCode?: true
    duration?: true
    category?: true
    severity?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    method?: true
    url?: true
    statusCode?: true
    duration?: true
    category?: true
    severity?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    method: string | null
    url: string | null
    statusCode: number | null
    duration: number | null
    category: string
    severity: string
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    method?: boolean
    url?: boolean
    statusCode?: boolean
    duration?: boolean
    category?: boolean
    severity?: boolean
    createdAt?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    method?: boolean
    url?: boolean
    statusCode?: boolean
    duration?: boolean
    category?: boolean
    severity?: boolean
    createdAt?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    method?: boolean
    url?: boolean
    statusCode?: boolean
    duration?: boolean
    category?: boolean
    severity?: boolean
    createdAt?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string | null
      resourceId: string | null
      details: string | null
      ipAddress: string | null
      userAgent: string | null
      method: string | null
      url: string | null
      statusCode: number | null
      duration: number | null
      category: string
      severity: string
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ActivityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly resource: FieldRef<"ActivityLog", 'String'>
    readonly resourceId: FieldRef<"ActivityLog", 'String'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly method: FieldRef<"ActivityLog", 'String'>
    readonly url: FieldRef<"ActivityLog", 'String'>
    readonly statusCode: FieldRef<"ActivityLog", 'Int'>
    readonly duration: FieldRef<"ActivityLog", 'Int'>
    readonly category: FieldRef<"ActivityLog", 'String'>
    readonly severity: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog.user
   */
  export type ActivityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    discountPercent: number | null
    discountAmount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    discountPercent: number | null
    discountAmount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.CampaignType | null
    status: $Enums.CampaignStatus | null
    targetAudience: string | null
    discountPercent: number | null
    discountAmount: number | null
    startDate: Date | null
    endDate: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.CampaignType | null
    status: $Enums.CampaignStatus | null
    targetAudience: string | null
    discountPercent: number | null
    discountAmount: number | null
    startDate: Date | null
    endDate: Date | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    status: number
    targetAudience: number
    discountPercent: number
    discountAmount: number
    startDate: number
    endDate: number
    sentAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    discountPercent?: true
    discountAmount?: true
  }

  export type CampaignSumAggregateInputType = {
    discountPercent?: true
    discountAmount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    targetAudience?: true
    discountPercent?: true
    discountAmount?: true
    startDate?: true
    endDate?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    targetAudience?: true
    discountPercent?: true
    discountAmount?: true
    startDate?: true
    endDate?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    targetAudience?: true
    discountPercent?: true
    discountAmount?: true
    startDate?: true
    endDate?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.CampaignType
    status: $Enums.CampaignStatus
    targetAudience: string | null
    discountPercent: number | null
    discountAmount: number | null
    startDate: Date | null
    endDate: Date | null
    sentAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    targetAudience?: boolean
    discountPercent?: boolean
    discountAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clicks?: boolean | Campaign$clicksArgs<ExtArgs>
    opens?: boolean | Campaign$opensArgs<ExtArgs>
    recipients?: boolean | Campaign$recipientsArgs<ExtArgs>
    emailLogs?: boolean | Campaign$emailLogsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    targetAudience?: boolean
    discountPercent?: boolean
    discountAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    targetAudience?: boolean
    discountPercent?: boolean
    discountAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clicks?: boolean | Campaign$clicksArgs<ExtArgs>
    opens?: boolean | Campaign$opensArgs<ExtArgs>
    recipients?: boolean | Campaign$recipientsArgs<ExtArgs>
    emailLogs?: boolean | Campaign$emailLogsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      clicks: Prisma.$CampaignClickPayload<ExtArgs>[]
      opens: Prisma.$CampaignOpenPayload<ExtArgs>[]
      recipients: Prisma.$CampaignRecipientPayload<ExtArgs>[]
      emailLogs: Prisma.$EmailLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.CampaignType
      status: $Enums.CampaignStatus
      targetAudience: string | null
      discountPercent: number | null
      discountAmount: number | null
      startDate: Date | null
      endDate: Date | null
      sentAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clicks<T extends Campaign$clicksArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$clicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "findMany"> | Null>
    opens<T extends Campaign$opensArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$opensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "findMany"> | Null>
    recipients<T extends Campaign$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findMany"> | Null>
    emailLogs<T extends Campaign$emailLogsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$emailLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'CampaignType'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly targetAudience: FieldRef<"Campaign", 'String'>
    readonly discountPercent: FieldRef<"Campaign", 'Int'>
    readonly discountAmount: FieldRef<"Campaign", 'Int'>
    readonly startDate: FieldRef<"Campaign", 'DateTime'>
    readonly endDate: FieldRef<"Campaign", 'DateTime'>
    readonly sentAt: FieldRef<"Campaign", 'DateTime'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.clicks
   */
  export type Campaign$clicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    where?: CampaignClickWhereInput
    orderBy?: CampaignClickOrderByWithRelationInput | CampaignClickOrderByWithRelationInput[]
    cursor?: CampaignClickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignClickScalarFieldEnum | CampaignClickScalarFieldEnum[]
  }

  /**
   * Campaign.opens
   */
  export type Campaign$opensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    where?: CampaignOpenWhereInput
    orderBy?: CampaignOpenOrderByWithRelationInput | CampaignOpenOrderByWithRelationInput[]
    cursor?: CampaignOpenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignOpenScalarFieldEnum | CampaignOpenScalarFieldEnum[]
  }

  /**
   * Campaign.recipients
   */
  export type Campaign$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    where?: CampaignRecipientWhereInput
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    cursor?: CampaignRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * Campaign.emailLogs
   */
  export type Campaign$emailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    cursor?: EmailLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignRecipient
   */

  export type AggregateCampaignRecipient = {
    _count: CampaignRecipientCountAggregateOutputType | null
    _min: CampaignRecipientMinAggregateOutputType | null
    _max: CampaignRecipientMaxAggregateOutputType | null
  }

  export type CampaignRecipientMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
  }

  export type CampaignRecipientMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
  }

  export type CampaignRecipientCountAggregateOutputType = {
    id: number
    campaignId: number
    email: number
    name: number
    createdAt: number
    _all: number
  }


  export type CampaignRecipientMinAggregateInputType = {
    id?: true
    campaignId?: true
    email?: true
    name?: true
    createdAt?: true
  }

  export type CampaignRecipientMaxAggregateInputType = {
    id?: true
    campaignId?: true
    email?: true
    name?: true
    createdAt?: true
  }

  export type CampaignRecipientCountAggregateInputType = {
    id?: true
    campaignId?: true
    email?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignRecipient to aggregate.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignRecipients
    **/
    _count?: true | CampaignRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignRecipientMaxAggregateInputType
  }

  export type GetCampaignRecipientAggregateType<T extends CampaignRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignRecipient[P]>
      : GetScalarType<T[P], AggregateCampaignRecipient[P]>
  }




  export type CampaignRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignRecipientWhereInput
    orderBy?: CampaignRecipientOrderByWithAggregationInput | CampaignRecipientOrderByWithAggregationInput[]
    by: CampaignRecipientScalarFieldEnum[] | CampaignRecipientScalarFieldEnum
    having?: CampaignRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignRecipientCountAggregateInputType | true
    _min?: CampaignRecipientMinAggregateInputType
    _max?: CampaignRecipientMaxAggregateInputType
  }

  export type CampaignRecipientGroupByOutputType = {
    id: string
    campaignId: string
    email: string
    name: string | null
    createdAt: Date
    _count: CampaignRecipientCountAggregateOutputType | null
    _min: CampaignRecipientMinAggregateOutputType | null
    _max: CampaignRecipientMaxAggregateOutputType | null
  }

  type GetCampaignRecipientGroupByPayload<T extends CampaignRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignRecipientGroupByOutputType[P]>
        }
      >
    >


  export type CampaignRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignRecipient"]>

  export type CampaignRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignRecipient"]>

  export type CampaignRecipientSelectScalar = {
    id?: boolean
    campaignId?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type CampaignRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignRecipient"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      email: string
      name: string | null
      createdAt: Date
    }, ExtArgs["result"]["campaignRecipient"]>
    composites: {}
  }

  type CampaignRecipientGetPayload<S extends boolean | null | undefined | CampaignRecipientDefaultArgs> = $Result.GetResult<Prisma.$CampaignRecipientPayload, S>

  type CampaignRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignRecipientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignRecipientCountAggregateInputType | true
    }

  export interface CampaignRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignRecipient'], meta: { name: 'CampaignRecipient' } }
    /**
     * Find zero or one CampaignRecipient that matches the filter.
     * @param {CampaignRecipientFindUniqueArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignRecipientFindUniqueArgs>(args: SelectSubset<T, CampaignRecipientFindUniqueArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignRecipient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignRecipientFindUniqueOrThrowArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientFindFirstArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignRecipientFindFirstArgs>(args?: SelectSubset<T, CampaignRecipientFindFirstArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientFindFirstOrThrowArgs} args - Arguments to find a CampaignRecipient
     * @example
     * // Get one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignRecipients
     * const campaignRecipients = await prisma.campaignRecipient.findMany()
     * 
     * // Get first 10 CampaignRecipients
     * const campaignRecipients = await prisma.campaignRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignRecipientWithIdOnly = await prisma.campaignRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignRecipientFindManyArgs>(args?: SelectSubset<T, CampaignRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignRecipient.
     * @param {CampaignRecipientCreateArgs} args - Arguments to create a CampaignRecipient.
     * @example
     * // Create one CampaignRecipient
     * const CampaignRecipient = await prisma.campaignRecipient.create({
     *   data: {
     *     // ... data to create a CampaignRecipient
     *   }
     * })
     * 
     */
    create<T extends CampaignRecipientCreateArgs>(args: SelectSubset<T, CampaignRecipientCreateArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignRecipients.
     * @param {CampaignRecipientCreateManyArgs} args - Arguments to create many CampaignRecipients.
     * @example
     * // Create many CampaignRecipients
     * const campaignRecipient = await prisma.campaignRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignRecipientCreateManyArgs>(args?: SelectSubset<T, CampaignRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignRecipients and returns the data saved in the database.
     * @param {CampaignRecipientCreateManyAndReturnArgs} args - Arguments to create many CampaignRecipients.
     * @example
     * // Create many CampaignRecipients
     * const campaignRecipient = await prisma.campaignRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignRecipients and only return the `id`
     * const campaignRecipientWithIdOnly = await prisma.campaignRecipient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignRecipient.
     * @param {CampaignRecipientDeleteArgs} args - Arguments to delete one CampaignRecipient.
     * @example
     * // Delete one CampaignRecipient
     * const CampaignRecipient = await prisma.campaignRecipient.delete({
     *   where: {
     *     // ... filter to delete one CampaignRecipient
     *   }
     * })
     * 
     */
    delete<T extends CampaignRecipientDeleteArgs>(args: SelectSubset<T, CampaignRecipientDeleteArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignRecipient.
     * @param {CampaignRecipientUpdateArgs} args - Arguments to update one CampaignRecipient.
     * @example
     * // Update one CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignRecipientUpdateArgs>(args: SelectSubset<T, CampaignRecipientUpdateArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignRecipients.
     * @param {CampaignRecipientDeleteManyArgs} args - Arguments to filter CampaignRecipients to delete.
     * @example
     * // Delete a few CampaignRecipients
     * const { count } = await prisma.campaignRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignRecipientDeleteManyArgs>(args?: SelectSubset<T, CampaignRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignRecipients
     * const campaignRecipient = await prisma.campaignRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignRecipientUpdateManyArgs>(args: SelectSubset<T, CampaignRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignRecipient.
     * @param {CampaignRecipientUpsertArgs} args - Arguments to update or create a CampaignRecipient.
     * @example
     * // Update or create a CampaignRecipient
     * const campaignRecipient = await prisma.campaignRecipient.upsert({
     *   create: {
     *     // ... data to create a CampaignRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignRecipient we want to update
     *   }
     * })
     */
    upsert<T extends CampaignRecipientUpsertArgs>(args: SelectSubset<T, CampaignRecipientUpsertArgs<ExtArgs>>): Prisma__CampaignRecipientClient<$Result.GetResult<Prisma.$CampaignRecipientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientCountArgs} args - Arguments to filter CampaignRecipients to count.
     * @example
     * // Count the number of CampaignRecipients
     * const count = await prisma.campaignRecipient.count({
     *   where: {
     *     // ... the filter for the CampaignRecipients we want to count
     *   }
     * })
    **/
    count<T extends CampaignRecipientCountArgs>(
      args?: Subset<T, CampaignRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignRecipientAggregateArgs>(args: Subset<T, CampaignRecipientAggregateArgs>): Prisma.PrismaPromise<GetCampaignRecipientAggregateType<T>>

    /**
     * Group by CampaignRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignRecipientGroupByArgs['orderBy'] }
        : { orderBy?: CampaignRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignRecipient model
   */
  readonly fields: CampaignRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignRecipient model
   */ 
  interface CampaignRecipientFieldRefs {
    readonly id: FieldRef<"CampaignRecipient", 'String'>
    readonly campaignId: FieldRef<"CampaignRecipient", 'String'>
    readonly email: FieldRef<"CampaignRecipient", 'String'>
    readonly name: FieldRef<"CampaignRecipient", 'String'>
    readonly createdAt: FieldRef<"CampaignRecipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignRecipient findUnique
   */
  export type CampaignRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient findUniqueOrThrow
   */
  export type CampaignRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient findFirst
   */
  export type CampaignRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignRecipients.
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignRecipients.
     */
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * CampaignRecipient findFirstOrThrow
   */
  export type CampaignRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipient to fetch.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignRecipients.
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignRecipients.
     */
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * CampaignRecipient findMany
   */
  export type CampaignRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter, which CampaignRecipients to fetch.
     */
    where?: CampaignRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignRecipients to fetch.
     */
    orderBy?: CampaignRecipientOrderByWithRelationInput | CampaignRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignRecipients.
     */
    cursor?: CampaignRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignRecipients.
     */
    skip?: number
    distinct?: CampaignRecipientScalarFieldEnum | CampaignRecipientScalarFieldEnum[]
  }

  /**
   * CampaignRecipient create
   */
  export type CampaignRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignRecipient.
     */
    data: XOR<CampaignRecipientCreateInput, CampaignRecipientUncheckedCreateInput>
  }

  /**
   * CampaignRecipient createMany
   */
  export type CampaignRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignRecipients.
     */
    data: CampaignRecipientCreateManyInput | CampaignRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignRecipient createManyAndReturn
   */
  export type CampaignRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignRecipients.
     */
    data: CampaignRecipientCreateManyInput | CampaignRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignRecipient update
   */
  export type CampaignRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignRecipient.
     */
    data: XOR<CampaignRecipientUpdateInput, CampaignRecipientUncheckedUpdateInput>
    /**
     * Choose, which CampaignRecipient to update.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient updateMany
   */
  export type CampaignRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignRecipients.
     */
    data: XOR<CampaignRecipientUpdateManyMutationInput, CampaignRecipientUncheckedUpdateManyInput>
    /**
     * Filter which CampaignRecipients to update
     */
    where?: CampaignRecipientWhereInput
  }

  /**
   * CampaignRecipient upsert
   */
  export type CampaignRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignRecipient to update in case it exists.
     */
    where: CampaignRecipientWhereUniqueInput
    /**
     * In case the CampaignRecipient found by the `where` argument doesn't exist, create a new CampaignRecipient with this data.
     */
    create: XOR<CampaignRecipientCreateInput, CampaignRecipientUncheckedCreateInput>
    /**
     * In case the CampaignRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignRecipientUpdateInput, CampaignRecipientUncheckedUpdateInput>
  }

  /**
   * CampaignRecipient delete
   */
  export type CampaignRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
    /**
     * Filter which CampaignRecipient to delete.
     */
    where: CampaignRecipientWhereUniqueInput
  }

  /**
   * CampaignRecipient deleteMany
   */
  export type CampaignRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignRecipients to delete
     */
    where?: CampaignRecipientWhereInput
  }

  /**
   * CampaignRecipient without action
   */
  export type CampaignRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignRecipient
     */
    select?: CampaignRecipientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignRecipientInclude<ExtArgs> | null
  }


  /**
   * Model CampaignOpen
   */

  export type AggregateCampaignOpen = {
    _count: CampaignOpenCountAggregateOutputType | null
    _min: CampaignOpenMinAggregateOutputType | null
    _max: CampaignOpenMaxAggregateOutputType | null
  }

  export type CampaignOpenMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    recipientEmail: string | null
    createdAt: Date | null
  }

  export type CampaignOpenMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    recipientEmail: string | null
    createdAt: Date | null
  }

  export type CampaignOpenCountAggregateOutputType = {
    id: number
    campaignId: number
    recipientEmail: number
    createdAt: number
    _all: number
  }


  export type CampaignOpenMinAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    createdAt?: true
  }

  export type CampaignOpenMaxAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    createdAt?: true
  }

  export type CampaignOpenCountAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignOpenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignOpen to aggregate.
     */
    where?: CampaignOpenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOpens to fetch.
     */
    orderBy?: CampaignOpenOrderByWithRelationInput | CampaignOpenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignOpenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOpens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOpens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignOpens
    **/
    _count?: true | CampaignOpenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignOpenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignOpenMaxAggregateInputType
  }

  export type GetCampaignOpenAggregateType<T extends CampaignOpenAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignOpen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignOpen[P]>
      : GetScalarType<T[P], AggregateCampaignOpen[P]>
  }




  export type CampaignOpenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignOpenWhereInput
    orderBy?: CampaignOpenOrderByWithAggregationInput | CampaignOpenOrderByWithAggregationInput[]
    by: CampaignOpenScalarFieldEnum[] | CampaignOpenScalarFieldEnum
    having?: CampaignOpenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignOpenCountAggregateInputType | true
    _min?: CampaignOpenMinAggregateInputType
    _max?: CampaignOpenMaxAggregateInputType
  }

  export type CampaignOpenGroupByOutputType = {
    id: string
    campaignId: string
    recipientEmail: string | null
    createdAt: Date
    _count: CampaignOpenCountAggregateOutputType | null
    _min: CampaignOpenMinAggregateOutputType | null
    _max: CampaignOpenMaxAggregateOutputType | null
  }

  type GetCampaignOpenGroupByPayload<T extends CampaignOpenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignOpenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignOpenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignOpenGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignOpenGroupByOutputType[P]>
        }
      >
    >


  export type CampaignOpenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignOpen"]>

  export type CampaignOpenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignOpen"]>

  export type CampaignOpenSelectScalar = {
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    createdAt?: boolean
  }

  export type CampaignOpenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignOpenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignOpenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignOpen"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      recipientEmail: string | null
      createdAt: Date
    }, ExtArgs["result"]["campaignOpen"]>
    composites: {}
  }

  type CampaignOpenGetPayload<S extends boolean | null | undefined | CampaignOpenDefaultArgs> = $Result.GetResult<Prisma.$CampaignOpenPayload, S>

  type CampaignOpenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignOpenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignOpenCountAggregateInputType | true
    }

  export interface CampaignOpenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignOpen'], meta: { name: 'CampaignOpen' } }
    /**
     * Find zero or one CampaignOpen that matches the filter.
     * @param {CampaignOpenFindUniqueArgs} args - Arguments to find a CampaignOpen
     * @example
     * // Get one CampaignOpen
     * const campaignOpen = await prisma.campaignOpen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignOpenFindUniqueArgs>(args: SelectSubset<T, CampaignOpenFindUniqueArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignOpen that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignOpenFindUniqueOrThrowArgs} args - Arguments to find a CampaignOpen
     * @example
     * // Get one CampaignOpen
     * const campaignOpen = await prisma.campaignOpen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignOpenFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignOpenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignOpen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOpenFindFirstArgs} args - Arguments to find a CampaignOpen
     * @example
     * // Get one CampaignOpen
     * const campaignOpen = await prisma.campaignOpen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignOpenFindFirstArgs>(args?: SelectSubset<T, CampaignOpenFindFirstArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignOpen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOpenFindFirstOrThrowArgs} args - Arguments to find a CampaignOpen
     * @example
     * // Get one CampaignOpen
     * const campaignOpen = await prisma.campaignOpen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignOpenFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignOpenFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignOpens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOpenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignOpens
     * const campaignOpens = await prisma.campaignOpen.findMany()
     * 
     * // Get first 10 CampaignOpens
     * const campaignOpens = await prisma.campaignOpen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignOpenWithIdOnly = await prisma.campaignOpen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignOpenFindManyArgs>(args?: SelectSubset<T, CampaignOpenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignOpen.
     * @param {CampaignOpenCreateArgs} args - Arguments to create a CampaignOpen.
     * @example
     * // Create one CampaignOpen
     * const CampaignOpen = await prisma.campaignOpen.create({
     *   data: {
     *     // ... data to create a CampaignOpen
     *   }
     * })
     * 
     */
    create<T extends CampaignOpenCreateArgs>(args: SelectSubset<T, CampaignOpenCreateArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignOpens.
     * @param {CampaignOpenCreateManyArgs} args - Arguments to create many CampaignOpens.
     * @example
     * // Create many CampaignOpens
     * const campaignOpen = await prisma.campaignOpen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignOpenCreateManyArgs>(args?: SelectSubset<T, CampaignOpenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignOpens and returns the data saved in the database.
     * @param {CampaignOpenCreateManyAndReturnArgs} args - Arguments to create many CampaignOpens.
     * @example
     * // Create many CampaignOpens
     * const campaignOpen = await prisma.campaignOpen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignOpens and only return the `id`
     * const campaignOpenWithIdOnly = await prisma.campaignOpen.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignOpenCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignOpenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignOpen.
     * @param {CampaignOpenDeleteArgs} args - Arguments to delete one CampaignOpen.
     * @example
     * // Delete one CampaignOpen
     * const CampaignOpen = await prisma.campaignOpen.delete({
     *   where: {
     *     // ... filter to delete one CampaignOpen
     *   }
     * })
     * 
     */
    delete<T extends CampaignOpenDeleteArgs>(args: SelectSubset<T, CampaignOpenDeleteArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignOpen.
     * @param {CampaignOpenUpdateArgs} args - Arguments to update one CampaignOpen.
     * @example
     * // Update one CampaignOpen
     * const campaignOpen = await prisma.campaignOpen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignOpenUpdateArgs>(args: SelectSubset<T, CampaignOpenUpdateArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignOpens.
     * @param {CampaignOpenDeleteManyArgs} args - Arguments to filter CampaignOpens to delete.
     * @example
     * // Delete a few CampaignOpens
     * const { count } = await prisma.campaignOpen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignOpenDeleteManyArgs>(args?: SelectSubset<T, CampaignOpenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignOpens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOpenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignOpens
     * const campaignOpen = await prisma.campaignOpen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignOpenUpdateManyArgs>(args: SelectSubset<T, CampaignOpenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignOpen.
     * @param {CampaignOpenUpsertArgs} args - Arguments to update or create a CampaignOpen.
     * @example
     * // Update or create a CampaignOpen
     * const campaignOpen = await prisma.campaignOpen.upsert({
     *   create: {
     *     // ... data to create a CampaignOpen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignOpen we want to update
     *   }
     * })
     */
    upsert<T extends CampaignOpenUpsertArgs>(args: SelectSubset<T, CampaignOpenUpsertArgs<ExtArgs>>): Prisma__CampaignOpenClient<$Result.GetResult<Prisma.$CampaignOpenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignOpens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOpenCountArgs} args - Arguments to filter CampaignOpens to count.
     * @example
     * // Count the number of CampaignOpens
     * const count = await prisma.campaignOpen.count({
     *   where: {
     *     // ... the filter for the CampaignOpens we want to count
     *   }
     * })
    **/
    count<T extends CampaignOpenCountArgs>(
      args?: Subset<T, CampaignOpenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignOpenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignOpen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOpenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignOpenAggregateArgs>(args: Subset<T, CampaignOpenAggregateArgs>): Prisma.PrismaPromise<GetCampaignOpenAggregateType<T>>

    /**
     * Group by CampaignOpen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignOpenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignOpenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignOpenGroupByArgs['orderBy'] }
        : { orderBy?: CampaignOpenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignOpenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignOpenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignOpen model
   */
  readonly fields: CampaignOpenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignOpen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignOpenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignOpen model
   */ 
  interface CampaignOpenFieldRefs {
    readonly id: FieldRef<"CampaignOpen", 'String'>
    readonly campaignId: FieldRef<"CampaignOpen", 'String'>
    readonly recipientEmail: FieldRef<"CampaignOpen", 'String'>
    readonly createdAt: FieldRef<"CampaignOpen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignOpen findUnique
   */
  export type CampaignOpenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOpen to fetch.
     */
    where: CampaignOpenWhereUniqueInput
  }

  /**
   * CampaignOpen findUniqueOrThrow
   */
  export type CampaignOpenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOpen to fetch.
     */
    where: CampaignOpenWhereUniqueInput
  }

  /**
   * CampaignOpen findFirst
   */
  export type CampaignOpenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOpen to fetch.
     */
    where?: CampaignOpenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOpens to fetch.
     */
    orderBy?: CampaignOpenOrderByWithRelationInput | CampaignOpenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignOpens.
     */
    cursor?: CampaignOpenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOpens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOpens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignOpens.
     */
    distinct?: CampaignOpenScalarFieldEnum | CampaignOpenScalarFieldEnum[]
  }

  /**
   * CampaignOpen findFirstOrThrow
   */
  export type CampaignOpenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOpen to fetch.
     */
    where?: CampaignOpenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOpens to fetch.
     */
    orderBy?: CampaignOpenOrderByWithRelationInput | CampaignOpenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignOpens.
     */
    cursor?: CampaignOpenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOpens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOpens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignOpens.
     */
    distinct?: CampaignOpenScalarFieldEnum | CampaignOpenScalarFieldEnum[]
  }

  /**
   * CampaignOpen findMany
   */
  export type CampaignOpenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * Filter, which CampaignOpens to fetch.
     */
    where?: CampaignOpenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignOpens to fetch.
     */
    orderBy?: CampaignOpenOrderByWithRelationInput | CampaignOpenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignOpens.
     */
    cursor?: CampaignOpenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignOpens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignOpens.
     */
    skip?: number
    distinct?: CampaignOpenScalarFieldEnum | CampaignOpenScalarFieldEnum[]
  }

  /**
   * CampaignOpen create
   */
  export type CampaignOpenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignOpen.
     */
    data: XOR<CampaignOpenCreateInput, CampaignOpenUncheckedCreateInput>
  }

  /**
   * CampaignOpen createMany
   */
  export type CampaignOpenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignOpens.
     */
    data: CampaignOpenCreateManyInput | CampaignOpenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignOpen createManyAndReturn
   */
  export type CampaignOpenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignOpens.
     */
    data: CampaignOpenCreateManyInput | CampaignOpenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignOpen update
   */
  export type CampaignOpenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignOpen.
     */
    data: XOR<CampaignOpenUpdateInput, CampaignOpenUncheckedUpdateInput>
    /**
     * Choose, which CampaignOpen to update.
     */
    where: CampaignOpenWhereUniqueInput
  }

  /**
   * CampaignOpen updateMany
   */
  export type CampaignOpenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignOpens.
     */
    data: XOR<CampaignOpenUpdateManyMutationInput, CampaignOpenUncheckedUpdateManyInput>
    /**
     * Filter which CampaignOpens to update
     */
    where?: CampaignOpenWhereInput
  }

  /**
   * CampaignOpen upsert
   */
  export type CampaignOpenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignOpen to update in case it exists.
     */
    where: CampaignOpenWhereUniqueInput
    /**
     * In case the CampaignOpen found by the `where` argument doesn't exist, create a new CampaignOpen with this data.
     */
    create: XOR<CampaignOpenCreateInput, CampaignOpenUncheckedCreateInput>
    /**
     * In case the CampaignOpen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignOpenUpdateInput, CampaignOpenUncheckedUpdateInput>
  }

  /**
   * CampaignOpen delete
   */
  export type CampaignOpenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
    /**
     * Filter which CampaignOpen to delete.
     */
    where: CampaignOpenWhereUniqueInput
  }

  /**
   * CampaignOpen deleteMany
   */
  export type CampaignOpenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignOpens to delete
     */
    where?: CampaignOpenWhereInput
  }

  /**
   * CampaignOpen without action
   */
  export type CampaignOpenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignOpen
     */
    select?: CampaignOpenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignOpenInclude<ExtArgs> | null
  }


  /**
   * Model CampaignClick
   */

  export type AggregateCampaignClick = {
    _count: CampaignClickCountAggregateOutputType | null
    _min: CampaignClickMinAggregateOutputType | null
    _max: CampaignClickMaxAggregateOutputType | null
  }

  export type CampaignClickMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    recipientEmail: string | null
    url: string | null
    createdAt: Date | null
  }

  export type CampaignClickMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    recipientEmail: string | null
    url: string | null
    createdAt: Date | null
  }

  export type CampaignClickCountAggregateOutputType = {
    id: number
    campaignId: number
    recipientEmail: number
    url: number
    createdAt: number
    _all: number
  }


  export type CampaignClickMinAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    url?: true
    createdAt?: true
  }

  export type CampaignClickMaxAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    url?: true
    createdAt?: true
  }

  export type CampaignClickCountAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    url?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignClickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignClick to aggregate.
     */
    where?: CampaignClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignClicks to fetch.
     */
    orderBy?: CampaignClickOrderByWithRelationInput | CampaignClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignClicks
    **/
    _count?: true | CampaignClickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignClickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignClickMaxAggregateInputType
  }

  export type GetCampaignClickAggregateType<T extends CampaignClickAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignClick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignClick[P]>
      : GetScalarType<T[P], AggregateCampaignClick[P]>
  }




  export type CampaignClickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignClickWhereInput
    orderBy?: CampaignClickOrderByWithAggregationInput | CampaignClickOrderByWithAggregationInput[]
    by: CampaignClickScalarFieldEnum[] | CampaignClickScalarFieldEnum
    having?: CampaignClickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignClickCountAggregateInputType | true
    _min?: CampaignClickMinAggregateInputType
    _max?: CampaignClickMaxAggregateInputType
  }

  export type CampaignClickGroupByOutputType = {
    id: string
    campaignId: string
    recipientEmail: string | null
    url: string | null
    createdAt: Date
    _count: CampaignClickCountAggregateOutputType | null
    _min: CampaignClickMinAggregateOutputType | null
    _max: CampaignClickMaxAggregateOutputType | null
  }

  type GetCampaignClickGroupByPayload<T extends CampaignClickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignClickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignClickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignClickGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignClickGroupByOutputType[P]>
        }
      >
    >


  export type CampaignClickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    url?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignClick"]>

  export type CampaignClickSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    url?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignClick"]>

  export type CampaignClickSelectScalar = {
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    url?: boolean
    createdAt?: boolean
  }

  export type CampaignClickInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignClickIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignClickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignClick"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      recipientEmail: string | null
      url: string | null
      createdAt: Date
    }, ExtArgs["result"]["campaignClick"]>
    composites: {}
  }

  type CampaignClickGetPayload<S extends boolean | null | undefined | CampaignClickDefaultArgs> = $Result.GetResult<Prisma.$CampaignClickPayload, S>

  type CampaignClickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignClickFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignClickCountAggregateInputType | true
    }

  export interface CampaignClickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignClick'], meta: { name: 'CampaignClick' } }
    /**
     * Find zero or one CampaignClick that matches the filter.
     * @param {CampaignClickFindUniqueArgs} args - Arguments to find a CampaignClick
     * @example
     * // Get one CampaignClick
     * const campaignClick = await prisma.campaignClick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignClickFindUniqueArgs>(args: SelectSubset<T, CampaignClickFindUniqueArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignClick that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignClickFindUniqueOrThrowArgs} args - Arguments to find a CampaignClick
     * @example
     * // Get one CampaignClick
     * const campaignClick = await prisma.campaignClick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignClickFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignClickFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignClick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignClickFindFirstArgs} args - Arguments to find a CampaignClick
     * @example
     * // Get one CampaignClick
     * const campaignClick = await prisma.campaignClick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignClickFindFirstArgs>(args?: SelectSubset<T, CampaignClickFindFirstArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignClick that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignClickFindFirstOrThrowArgs} args - Arguments to find a CampaignClick
     * @example
     * // Get one CampaignClick
     * const campaignClick = await prisma.campaignClick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignClickFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignClickFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignClicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignClickFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignClicks
     * const campaignClicks = await prisma.campaignClick.findMany()
     * 
     * // Get first 10 CampaignClicks
     * const campaignClicks = await prisma.campaignClick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignClickWithIdOnly = await prisma.campaignClick.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignClickFindManyArgs>(args?: SelectSubset<T, CampaignClickFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignClick.
     * @param {CampaignClickCreateArgs} args - Arguments to create a CampaignClick.
     * @example
     * // Create one CampaignClick
     * const CampaignClick = await prisma.campaignClick.create({
     *   data: {
     *     // ... data to create a CampaignClick
     *   }
     * })
     * 
     */
    create<T extends CampaignClickCreateArgs>(args: SelectSubset<T, CampaignClickCreateArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignClicks.
     * @param {CampaignClickCreateManyArgs} args - Arguments to create many CampaignClicks.
     * @example
     * // Create many CampaignClicks
     * const campaignClick = await prisma.campaignClick.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignClickCreateManyArgs>(args?: SelectSubset<T, CampaignClickCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignClicks and returns the data saved in the database.
     * @param {CampaignClickCreateManyAndReturnArgs} args - Arguments to create many CampaignClicks.
     * @example
     * // Create many CampaignClicks
     * const campaignClick = await prisma.campaignClick.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignClicks and only return the `id`
     * const campaignClickWithIdOnly = await prisma.campaignClick.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignClickCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignClickCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignClick.
     * @param {CampaignClickDeleteArgs} args - Arguments to delete one CampaignClick.
     * @example
     * // Delete one CampaignClick
     * const CampaignClick = await prisma.campaignClick.delete({
     *   where: {
     *     // ... filter to delete one CampaignClick
     *   }
     * })
     * 
     */
    delete<T extends CampaignClickDeleteArgs>(args: SelectSubset<T, CampaignClickDeleteArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignClick.
     * @param {CampaignClickUpdateArgs} args - Arguments to update one CampaignClick.
     * @example
     * // Update one CampaignClick
     * const campaignClick = await prisma.campaignClick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignClickUpdateArgs>(args: SelectSubset<T, CampaignClickUpdateArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignClicks.
     * @param {CampaignClickDeleteManyArgs} args - Arguments to filter CampaignClicks to delete.
     * @example
     * // Delete a few CampaignClicks
     * const { count } = await prisma.campaignClick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignClickDeleteManyArgs>(args?: SelectSubset<T, CampaignClickDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignClickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignClicks
     * const campaignClick = await prisma.campaignClick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignClickUpdateManyArgs>(args: SelectSubset<T, CampaignClickUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignClick.
     * @param {CampaignClickUpsertArgs} args - Arguments to update or create a CampaignClick.
     * @example
     * // Update or create a CampaignClick
     * const campaignClick = await prisma.campaignClick.upsert({
     *   create: {
     *     // ... data to create a CampaignClick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignClick we want to update
     *   }
     * })
     */
    upsert<T extends CampaignClickUpsertArgs>(args: SelectSubset<T, CampaignClickUpsertArgs<ExtArgs>>): Prisma__CampaignClickClient<$Result.GetResult<Prisma.$CampaignClickPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignClickCountArgs} args - Arguments to filter CampaignClicks to count.
     * @example
     * // Count the number of CampaignClicks
     * const count = await prisma.campaignClick.count({
     *   where: {
     *     // ... the filter for the CampaignClicks we want to count
     *   }
     * })
    **/
    count<T extends CampaignClickCountArgs>(
      args?: Subset<T, CampaignClickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignClickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignClickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignClickAggregateArgs>(args: Subset<T, CampaignClickAggregateArgs>): Prisma.PrismaPromise<GetCampaignClickAggregateType<T>>

    /**
     * Group by CampaignClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignClickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignClickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignClickGroupByArgs['orderBy'] }
        : { orderBy?: CampaignClickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignClickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignClickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignClick model
   */
  readonly fields: CampaignClickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignClick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignClick model
   */ 
  interface CampaignClickFieldRefs {
    readonly id: FieldRef<"CampaignClick", 'String'>
    readonly campaignId: FieldRef<"CampaignClick", 'String'>
    readonly recipientEmail: FieldRef<"CampaignClick", 'String'>
    readonly url: FieldRef<"CampaignClick", 'String'>
    readonly createdAt: FieldRef<"CampaignClick", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignClick findUnique
   */
  export type CampaignClickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * Filter, which CampaignClick to fetch.
     */
    where: CampaignClickWhereUniqueInput
  }

  /**
   * CampaignClick findUniqueOrThrow
   */
  export type CampaignClickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * Filter, which CampaignClick to fetch.
     */
    where: CampaignClickWhereUniqueInput
  }

  /**
   * CampaignClick findFirst
   */
  export type CampaignClickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * Filter, which CampaignClick to fetch.
     */
    where?: CampaignClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignClicks to fetch.
     */
    orderBy?: CampaignClickOrderByWithRelationInput | CampaignClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignClicks.
     */
    cursor?: CampaignClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignClicks.
     */
    distinct?: CampaignClickScalarFieldEnum | CampaignClickScalarFieldEnum[]
  }

  /**
   * CampaignClick findFirstOrThrow
   */
  export type CampaignClickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * Filter, which CampaignClick to fetch.
     */
    where?: CampaignClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignClicks to fetch.
     */
    orderBy?: CampaignClickOrderByWithRelationInput | CampaignClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignClicks.
     */
    cursor?: CampaignClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignClicks.
     */
    distinct?: CampaignClickScalarFieldEnum | CampaignClickScalarFieldEnum[]
  }

  /**
   * CampaignClick findMany
   */
  export type CampaignClickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * Filter, which CampaignClicks to fetch.
     */
    where?: CampaignClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignClicks to fetch.
     */
    orderBy?: CampaignClickOrderByWithRelationInput | CampaignClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignClicks.
     */
    cursor?: CampaignClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignClicks.
     */
    skip?: number
    distinct?: CampaignClickScalarFieldEnum | CampaignClickScalarFieldEnum[]
  }

  /**
   * CampaignClick create
   */
  export type CampaignClickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignClick.
     */
    data: XOR<CampaignClickCreateInput, CampaignClickUncheckedCreateInput>
  }

  /**
   * CampaignClick createMany
   */
  export type CampaignClickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignClicks.
     */
    data: CampaignClickCreateManyInput | CampaignClickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignClick createManyAndReturn
   */
  export type CampaignClickCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignClicks.
     */
    data: CampaignClickCreateManyInput | CampaignClickCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignClick update
   */
  export type CampaignClickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignClick.
     */
    data: XOR<CampaignClickUpdateInput, CampaignClickUncheckedUpdateInput>
    /**
     * Choose, which CampaignClick to update.
     */
    where: CampaignClickWhereUniqueInput
  }

  /**
   * CampaignClick updateMany
   */
  export type CampaignClickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignClicks.
     */
    data: XOR<CampaignClickUpdateManyMutationInput, CampaignClickUncheckedUpdateManyInput>
    /**
     * Filter which CampaignClicks to update
     */
    where?: CampaignClickWhereInput
  }

  /**
   * CampaignClick upsert
   */
  export type CampaignClickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignClick to update in case it exists.
     */
    where: CampaignClickWhereUniqueInput
    /**
     * In case the CampaignClick found by the `where` argument doesn't exist, create a new CampaignClick with this data.
     */
    create: XOR<CampaignClickCreateInput, CampaignClickUncheckedCreateInput>
    /**
     * In case the CampaignClick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignClickUpdateInput, CampaignClickUncheckedUpdateInput>
  }

  /**
   * CampaignClick delete
   */
  export type CampaignClickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
    /**
     * Filter which CampaignClick to delete.
     */
    where: CampaignClickWhereUniqueInput
  }

  /**
   * CampaignClick deleteMany
   */
  export type CampaignClickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignClicks to delete
     */
    where?: CampaignClickWhereInput
  }

  /**
   * CampaignClick without action
   */
  export type CampaignClickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignClick
     */
    select?: CampaignClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignClickInclude<ExtArgs> | null
  }


  /**
   * Model EmailLog
   */

  export type AggregateEmailLog = {
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  export type EmailLogMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    recipientEmail: string | null
    subject: string | null
    status: string | null
    error: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type EmailLogMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    recipientEmail: string | null
    subject: string | null
    status: string | null
    error: string | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type EmailLogCountAggregateOutputType = {
    id: number
    campaignId: number
    recipientEmail: number
    subject: number
    status: number
    error: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type EmailLogMinAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    subject?: true
    status?: true
    error?: true
    sentAt?: true
    createdAt?: true
  }

  export type EmailLogMaxAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    subject?: true
    status?: true
    error?: true
    sentAt?: true
    createdAt?: true
  }

  export type EmailLogCountAggregateInputType = {
    id?: true
    campaignId?: true
    recipientEmail?: true
    subject?: true
    status?: true
    error?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type EmailLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLog to aggregate.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLogs
    **/
    _count?: true | EmailLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLogMaxAggregateInputType
  }

  export type GetEmailLogAggregateType<T extends EmailLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLog[P]>
      : GetScalarType<T[P], AggregateEmailLog[P]>
  }




  export type EmailLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithAggregationInput | EmailLogOrderByWithAggregationInput[]
    by: EmailLogScalarFieldEnum[] | EmailLogScalarFieldEnum
    having?: EmailLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLogCountAggregateInputType | true
    _min?: EmailLogMinAggregateInputType
    _max?: EmailLogMaxAggregateInputType
  }

  export type EmailLogGroupByOutputType = {
    id: string
    campaignId: string | null
    recipientEmail: string
    subject: string
    status: string
    error: string | null
    sentAt: Date | null
    createdAt: Date
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  type GetEmailLogGroupByPayload<T extends EmailLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    subject?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    createdAt?: boolean
    campaign?: boolean | EmailLog$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    subject?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    createdAt?: boolean
    campaign?: boolean | EmailLog$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectScalar = {
    id?: boolean
    campaignId?: boolean
    recipientEmail?: boolean
    subject?: boolean
    status?: boolean
    error?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }

  export type EmailLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | EmailLog$campaignArgs<ExtArgs>
  }
  export type EmailLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | EmailLog$campaignArgs<ExtArgs>
  }

  export type $EmailLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLog"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string | null
      recipientEmail: string
      subject: string
      status: string
      error: string | null
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["emailLog"]>
    composites: {}
  }

  type EmailLogGetPayload<S extends boolean | null | undefined | EmailLogDefaultArgs> = $Result.GetResult<Prisma.$EmailLogPayload, S>

  type EmailLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailLogCountAggregateInputType | true
    }

  export interface EmailLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLog'], meta: { name: 'EmailLog' } }
    /**
     * Find zero or one EmailLog that matches the filter.
     * @param {EmailLogFindUniqueArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailLogFindUniqueArgs>(args: SelectSubset<T, EmailLogFindUniqueArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailLogFindUniqueOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailLogFindFirstArgs>(args?: SelectSubset<T, EmailLogFindFirstArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLogs
     * const emailLogs = await prisma.emailLog.findMany()
     * 
     * // Get first 10 EmailLogs
     * const emailLogs = await prisma.emailLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailLogFindManyArgs>(args?: SelectSubset<T, EmailLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailLog.
     * @param {EmailLogCreateArgs} args - Arguments to create a EmailLog.
     * @example
     * // Create one EmailLog
     * const EmailLog = await prisma.emailLog.create({
     *   data: {
     *     // ... data to create a EmailLog
     *   }
     * })
     * 
     */
    create<T extends EmailLogCreateArgs>(args: SelectSubset<T, EmailLogCreateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailLogs.
     * @param {EmailLogCreateManyArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailLogCreateManyArgs>(args?: SelectSubset<T, EmailLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailLogs and returns the data saved in the database.
     * @param {EmailLogCreateManyAndReturnArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailLogs and only return the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailLog.
     * @param {EmailLogDeleteArgs} args - Arguments to delete one EmailLog.
     * @example
     * // Delete one EmailLog
     * const EmailLog = await prisma.emailLog.delete({
     *   where: {
     *     // ... filter to delete one EmailLog
     *   }
     * })
     * 
     */
    delete<T extends EmailLogDeleteArgs>(args: SelectSubset<T, EmailLogDeleteArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailLog.
     * @param {EmailLogUpdateArgs} args - Arguments to update one EmailLog.
     * @example
     * // Update one EmailLog
     * const emailLog = await prisma.emailLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailLogUpdateArgs>(args: SelectSubset<T, EmailLogUpdateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailLogs.
     * @param {EmailLogDeleteManyArgs} args - Arguments to filter EmailLogs to delete.
     * @example
     * // Delete a few EmailLogs
     * const { count } = await prisma.emailLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailLogDeleteManyArgs>(args?: SelectSubset<T, EmailLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailLogUpdateManyArgs>(args: SelectSubset<T, EmailLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailLog.
     * @param {EmailLogUpsertArgs} args - Arguments to update or create a EmailLog.
     * @example
     * // Update or create a EmailLog
     * const emailLog = await prisma.emailLog.upsert({
     *   create: {
     *     // ... data to create a EmailLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailLogUpsertArgs>(args: SelectSubset<T, EmailLogUpsertArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogCountArgs} args - Arguments to filter EmailLogs to count.
     * @example
     * // Count the number of EmailLogs
     * const count = await prisma.emailLog.count({
     *   where: {
     *     // ... the filter for the EmailLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailLogCountArgs>(
      args?: Subset<T, EmailLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLogAggregateArgs>(args: Subset<T, EmailLogAggregateArgs>): Prisma.PrismaPromise<GetEmailLogAggregateType<T>>

    /**
     * Group by EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLog model
   */
  readonly fields: EmailLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends EmailLog$campaignArgs<ExtArgs> = {}>(args?: Subset<T, EmailLog$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailLog model
   */ 
  interface EmailLogFieldRefs {
    readonly id: FieldRef<"EmailLog", 'String'>
    readonly campaignId: FieldRef<"EmailLog", 'String'>
    readonly recipientEmail: FieldRef<"EmailLog", 'String'>
    readonly subject: FieldRef<"EmailLog", 'String'>
    readonly status: FieldRef<"EmailLog", 'String'>
    readonly error: FieldRef<"EmailLog", 'String'>
    readonly sentAt: FieldRef<"EmailLog", 'DateTime'>
    readonly createdAt: FieldRef<"EmailLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailLog findUnique
   */
  export type EmailLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findUniqueOrThrow
   */
  export type EmailLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findFirst
   */
  export type EmailLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findFirstOrThrow
   */
  export type EmailLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findMany
   */
  export type EmailLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLogs to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog create
   */
  export type EmailLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailLog.
     */
    data: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
  }

  /**
   * EmailLog createMany
   */
  export type EmailLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailLog createManyAndReturn
   */
  export type EmailLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailLog update
   */
  export type EmailLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailLog.
     */
    data: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
    /**
     * Choose, which EmailLog to update.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog updateMany
   */
  export type EmailLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog upsert
   */
  export type EmailLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailLog to update in case it exists.
     */
    where: EmailLogWhereUniqueInput
    /**
     * In case the EmailLog found by the `where` argument doesn't exist, create a new EmailLog with this data.
     */
    create: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
    /**
     * In case the EmailLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
  }

  /**
   * EmailLog delete
   */
  export type EmailLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter which EmailLog to delete.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog deleteMany
   */
  export type EmailLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLogs to delete
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog.campaign
   */
  export type EmailLog$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * EmailLog without action
   */
  export type EmailLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
  }


  /**
   * Model contact_messages
   */

  export type AggregateContact_messages = {
    _count: Contact_messagesCountAggregateOutputType | null
    _min: Contact_messagesMinAggregateOutputType | null
    _max: Contact_messagesMaxAggregateOutputType | null
  }

  export type Contact_messagesMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    company: string | null
    serviceType: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Contact_messagesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    company: string | null
    serviceType: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Contact_messagesCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    subject: number
    message: number
    company: number
    serviceType: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Contact_messagesMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    company?: true
    serviceType?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Contact_messagesMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    company?: true
    serviceType?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Contact_messagesCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    company?: true
    serviceType?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Contact_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact_messages to aggregate.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contact_messages
    **/
    _count?: true | Contact_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_messagesMaxAggregateInputType
  }

  export type GetContact_messagesAggregateType<T extends Contact_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_messages[P]>
      : GetScalarType<T[P], AggregateContact_messages[P]>
  }




  export type contact_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contact_messagesWhereInput
    orderBy?: contact_messagesOrderByWithAggregationInput | contact_messagesOrderByWithAggregationInput[]
    by: Contact_messagesScalarFieldEnum[] | Contact_messagesScalarFieldEnum
    having?: contact_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_messagesCountAggregateInputType | true
    _min?: Contact_messagesMinAggregateInputType
    _max?: Contact_messagesMaxAggregateInputType
  }

  export type Contact_messagesGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    subject: string
    message: string
    company: string | null
    serviceType: string | null
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: Contact_messagesCountAggregateOutputType | null
    _min: Contact_messagesMinAggregateOutputType | null
    _max: Contact_messagesMaxAggregateOutputType | null
  }

  type GetContact_messagesGroupByPayload<T extends contact_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_messagesGroupByOutputType[P]>
        }
      >
    >


  export type contact_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    company?: boolean
    serviceType?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact_messages"]>

  export type contact_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    company?: boolean
    serviceType?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact_messages"]>

  export type contact_messagesSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    company?: boolean
    serviceType?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $contact_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contact_messages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      subject: string
      message: string
      company: string | null
      serviceType: string | null
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact_messages"]>
    composites: {}
  }

  type contact_messagesGetPayload<S extends boolean | null | undefined | contact_messagesDefaultArgs> = $Result.GetResult<Prisma.$contact_messagesPayload, S>

  type contact_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contact_messagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Contact_messagesCountAggregateInputType | true
    }

  export interface contact_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contact_messages'], meta: { name: 'contact_messages' } }
    /**
     * Find zero or one Contact_messages that matches the filter.
     * @param {contact_messagesFindUniqueArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contact_messagesFindUniqueArgs>(args: SelectSubset<T, contact_messagesFindUniqueArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact_messages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {contact_messagesFindUniqueOrThrowArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contact_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, contact_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesFindFirstArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contact_messagesFindFirstArgs>(args?: SelectSubset<T, contact_messagesFindFirstArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesFindFirstOrThrowArgs} args - Arguments to find a Contact_messages
     * @example
     * // Get one Contact_messages
     * const contact_messages = await prisma.contact_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contact_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, contact_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contact_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_messages
     * const contact_messages = await prisma.contact_messages.findMany()
     * 
     * // Get first 10 Contact_messages
     * const contact_messages = await prisma.contact_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_messagesWithIdOnly = await prisma.contact_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contact_messagesFindManyArgs>(args?: SelectSubset<T, contact_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact_messages.
     * @param {contact_messagesCreateArgs} args - Arguments to create a Contact_messages.
     * @example
     * // Create one Contact_messages
     * const Contact_messages = await prisma.contact_messages.create({
     *   data: {
     *     // ... data to create a Contact_messages
     *   }
     * })
     * 
     */
    create<T extends contact_messagesCreateArgs>(args: SelectSubset<T, contact_messagesCreateArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contact_messages.
     * @param {contact_messagesCreateManyArgs} args - Arguments to create many Contact_messages.
     * @example
     * // Create many Contact_messages
     * const contact_messages = await prisma.contact_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contact_messagesCreateManyArgs>(args?: SelectSubset<T, contact_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_messages and returns the data saved in the database.
     * @param {contact_messagesCreateManyAndReturnArgs} args - Arguments to create many Contact_messages.
     * @example
     * // Create many Contact_messages
     * const contact_messages = await prisma.contact_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_messages and only return the `id`
     * const contact_messagesWithIdOnly = await prisma.contact_messages.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends contact_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, contact_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact_messages.
     * @param {contact_messagesDeleteArgs} args - Arguments to delete one Contact_messages.
     * @example
     * // Delete one Contact_messages
     * const Contact_messages = await prisma.contact_messages.delete({
     *   where: {
     *     // ... filter to delete one Contact_messages
     *   }
     * })
     * 
     */
    delete<T extends contact_messagesDeleteArgs>(args: SelectSubset<T, contact_messagesDeleteArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact_messages.
     * @param {contact_messagesUpdateArgs} args - Arguments to update one Contact_messages.
     * @example
     * // Update one Contact_messages
     * const contact_messages = await prisma.contact_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contact_messagesUpdateArgs>(args: SelectSubset<T, contact_messagesUpdateArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contact_messages.
     * @param {contact_messagesDeleteManyArgs} args - Arguments to filter Contact_messages to delete.
     * @example
     * // Delete a few Contact_messages
     * const { count } = await prisma.contact_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contact_messagesDeleteManyArgs>(args?: SelectSubset<T, contact_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_messages
     * const contact_messages = await prisma.contact_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contact_messagesUpdateManyArgs>(args: SelectSubset<T, contact_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_messages.
     * @param {contact_messagesUpsertArgs} args - Arguments to update or create a Contact_messages.
     * @example
     * // Update or create a Contact_messages
     * const contact_messages = await prisma.contact_messages.upsert({
     *   create: {
     *     // ... data to create a Contact_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_messages we want to update
     *   }
     * })
     */
    upsert<T extends contact_messagesUpsertArgs>(args: SelectSubset<T, contact_messagesUpsertArgs<ExtArgs>>): Prisma__contact_messagesClient<$Result.GetResult<Prisma.$contact_messagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesCountArgs} args - Arguments to filter Contact_messages to count.
     * @example
     * // Count the number of Contact_messages
     * const count = await prisma.contact_messages.count({
     *   where: {
     *     // ... the filter for the Contact_messages we want to count
     *   }
     * })
    **/
    count<T extends contact_messagesCountArgs>(
      args?: Subset<T, contact_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_messagesAggregateArgs>(args: Subset<T, Contact_messagesAggregateArgs>): Prisma.PrismaPromise<GetContact_messagesAggregateType<T>>

    /**
     * Group by Contact_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contact_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contact_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contact_messagesGroupByArgs['orderBy'] }
        : { orderBy?: contact_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contact_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contact_messages model
   */
  readonly fields: contact_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contact_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contact_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contact_messages model
   */ 
  interface contact_messagesFieldRefs {
    readonly id: FieldRef<"contact_messages", 'String'>
    readonly name: FieldRef<"contact_messages", 'String'>
    readonly email: FieldRef<"contact_messages", 'String'>
    readonly phone: FieldRef<"contact_messages", 'String'>
    readonly subject: FieldRef<"contact_messages", 'String'>
    readonly message: FieldRef<"contact_messages", 'String'>
    readonly company: FieldRef<"contact_messages", 'String'>
    readonly serviceType: FieldRef<"contact_messages", 'String'>
    readonly isRead: FieldRef<"contact_messages", 'Boolean'>
    readonly createdAt: FieldRef<"contact_messages", 'DateTime'>
    readonly updatedAt: FieldRef<"contact_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contact_messages findUnique
   */
  export type contact_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages findUniqueOrThrow
   */
  export type contact_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages findFirst
   */
  export type contact_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contact_messages.
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contact_messages.
     */
    distinct?: Contact_messagesScalarFieldEnum | Contact_messagesScalarFieldEnum[]
  }

  /**
   * contact_messages findFirstOrThrow
   */
  export type contact_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contact_messages.
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contact_messages.
     */
    distinct?: Contact_messagesScalarFieldEnum | Contact_messagesScalarFieldEnum[]
  }

  /**
   * contact_messages findMany
   */
  export type contact_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Filter, which contact_messages to fetch.
     */
    where?: contact_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contact_messages to fetch.
     */
    orderBy?: contact_messagesOrderByWithRelationInput | contact_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contact_messages.
     */
    cursor?: contact_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contact_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contact_messages.
     */
    skip?: number
    distinct?: Contact_messagesScalarFieldEnum | Contact_messagesScalarFieldEnum[]
  }

  /**
   * contact_messages create
   */
  export type contact_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * The data needed to create a contact_messages.
     */
    data: XOR<contact_messagesCreateInput, contact_messagesUncheckedCreateInput>
  }

  /**
   * contact_messages createMany
   */
  export type contact_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contact_messages.
     */
    data: contact_messagesCreateManyInput | contact_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contact_messages createManyAndReturn
   */
  export type contact_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many contact_messages.
     */
    data: contact_messagesCreateManyInput | contact_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contact_messages update
   */
  export type contact_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * The data needed to update a contact_messages.
     */
    data: XOR<contact_messagesUpdateInput, contact_messagesUncheckedUpdateInput>
    /**
     * Choose, which contact_messages to update.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages updateMany
   */
  export type contact_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contact_messages.
     */
    data: XOR<contact_messagesUpdateManyMutationInput, contact_messagesUncheckedUpdateManyInput>
    /**
     * Filter which contact_messages to update
     */
    where?: contact_messagesWhereInput
  }

  /**
   * contact_messages upsert
   */
  export type contact_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * The filter to search for the contact_messages to update in case it exists.
     */
    where: contact_messagesWhereUniqueInput
    /**
     * In case the contact_messages found by the `where` argument doesn't exist, create a new contact_messages with this data.
     */
    create: XOR<contact_messagesCreateInput, contact_messagesUncheckedCreateInput>
    /**
     * In case the contact_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contact_messagesUpdateInput, contact_messagesUncheckedUpdateInput>
  }

  /**
   * contact_messages delete
   */
  export type contact_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
    /**
     * Filter which contact_messages to delete.
     */
    where: contact_messagesWhereUniqueInput
  }

  /**
   * contact_messages deleteMany
   */
  export type contact_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact_messages to delete
     */
    where?: contact_messagesWhereInput
  }

  /**
   * contact_messages without action
   */
  export type contact_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact_messages
     */
    select?: contact_messagesSelect<ExtArgs> | null
  }


  /**
   * Model site_settings
   */

  export type AggregateSite_settings = {
    _count: Site_settingsCountAggregateOutputType | null
    _min: Site_settingsMinAggregateOutputType | null
    _max: Site_settingsMaxAggregateOutputType | null
  }

  export type Site_settingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Site_settingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Site_settingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Site_settingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Site_settingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Site_settingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Site_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which site_settings to aggregate.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned site_settings
    **/
    _count?: true | Site_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Site_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Site_settingsMaxAggregateInputType
  }

  export type GetSite_settingsAggregateType<T extends Site_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSite_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite_settings[P]>
      : GetScalarType<T[P], AggregateSite_settings[P]>
  }




  export type site_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: site_settingsWhereInput
    orderBy?: site_settingsOrderByWithAggregationInput | site_settingsOrderByWithAggregationInput[]
    by: Site_settingsScalarFieldEnum[] | Site_settingsScalarFieldEnum
    having?: site_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Site_settingsCountAggregateInputType | true
    _min?: Site_settingsMinAggregateInputType
    _max?: Site_settingsMaxAggregateInputType
  }

  export type Site_settingsGroupByOutputType = {
    id: string
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: Site_settingsCountAggregateOutputType | null
    _min: Site_settingsMinAggregateOutputType | null
    _max: Site_settingsMaxAggregateOutputType | null
  }

  type GetSite_settingsGroupByPayload<T extends site_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Site_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Site_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Site_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Site_settingsGroupByOutputType[P]>
        }
      >
    >


  export type site_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["site_settings"]>

  export type site_settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["site_settings"]>

  export type site_settingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $site_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "site_settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["site_settings"]>
    composites: {}
  }

  type site_settingsGetPayload<S extends boolean | null | undefined | site_settingsDefaultArgs> = $Result.GetResult<Prisma.$site_settingsPayload, S>

  type site_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<site_settingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Site_settingsCountAggregateInputType | true
    }

  export interface site_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['site_settings'], meta: { name: 'site_settings' } }
    /**
     * Find zero or one Site_settings that matches the filter.
     * @param {site_settingsFindUniqueArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends site_settingsFindUniqueArgs>(args: SelectSubset<T, site_settingsFindUniqueArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Site_settings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {site_settingsFindUniqueOrThrowArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends site_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, site_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Site_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsFindFirstArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends site_settingsFindFirstArgs>(args?: SelectSubset<T, site_settingsFindFirstArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Site_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsFindFirstOrThrowArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends site_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, site_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Site_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Site_settings
     * const site_settings = await prisma.site_settings.findMany()
     * 
     * // Get first 10 Site_settings
     * const site_settings = await prisma.site_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const site_settingsWithIdOnly = await prisma.site_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends site_settingsFindManyArgs>(args?: SelectSubset<T, site_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Site_settings.
     * @param {site_settingsCreateArgs} args - Arguments to create a Site_settings.
     * @example
     * // Create one Site_settings
     * const Site_settings = await prisma.site_settings.create({
     *   data: {
     *     // ... data to create a Site_settings
     *   }
     * })
     * 
     */
    create<T extends site_settingsCreateArgs>(args: SelectSubset<T, site_settingsCreateArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Site_settings.
     * @param {site_settingsCreateManyArgs} args - Arguments to create many Site_settings.
     * @example
     * // Create many Site_settings
     * const site_settings = await prisma.site_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends site_settingsCreateManyArgs>(args?: SelectSubset<T, site_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Site_settings and returns the data saved in the database.
     * @param {site_settingsCreateManyAndReturnArgs} args - Arguments to create many Site_settings.
     * @example
     * // Create many Site_settings
     * const site_settings = await prisma.site_settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Site_settings and only return the `id`
     * const site_settingsWithIdOnly = await prisma.site_settings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends site_settingsCreateManyAndReturnArgs>(args?: SelectSubset<T, site_settingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Site_settings.
     * @param {site_settingsDeleteArgs} args - Arguments to delete one Site_settings.
     * @example
     * // Delete one Site_settings
     * const Site_settings = await prisma.site_settings.delete({
     *   where: {
     *     // ... filter to delete one Site_settings
     *   }
     * })
     * 
     */
    delete<T extends site_settingsDeleteArgs>(args: SelectSubset<T, site_settingsDeleteArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Site_settings.
     * @param {site_settingsUpdateArgs} args - Arguments to update one Site_settings.
     * @example
     * // Update one Site_settings
     * const site_settings = await prisma.site_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends site_settingsUpdateArgs>(args: SelectSubset<T, site_settingsUpdateArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Site_settings.
     * @param {site_settingsDeleteManyArgs} args - Arguments to filter Site_settings to delete.
     * @example
     * // Delete a few Site_settings
     * const { count } = await prisma.site_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends site_settingsDeleteManyArgs>(args?: SelectSubset<T, site_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Site_settings
     * const site_settings = await prisma.site_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends site_settingsUpdateManyArgs>(args: SelectSubset<T, site_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Site_settings.
     * @param {site_settingsUpsertArgs} args - Arguments to update or create a Site_settings.
     * @example
     * // Update or create a Site_settings
     * const site_settings = await prisma.site_settings.upsert({
     *   create: {
     *     // ... data to create a Site_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site_settings we want to update
     *   }
     * })
     */
    upsert<T extends site_settingsUpsertArgs>(args: SelectSubset<T, site_settingsUpsertArgs<ExtArgs>>): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsCountArgs} args - Arguments to filter Site_settings to count.
     * @example
     * // Count the number of Site_settings
     * const count = await prisma.site_settings.count({
     *   where: {
     *     // ... the filter for the Site_settings we want to count
     *   }
     * })
    **/
    count<T extends site_settingsCountArgs>(
      args?: Subset<T, site_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Site_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Site_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Site_settingsAggregateArgs>(args: Subset<T, Site_settingsAggregateArgs>): Prisma.PrismaPromise<GetSite_settingsAggregateType<T>>

    /**
     * Group by Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends site_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: site_settingsGroupByArgs['orderBy'] }
        : { orderBy?: site_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, site_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSite_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the site_settings model
   */
  readonly fields: site_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for site_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__site_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the site_settings model
   */ 
  interface site_settingsFieldRefs {
    readonly id: FieldRef<"site_settings", 'String'>
    readonly key: FieldRef<"site_settings", 'String'>
    readonly value: FieldRef<"site_settings", 'String'>
    readonly createdAt: FieldRef<"site_settings", 'DateTime'>
    readonly updatedAt: FieldRef<"site_settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * site_settings findUnique
   */
  export type site_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where: site_settingsWhereUniqueInput
  }

  /**
   * site_settings findUniqueOrThrow
   */
  export type site_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where: site_settingsWhereUniqueInput
  }

  /**
   * site_settings findFirst
   */
  export type site_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for site_settings.
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of site_settings.
     */
    distinct?: Site_settingsScalarFieldEnum | Site_settingsScalarFieldEnum[]
  }

  /**
   * site_settings findFirstOrThrow
   */
  export type site_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for site_settings.
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of site_settings.
     */
    distinct?: Site_settingsScalarFieldEnum | Site_settingsScalarFieldEnum[]
  }

  /**
   * site_settings findMany
   */
  export type site_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing site_settings.
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    distinct?: Site_settingsScalarFieldEnum | Site_settingsScalarFieldEnum[]
  }

  /**
   * site_settings create
   */
  export type site_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * The data needed to create a site_settings.
     */
    data: XOR<site_settingsCreateInput, site_settingsUncheckedCreateInput>
  }

  /**
   * site_settings createMany
   */
  export type site_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many site_settings.
     */
    data: site_settingsCreateManyInput | site_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * site_settings createManyAndReturn
   */
  export type site_settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many site_settings.
     */
    data: site_settingsCreateManyInput | site_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * site_settings update
   */
  export type site_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * The data needed to update a site_settings.
     */
    data: XOR<site_settingsUpdateInput, site_settingsUncheckedUpdateInput>
    /**
     * Choose, which site_settings to update.
     */
    where: site_settingsWhereUniqueInput
  }

  /**
   * site_settings updateMany
   */
  export type site_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update site_settings.
     */
    data: XOR<site_settingsUpdateManyMutationInput, site_settingsUncheckedUpdateManyInput>
    /**
     * Filter which site_settings to update
     */
    where?: site_settingsWhereInput
  }

  /**
   * site_settings upsert
   */
  export type site_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * The filter to search for the site_settings to update in case it exists.
     */
    where: site_settingsWhereUniqueInput
    /**
     * In case the site_settings found by the `where` argument doesn't exist, create a new site_settings with this data.
     */
    create: XOR<site_settingsCreateInput, site_settingsUncheckedCreateInput>
    /**
     * In case the site_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<site_settingsUpdateInput, site_settingsUncheckedUpdateInput>
  }

  /**
   * site_settings delete
   */
  export type site_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter which site_settings to delete.
     */
    where: site_settingsWhereUniqueInput
  }

  /**
   * site_settings deleteMany
   */
  export type site_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which site_settings to delete
     */
    where?: site_settingsWhereInput
  }

  /**
   * site_settings without action
   */
  export type site_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
  }


  /**
   * Model software
   */

  export type AggregateSoftware = {
    _count: SoftwareCountAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  export type SoftwareMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    category: string | null
    platform: string | null
    version: string | null
    downloadUrl: string | null
    websiteUrl: string | null
    imageUrl: string | null
    features: string | null
    isActive: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SoftwareMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    category: string | null
    platform: string | null
    version: string | null
    downloadUrl: string | null
    websiteUrl: string | null
    imageUrl: string | null
    features: string | null
    isActive: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SoftwareCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    category: number
    platform: number
    version: number
    downloadUrl: number
    websiteUrl: number
    imageUrl: number
    features: number
    isActive: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SoftwareMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    category?: true
    platform?: true
    version?: true
    downloadUrl?: true
    websiteUrl?: true
    imageUrl?: true
    features?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SoftwareMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    category?: true
    platform?: true
    version?: true
    downloadUrl?: true
    websiteUrl?: true
    imageUrl?: true
    features?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SoftwareCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    category?: true
    platform?: true
    version?: true
    downloadUrl?: true
    websiteUrl?: true
    imageUrl?: true
    features?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SoftwareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which software to aggregate.
     */
    where?: softwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of software to fetch.
     */
    orderBy?: softwareOrderByWithRelationInput | softwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: softwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned software
    **/
    _count?: true | SoftwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoftwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoftwareMaxAggregateInputType
  }

  export type GetSoftwareAggregateType<T extends SoftwareAggregateArgs> = {
        [P in keyof T & keyof AggregateSoftware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoftware[P]>
      : GetScalarType<T[P], AggregateSoftware[P]>
  }




  export type softwareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: softwareWhereInput
    orderBy?: softwareOrderByWithAggregationInput | softwareOrderByWithAggregationInput[]
    by: SoftwareScalarFieldEnum[] | SoftwareScalarFieldEnum
    having?: softwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoftwareCountAggregateInputType | true
    _min?: SoftwareMinAggregateInputType
    _max?: SoftwareMaxAggregateInputType
  }

  export type SoftwareGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    category: string
    platform: string
    version: string | null
    downloadUrl: string | null
    websiteUrl: string | null
    imageUrl: string | null
    features: string | null
    isActive: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SoftwareCountAggregateOutputType | null
    _min: SoftwareMinAggregateOutputType | null
    _max: SoftwareMaxAggregateOutputType | null
  }

  type GetSoftwareGroupByPayload<T extends softwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoftwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoftwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
            : GetScalarType<T[P], SoftwareGroupByOutputType[P]>
        }
      >
    >


  export type softwareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    category?: boolean
    platform?: boolean
    version?: boolean
    downloadUrl?: boolean
    websiteUrl?: boolean
    imageUrl?: boolean
    features?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["software"]>

  export type softwareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    category?: boolean
    platform?: boolean
    version?: boolean
    downloadUrl?: boolean
    websiteUrl?: boolean
    imageUrl?: boolean
    features?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["software"]>

  export type softwareSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    category?: boolean
    platform?: boolean
    version?: boolean
    downloadUrl?: boolean
    websiteUrl?: boolean
    imageUrl?: boolean
    features?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $softwarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "software"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      category: string
      platform: string
      version: string | null
      downloadUrl: string | null
      websiteUrl: string | null
      imageUrl: string | null
      features: string | null
      isActive: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["software"]>
    composites: {}
  }

  type softwareGetPayload<S extends boolean | null | undefined | softwareDefaultArgs> = $Result.GetResult<Prisma.$softwarePayload, S>

  type softwareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<softwareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoftwareCountAggregateInputType | true
    }

  export interface softwareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['software'], meta: { name: 'software' } }
    /**
     * Find zero or one Software that matches the filter.
     * @param {softwareFindUniqueArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends softwareFindUniqueArgs>(args: SelectSubset<T, softwareFindUniqueArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Software that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {softwareFindUniqueOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends softwareFindUniqueOrThrowArgs>(args: SelectSubset<T, softwareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwareFindFirstArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends softwareFindFirstArgs>(args?: SelectSubset<T, softwareFindFirstArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Software that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwareFindFirstOrThrowArgs} args - Arguments to find a Software
     * @example
     * // Get one Software
     * const software = await prisma.software.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends softwareFindFirstOrThrowArgs>(args?: SelectSubset<T, softwareFindFirstOrThrowArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Software that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Software
     * const software = await prisma.software.findMany()
     * 
     * // Get first 10 Software
     * const software = await prisma.software.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const softwareWithIdOnly = await prisma.software.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends softwareFindManyArgs>(args?: SelectSubset<T, softwareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Software.
     * @param {softwareCreateArgs} args - Arguments to create a Software.
     * @example
     * // Create one Software
     * const Software = await prisma.software.create({
     *   data: {
     *     // ... data to create a Software
     *   }
     * })
     * 
     */
    create<T extends softwareCreateArgs>(args: SelectSubset<T, softwareCreateArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Software.
     * @param {softwareCreateManyArgs} args - Arguments to create many Software.
     * @example
     * // Create many Software
     * const software = await prisma.software.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends softwareCreateManyArgs>(args?: SelectSubset<T, softwareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Software and returns the data saved in the database.
     * @param {softwareCreateManyAndReturnArgs} args - Arguments to create many Software.
     * @example
     * // Create many Software
     * const software = await prisma.software.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Software and only return the `id`
     * const softwareWithIdOnly = await prisma.software.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends softwareCreateManyAndReturnArgs>(args?: SelectSubset<T, softwareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Software.
     * @param {softwareDeleteArgs} args - Arguments to delete one Software.
     * @example
     * // Delete one Software
     * const Software = await prisma.software.delete({
     *   where: {
     *     // ... filter to delete one Software
     *   }
     * })
     * 
     */
    delete<T extends softwareDeleteArgs>(args: SelectSubset<T, softwareDeleteArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Software.
     * @param {softwareUpdateArgs} args - Arguments to update one Software.
     * @example
     * // Update one Software
     * const software = await prisma.software.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends softwareUpdateArgs>(args: SelectSubset<T, softwareUpdateArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Software.
     * @param {softwareDeleteManyArgs} args - Arguments to filter Software to delete.
     * @example
     * // Delete a few Software
     * const { count } = await prisma.software.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends softwareDeleteManyArgs>(args?: SelectSubset<T, softwareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Software
     * const software = await prisma.software.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends softwareUpdateManyArgs>(args: SelectSubset<T, softwareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Software.
     * @param {softwareUpsertArgs} args - Arguments to update or create a Software.
     * @example
     * // Update or create a Software
     * const software = await prisma.software.upsert({
     *   create: {
     *     // ... data to create a Software
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Software we want to update
     *   }
     * })
     */
    upsert<T extends softwareUpsertArgs>(args: SelectSubset<T, softwareUpsertArgs<ExtArgs>>): Prisma__softwareClient<$Result.GetResult<Prisma.$softwarePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwareCountArgs} args - Arguments to filter Software to count.
     * @example
     * // Count the number of Software
     * const count = await prisma.software.count({
     *   where: {
     *     // ... the filter for the Software we want to count
     *   }
     * })
    **/
    count<T extends softwareCountArgs>(
      args?: Subset<T, softwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoftwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoftwareAggregateArgs>(args: Subset<T, SoftwareAggregateArgs>): Prisma.PrismaPromise<GetSoftwareAggregateType<T>>

    /**
     * Group by Software.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends softwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: softwareGroupByArgs['orderBy'] }
        : { orderBy?: softwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, softwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoftwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the software model
   */
  readonly fields: softwareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for software.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__softwareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the software model
   */ 
  interface softwareFieldRefs {
    readonly id: FieldRef<"software", 'String'>
    readonly name: FieldRef<"software", 'String'>
    readonly slug: FieldRef<"software", 'String'>
    readonly description: FieldRef<"software", 'String'>
    readonly category: FieldRef<"software", 'String'>
    readonly platform: FieldRef<"software", 'String'>
    readonly version: FieldRef<"software", 'String'>
    readonly downloadUrl: FieldRef<"software", 'String'>
    readonly websiteUrl: FieldRef<"software", 'String'>
    readonly imageUrl: FieldRef<"software", 'String'>
    readonly features: FieldRef<"software", 'String'>
    readonly isActive: FieldRef<"software", 'Boolean'>
    readonly isDeleted: FieldRef<"software", 'Boolean'>
    readonly createdAt: FieldRef<"software", 'DateTime'>
    readonly updatedAt: FieldRef<"software", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * software findUnique
   */
  export type softwareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * Filter, which software to fetch.
     */
    where: softwareWhereUniqueInput
  }

  /**
   * software findUniqueOrThrow
   */
  export type softwareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * Filter, which software to fetch.
     */
    where: softwareWhereUniqueInput
  }

  /**
   * software findFirst
   */
  export type softwareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * Filter, which software to fetch.
     */
    where?: softwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of software to fetch.
     */
    orderBy?: softwareOrderByWithRelationInput | softwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for software.
     */
    cursor?: softwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * software findFirstOrThrow
   */
  export type softwareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * Filter, which software to fetch.
     */
    where?: softwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of software to fetch.
     */
    orderBy?: softwareOrderByWithRelationInput | softwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for software.
     */
    cursor?: softwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` software.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of software.
     */
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * software findMany
   */
  export type softwareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * Filter, which software to fetch.
     */
    where?: softwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of software to fetch.
     */
    orderBy?: softwareOrderByWithRelationInput | softwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing software.
     */
    cursor?: softwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` software from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` software.
     */
    skip?: number
    distinct?: SoftwareScalarFieldEnum | SoftwareScalarFieldEnum[]
  }

  /**
   * software create
   */
  export type softwareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * The data needed to create a software.
     */
    data: XOR<softwareCreateInput, softwareUncheckedCreateInput>
  }

  /**
   * software createMany
   */
  export type softwareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many software.
     */
    data: softwareCreateManyInput | softwareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * software createManyAndReturn
   */
  export type softwareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many software.
     */
    data: softwareCreateManyInput | softwareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * software update
   */
  export type softwareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * The data needed to update a software.
     */
    data: XOR<softwareUpdateInput, softwareUncheckedUpdateInput>
    /**
     * Choose, which software to update.
     */
    where: softwareWhereUniqueInput
  }

  /**
   * software updateMany
   */
  export type softwareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update software.
     */
    data: XOR<softwareUpdateManyMutationInput, softwareUncheckedUpdateManyInput>
    /**
     * Filter which software to update
     */
    where?: softwareWhereInput
  }

  /**
   * software upsert
   */
  export type softwareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * The filter to search for the software to update in case it exists.
     */
    where: softwareWhereUniqueInput
    /**
     * In case the software found by the `where` argument doesn't exist, create a new software with this data.
     */
    create: XOR<softwareCreateInput, softwareUncheckedCreateInput>
    /**
     * In case the software was found with the provided `where` argument, update it with this data.
     */
    update: XOR<softwareUpdateInput, softwareUncheckedUpdateInput>
  }

  /**
   * software delete
   */
  export type softwareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
    /**
     * Filter which software to delete.
     */
    where: softwareWhereUniqueInput
  }

  /**
   * software deleteMany
   */
  export type softwareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which software to delete
     */
    where?: softwareWhereInput
  }

  /**
   * software without action
   */
  export type softwareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the software
     */
    select?: softwareSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    shortDescription: 'shortDescription',
    priceCents: 'priceCents',
    originalPriceCents: 'originalPriceCents',
    imageUrl: 'imageUrl',
    images: 'images',
    categoryId: 'categoryId',
    brand: 'brand',
    model: 'model',
    sku: 'sku',
    specifications: 'specifications',
    features: 'features',
    warranty: 'warranty',
    weight: 'weight',
    dimensions: 'dimensions',
    stockQuantity: 'stockQuantity',
    minOrderQuantity: 'minOrderQuantity',
    maxOrderQuantity: 'maxOrderQuantity',
    maxStock: 'maxStock',
    tags: 'tags',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords',
    canonicalUrl: 'canonicalUrl',
    featured: 'featured',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    viewCount: 'viewCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    parentId: 'parentId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    canonicalUrl: 'canonicalUrl',
    description: 'description',
    imageUrl: 'imageUrl',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords',
    metaTitle: 'metaTitle'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    guestId: 'guestId',
    status: 'status',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    userId: 'userId',
    subtotalCents: 'subtotalCents',
    discountCents: 'discountCents',
    shippingCents: 'shippingCents',
    totalCents: 'totalCents',
    status: 'status',
    shippingAddress: 'shippingAddress',
    shippingCoordinates: 'shippingCoordinates',
    promotionCode: 'promotionCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    name: 'name',
    unitPrice: 'unitPrice',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    intentId: 'intentId',
    provider: 'provider',
    amountCents: 'amountCents',
    status: 'status',
    transactionId: 'transactionId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    amountCents: 'amountCents',
    reason: 'reason',
    status: 'status',
    providerRefundId: 'providerRefundId',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    errorMessage: 'errorMessage'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const ServiceTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    color: 'color',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTypeScalarFieldEnum = (typeof ServiceTypeScalarFieldEnum)[keyof typeof ServiceTypeScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    shortDescription: 'shortDescription',
    basePriceCents: 'basePriceCents',
    price: 'price',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    priceType: 'priceType',
    duration: 'duration',
    typeId: 'typeId',
    images: 'images',
    isActive: 'isActive',
    isFeatured: 'isFeatured',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription',
    type: 'type',
    tags: 'tags',
    features: 'features',
    requirements: 'requirements',
    metadata: 'metadata',
    viewCount: 'viewCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    stock: 'stock',
    reserved: 'reserved',
    lowStockThreshold: 'lowStockThreshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    type: 'type',
    quantity: 'quantity',
    previousStock: 'previousStock',
    newStock: 'newStock',
    reason: 'reason',
    referenceId: 'referenceId',
    referenceType: 'referenceType',
    userId: 'userId',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const InventoryAlertScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    type: 'type',
    message: 'message',
    threshold: 'threshold',
    currentStock: 'currentStock',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryAlertScalarFieldEnum = (typeof InventoryAlertScalarFieldEnum)[keyof typeof InventoryAlertScalarFieldEnum]


  export const InventoryReportScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    description: 'description',
    parameters: 'parameters',
    data: 'data',
    generatedBy: 'generatedBy',
    generatedAt: 'generatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryReportScalarFieldEnum = (typeof InventoryReportScalarFieldEnum)[keyof typeof InventoryReportScalarFieldEnum]


  export const WishlistItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    createdAt: 'createdAt'
  };

  export type WishlistItemScalarFieldEnum = (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum]


  export const ProductReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    rating: 'rating',
    title: 'title',
    comment: 'comment',
    isVerified: 'isVerified',
    status: 'status',
    upvotes: 'upvotes',
    downvotes: 'downvotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductReviewScalarFieldEnum = (typeof ProductReviewScalarFieldEnum)[keyof typeof ProductReviewScalarFieldEnum]


  export const ProductReviewVoteScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    isUpvote: 'isUpvote',
    createdAt: 'createdAt'
  };

  export type ProductReviewVoteScalarFieldEnum = (typeof ProductReviewVoteScalarFieldEnum)[keyof typeof ProductReviewVoteScalarFieldEnum]


  export const ProductReviewReportScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ProductReviewReportScalarFieldEnum = (typeof ProductReviewReportScalarFieldEnum)[keyof typeof ProductReviewReportScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    content: 'content',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const SearchQueryScalarFieldEnum: {
    id: 'id',
    query: 'query',
    userId: 'userId',
    timestamp: 'timestamp'
  };

  export type SearchQueryScalarFieldEnum = (typeof SearchQueryScalarFieldEnum)[keyof typeof SearchQueryScalarFieldEnum]


  export const ProductViewScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    userId: 'userId',
    timestamp: 'timestamp',
    duration: 'duration'
  };

  export type ProductViewScalarFieldEnum = (typeof ProductViewScalarFieldEnum)[keyof typeof ProductViewScalarFieldEnum]


  export const ServiceViewScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    userId: 'userId',
    timestamp: 'timestamp',
    duration: 'duration'
  };

  export type ServiceViewScalarFieldEnum = (typeof ServiceViewScalarFieldEnum)[keyof typeof ServiceViewScalarFieldEnum]


  export const CustomerQuestionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    question: 'question',
    category: 'category',
    satisfaction: 'satisfaction',
    timestamp: 'timestamp'
  };

  export type CustomerQuestionScalarFieldEnum = (typeof CustomerQuestionScalarFieldEnum)[keyof typeof CustomerQuestionScalarFieldEnum]


  export const TechnicianScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    specialties: 'specialties',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type TechnicianScalarFieldEnum = (typeof TechnicianScalarFieldEnum)[keyof typeof TechnicianScalarFieldEnum]


  export const ServiceItemScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    name: 'name',
    price: 'price',
    quantity: 'quantity',
    createdAt: 'createdAt'
  };

  export type ServiceItemScalarFieldEnum = (typeof ServiceItemScalarFieldEnum)[keyof typeof ServiceItemScalarFieldEnum]


  export const ServiceBookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    technicianId: 'technicianId',
    status: 'status',
    scheduledAt: 'scheduledAt',
    scheduledTime: 'scheduledTime',
    completedAt: 'completedAt',
    notes: 'notes',
    estimatedCosts: 'estimatedCosts',
    actualCosts: 'actualCosts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceBookingScalarFieldEnum = (typeof ServiceBookingScalarFieldEnum)[keyof typeof ServiceBookingScalarFieldEnum]


  export const ServiceBookingItemScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    serviceItemId: 'serviceItemId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type ServiceBookingItemScalarFieldEnum = (typeof ServiceBookingItemScalarFieldEnum)[keyof typeof ServiceBookingItemScalarFieldEnum]


  export const TechnicianScheduleScalarFieldEnum: {
    id: 'id',
    technicianId: 'technicianId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    isAvailable: 'isAvailable',
    createdAt: 'createdAt'
  };

  export type TechnicianScheduleScalarFieldEnum = (typeof TechnicianScheduleScalarFieldEnum)[keyof typeof TechnicianScheduleScalarFieldEnum]


  export const ServiceStatusHistoryScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    status: 'status',
    newStatus: 'newStatus',
    note: 'note',
    changedBy: 'changedBy',
    createdAt: 'createdAt'
  };

  export type ServiceStatusHistoryScalarFieldEnum = (typeof ServiceStatusHistoryScalarFieldEnum)[keyof typeof ServiceStatusHistoryScalarFieldEnum]


  export const ServicePaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    provider: 'provider',
    amountCents: 'amountCents',
    status: 'status',
    transactionId: 'transactionId',
    paidAt: 'paidAt',
    createdAt: 'createdAt'
  };

  export type ServicePaymentScalarFieldEnum = (typeof ServicePaymentScalarFieldEnum)[keyof typeof ServicePaymentScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    type: 'type',
    value: 'value',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    imageUrl: 'imageUrl',
    mobileImageUrl: 'mobileImageUrl',
    linkUrl: 'linkUrl',
    buttonLabel: 'buttonLabel',
    page: 'page',
    locale: 'locale',
    position: 'position',
    isActive: 'isActive',
    startAt: 'startAt',
    endAt: 'endAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const LoyaltyAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    points: 'points',
    tier: 'tier',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyAccountScalarFieldEnum = (typeof LoyaltyAccountScalarFieldEnum)[keyof typeof LoyaltyAccountScalarFieldEnum]


  export const PointTransactionScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    amount: 'amount',
    type: 'type',
    description: 'description',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PointTransactionScalarFieldEnum = (typeof PointTransactionScalarFieldEnum)[keyof typeof PointTransactionScalarFieldEnum]


  export const RedemptionHistoryScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    rewardId: 'rewardId',
    pointsUsed: 'pointsUsed',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type RedemptionHistoryScalarFieldEnum = (typeof RedemptionHistoryScalarFieldEnum)[keyof typeof RedemptionHistoryScalarFieldEnum]


  export const LoyaltyRewardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    pointsCost: 'pointsCost',
    value: 'value',
    type: 'type',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type LoyaltyRewardScalarFieldEnum = (typeof LoyaltyRewardScalarFieldEnum)[keyof typeof LoyaltyRewardScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    url: 'url',
    secret: 'secret',
    events: 'events',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const KnowledgeBaseEntryScalarFieldEnum: {
    id: 'id',
    kind: 'kind',
    title: 'title',
    content: 'content',
    productId: 'productId',
    tags: 'tags',
    embedding: 'embedding',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeBaseEntryScalarFieldEnum = (typeof KnowledgeBaseEntryScalarFieldEnum)[keyof typeof KnowledgeBaseEntryScalarFieldEnum]


  export const PaymentIntentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    provider: 'provider',
    amountCents: 'amountCents',
    status: 'status',
    clientSecret: 'clientSecret',
    returnUrl: 'returnUrl',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentIntentScalarFieldEnum = (typeof PaymentIntentScalarFieldEnum)[keyof typeof PaymentIntentScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    shortDescription: 'shortDescription',
    client: 'client',
    clientLogo: 'clientLogo',
    category: 'category',
    technologies: 'technologies',
    features: 'features',
    images: 'images',
    thumbnailImage: 'thumbnailImage',
    coverImage: 'coverImage',
    youtubeVideoId: 'youtubeVideoId',
    youtubeVideoUrl: 'youtubeVideoUrl',
    demoUrl: 'demoUrl',
    githubUrl: 'githubUrl',
    liveUrl: 'liveUrl',
    startDate: 'startDate',
    endDate: 'endDate',
    duration: 'duration',
    teamSize: 'teamSize',
    budget: 'budget',
    status: 'status',
    isActive: 'isActive',
    isFeatured: 'isFeatured',
    displayOrder: 'displayOrder',
    viewCount: 'viewCount',
    userId: 'userId',
    tags: 'tags',
    testimonial: 'testimonial',
    results: 'results',
    challenges: 'challenges',
    solutions: 'solutions',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords',
    ogTitle: 'ogTitle',
    ogDescription: 'ogDescription',
    ogImage: 'ogImage',
    structuredData: 'structuredData',
    canonicalUrl: 'canonicalUrl',
    content: 'content',
    galleryImages: 'galleryImages',
    clientLogoUrl: 'clientLogoUrl',
    projectDate: 'projectDate',
    completionDate: 'completionDate',
    featured: 'featured',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    method: 'method',
    url: 'url',
    statusCode: 'statusCode',
    duration: 'duration',
    category: 'category',
    severity: 'severity',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    status: 'status',
    targetAudience: 'targetAudience',
    discountPercent: 'discountPercent',
    discountAmount: 'discountAmount',
    startDate: 'startDate',
    endDate: 'endDate',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignRecipientScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    email: 'email',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type CampaignRecipientScalarFieldEnum = (typeof CampaignRecipientScalarFieldEnum)[keyof typeof CampaignRecipientScalarFieldEnum]


  export const CampaignOpenScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    recipientEmail: 'recipientEmail',
    createdAt: 'createdAt'
  };

  export type CampaignOpenScalarFieldEnum = (typeof CampaignOpenScalarFieldEnum)[keyof typeof CampaignOpenScalarFieldEnum]


  export const CampaignClickScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    recipientEmail: 'recipientEmail',
    url: 'url',
    createdAt: 'createdAt'
  };

  export type CampaignClickScalarFieldEnum = (typeof CampaignClickScalarFieldEnum)[keyof typeof CampaignClickScalarFieldEnum]


  export const EmailLogScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    recipientEmail: 'recipientEmail',
    subject: 'subject',
    status: 'status',
    error: 'error',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type EmailLogScalarFieldEnum = (typeof EmailLogScalarFieldEnum)[keyof typeof EmailLogScalarFieldEnum]


  export const Contact_messagesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    company: 'company',
    serviceType: 'serviceType',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Contact_messagesScalarFieldEnum = (typeof Contact_messagesScalarFieldEnum)[keyof typeof Contact_messagesScalarFieldEnum]


  export const Site_settingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Site_settingsScalarFieldEnum = (typeof Site_settingsScalarFieldEnum)[keyof typeof Site_settingsScalarFieldEnum]


  export const SoftwareScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    category: 'category',
    platform: 'platform',
    version: 'version',
    downloadUrl: 'downloadUrl',
    websiteUrl: 'websiteUrl',
    imageUrl: 'imageUrl',
    features: 'features',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SoftwareScalarFieldEnum = (typeof SoftwareScalarFieldEnum)[keyof typeof SoftwareScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus[]'>
    


  /**
   * Reference to a field of type 'CampaignType'
   */
  export type EnumCampaignTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignType'>
    


  /**
   * Reference to a field of type 'CampaignType[]'
   */
  export type ListEnumCampaignTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignType[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activityLogs?: ActivityLogListRelationFilter
    carts?: CartListRelationFilter
    questions?: CustomerQuestionListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    loyaltyAccount?: XOR<LoyaltyAccountNullableRelationFilter, LoyaltyAccountWhereInput> | null
    notifications?: NotificationListRelationFilter
    orders?: OrderListRelationFilter
    reviews?: ProductReviewListRelationFilter
    productViews?: ProductViewListRelationFilter
    projects?: ProjectListRelationFilter
    searchQueries?: SearchQueryListRelationFilter
    ServiceBooking?: ServiceBookingListRelationFilter
    serviceViews?: ServiceViewListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    carts?: CartOrderByRelationAggregateInput
    questions?: CustomerQuestionOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    loyaltyAccount?: LoyaltyAccountOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    reviews?: ProductReviewOrderByRelationAggregateInput
    productViews?: ProductViewOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    searchQueries?: SearchQueryOrderByRelationAggregateInput
    ServiceBooking?: ServiceBookingOrderByRelationAggregateInput
    serviceViews?: ServiceViewOrderByRelationAggregateInput
    wishlistItems?: WishlistItemOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    activityLogs?: ActivityLogListRelationFilter
    carts?: CartListRelationFilter
    questions?: CustomerQuestionListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    loyaltyAccount?: XOR<LoyaltyAccountNullableRelationFilter, LoyaltyAccountWhereInput> | null
    notifications?: NotificationListRelationFilter
    orders?: OrderListRelationFilter
    reviews?: ProductReviewListRelationFilter
    productViews?: ProductViewListRelationFilter
    projects?: ProjectListRelationFilter
    searchQueries?: SearchQueryListRelationFilter
    ServiceBooking?: ServiceBookingListRelationFilter
    serviceViews?: ServiceViewListRelationFilter
    wishlistItems?: WishlistItemListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    shortDescription?: StringNullableFilter<"Product"> | string | null
    priceCents?: IntFilter<"Product"> | number
    originalPriceCents?: IntNullableFilter<"Product"> | number | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    specifications?: StringNullableFilter<"Product"> | string | null
    features?: StringNullableFilter<"Product"> | string | null
    warranty?: StringNullableFilter<"Product"> | string | null
    weight?: FloatNullableFilter<"Product"> | number | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    stockQuantity?: IntFilter<"Product"> | number
    minOrderQuantity?: IntFilter<"Product"> | number
    maxOrderQuantity?: IntNullableFilter<"Product"> | number | null
    maxStock?: IntNullableFilter<"Product"> | number | null
    tags?: StringNullableFilter<"Product"> | string | null
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDescription?: StringNullableFilter<"Product"> | string | null
    metaKeywords?: StringNullableFilter<"Product"> | string | null
    canonicalUrl?: StringNullableFilter<"Product"> | string | null
    featured?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    isDeleted?: BoolFilter<"Product"> | boolean
    viewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    cartItems?: CartItemListRelationFilter
    inventory?: XOR<InventoryNullableRelationFilter, InventoryWhereInput> | null
    InventoryAlert?: InventoryAlertListRelationFilter
    InventoryMovement?: InventoryMovementListRelationFilter
    knowledgeEntries?: KnowledgeBaseEntryListRelationFilter
    orderItems?: OrderItemListRelationFilter
    reviews?: ProductReviewListRelationFilter
    views?: ProductViewListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    wishlistItems?: WishlistItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    originalPriceCents?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    warranty?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    maxOrderQuantity?: SortOrderInput | SortOrder
    maxStock?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cartItems?: CartItemOrderByRelationAggregateInput
    inventory?: InventoryOrderByWithRelationInput
    InventoryAlert?: InventoryAlertOrderByRelationAggregateInput
    InventoryMovement?: InventoryMovementOrderByRelationAggregateInput
    knowledgeEntries?: KnowledgeBaseEntryOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    reviews?: ProductReviewOrderByRelationAggregateInput
    views?: ProductViewOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    wishlistItems?: WishlistItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    shortDescription?: StringNullableFilter<"Product"> | string | null
    priceCents?: IntFilter<"Product"> | number
    originalPriceCents?: IntNullableFilter<"Product"> | number | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    specifications?: StringNullableFilter<"Product"> | string | null
    features?: StringNullableFilter<"Product"> | string | null
    warranty?: StringNullableFilter<"Product"> | string | null
    weight?: FloatNullableFilter<"Product"> | number | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    stockQuantity?: IntFilter<"Product"> | number
    minOrderQuantity?: IntFilter<"Product"> | number
    maxOrderQuantity?: IntNullableFilter<"Product"> | number | null
    maxStock?: IntNullableFilter<"Product"> | number | null
    tags?: StringNullableFilter<"Product"> | string | null
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDescription?: StringNullableFilter<"Product"> | string | null
    metaKeywords?: StringNullableFilter<"Product"> | string | null
    canonicalUrl?: StringNullableFilter<"Product"> | string | null
    featured?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    isDeleted?: BoolFilter<"Product"> | boolean
    viewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    cartItems?: CartItemListRelationFilter
    inventory?: XOR<InventoryNullableRelationFilter, InventoryWhereInput> | null
    InventoryAlert?: InventoryAlertListRelationFilter
    InventoryMovement?: InventoryMovementListRelationFilter
    knowledgeEntries?: KnowledgeBaseEntryListRelationFilter
    orderItems?: OrderItemListRelationFilter
    reviews?: ProductReviewListRelationFilter
    views?: ProductViewListRelationFilter
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    wishlistItems?: WishlistItemListRelationFilter
  }, "id" | "slug" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    originalPriceCents?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    warranty?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    maxOrderQuantity?: SortOrderInput | SortOrder
    maxStock?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    shortDescription?: StringNullableWithAggregatesFilter<"Product"> | string | null
    priceCents?: IntWithAggregatesFilter<"Product"> | number
    originalPriceCents?: IntNullableWithAggregatesFilter<"Product"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    images?: StringNullableWithAggregatesFilter<"Product"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    brand?: StringNullableWithAggregatesFilter<"Product"> | string | null
    model?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    specifications?: StringNullableWithAggregatesFilter<"Product"> | string | null
    features?: StringNullableWithAggregatesFilter<"Product"> | string | null
    warranty?: StringNullableWithAggregatesFilter<"Product"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    dimensions?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stockQuantity?: IntWithAggregatesFilter<"Product"> | number
    minOrderQuantity?: IntWithAggregatesFilter<"Product"> | number
    maxOrderQuantity?: IntNullableWithAggregatesFilter<"Product"> | number | null
    maxStock?: IntNullableWithAggregatesFilter<"Product"> | number | null
    tags?: StringNullableWithAggregatesFilter<"Product"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Product"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Product"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"Product"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    featured?: BoolWithAggregatesFilter<"Product"> | boolean
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Product"> | boolean
    viewCount?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    canonicalUrl?: StringNullableFilter<"Category"> | string | null
    description?: StringNullableFilter<"Category"> | string | null
    imageUrl?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    metaKeywords?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    canonicalUrl?: StringNullableFilter<"Category"> | string | null
    description?: StringNullableFilter<"Category"> | string | null
    imageUrl?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    metaKeywords?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    canonicalUrl?: StringNullableWithAggregatesFilter<"Category"> | string | null
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringNullableFilter<"Cart"> | string | null
    guestId?: StringNullableFilter<"Cart"> | string | null
    status?: StringFilter<"Cart"> | string
    expiresAt?: DateTimeNullableFilter<"Cart"> | Date | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    items?: CartItemListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: CartItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    userId?: StringNullableFilter<"Cart"> | string | null
    guestId?: StringNullableFilter<"Cart"> | string | null
    status?: StringFilter<"Cart"> | string
    expiresAt?: DateTimeNullableFilter<"Cart"> | Date | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    items?: CartItemListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    userId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    guestId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    status?: StringWithAggregatesFilter<"Cart"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Cart"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    price?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartRelationFilter, CartWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cartId_productId?: CartItemCartIdProductIdCompoundUniqueInput
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    price?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartRelationFilter, CartWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "cartId_productId">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    price?: IntWithAggregatesFilter<"CartItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNo?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    subtotalCents?: IntFilter<"Order"> | number
    discountCents?: IntFilter<"Order"> | number
    shippingCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    shippingCoordinates?: StringNullableFilter<"Order"> | string | null
    promotionCode?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    items?: OrderItemListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    paymentIntents?: PaymentIntentListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    shippingCents?: SortOrder
    totalCents?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    shippingCoordinates?: SortOrderInput | SortOrder
    promotionCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: OrderItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    paymentIntents?: PaymentIntentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNo?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    subtotalCents?: IntFilter<"Order"> | number
    discountCents?: IntFilter<"Order"> | number
    shippingCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    shippingCoordinates?: StringNullableFilter<"Order"> | string | null
    promotionCode?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    items?: OrderItemListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    paymentIntents?: PaymentIntentListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "orderNo">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    shippingCents?: SortOrder
    totalCents?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    shippingCoordinates?: SortOrderInput | SortOrder
    promotionCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNo?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    subtotalCents?: IntWithAggregatesFilter<"Order"> | number
    discountCents?: IntWithAggregatesFilter<"Order"> | number
    shippingCents?: IntWithAggregatesFilter<"Order"> | number
    totalCents?: IntWithAggregatesFilter<"Order"> | number
    status?: StringWithAggregatesFilter<"Order"> | string
    shippingAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    shippingCoordinates?: StringNullableWithAggregatesFilter<"Order"> | string | null
    promotionCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: IntFilter<"OrderItem"> | number
    name?: StringNullableFilter<"OrderItem"> | string | null
    unitPrice?: IntNullableFilter<"OrderItem"> | number | null
    imageUrl?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    name?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: IntFilter<"OrderItem"> | number
    name?: StringNullableFilter<"OrderItem"> | string | null
    unitPrice?: IntNullableFilter<"OrderItem"> | number | null
    imageUrl?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    name?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: IntWithAggregatesFilter<"OrderItem"> | number
    name?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    unitPrice?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    intentId?: StringNullableFilter<"Payment"> | string | null
    provider?: StringFilter<"Payment"> | string
    amountCents?: IntFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    intent?: XOR<PaymentIntentNullableRelationFilter, PaymentIntentWhereInput> | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    refunds?: RefundListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    intentId?: SortOrderInput | SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    intent?: PaymentIntentOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    refunds?: RefundOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    orderId?: StringFilter<"Payment"> | string
    intentId?: StringNullableFilter<"Payment"> | string | null
    provider?: StringFilter<"Payment"> | string
    amountCents?: IntFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    intent?: XOR<PaymentIntentNullableRelationFilter, PaymentIntentWhereInput> | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    refunds?: RefundListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    intentId?: SortOrderInput | SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    intentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    provider?: StringWithAggregatesFilter<"Payment"> | string
    amountCents?: IntWithAggregatesFilter<"Payment"> | number
    status?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    id?: StringFilter<"Refund"> | string
    paymentId?: StringFilter<"Refund"> | string
    amountCents?: IntFilter<"Refund"> | number
    reason?: StringNullableFilter<"Refund"> | string | null
    status?: StringFilter<"Refund"> | string
    providerRefundId?: StringNullableFilter<"Refund"> | string | null
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    errorMessage?: StringNullableFilter<"Refund"> | string | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }

  export type RefundOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amountCents?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    providerRefundId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type RefundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    paymentId?: StringFilter<"Refund"> | string
    amountCents?: IntFilter<"Refund"> | number
    reason?: StringNullableFilter<"Refund"> | string | null
    status?: StringFilter<"Refund"> | string
    providerRefundId?: StringNullableFilter<"Refund"> | string | null
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    errorMessage?: StringNullableFilter<"Refund"> | string | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }, "id">

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amountCents?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    providerRefundId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: RefundCountOrderByAggregateInput
    _avg?: RefundAvgOrderByAggregateInput
    _max?: RefundMaxOrderByAggregateInput
    _min?: RefundMinOrderByAggregateInput
    _sum?: RefundSumOrderByAggregateInput
  }

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    OR?: RefundScalarWhereWithAggregatesInput[]
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Refund"> | string
    paymentId?: StringWithAggregatesFilter<"Refund"> | string
    amountCents?: IntWithAggregatesFilter<"Refund"> | number
    reason?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    status?: StringWithAggregatesFilter<"Refund"> | string
    providerRefundId?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Refund"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
    errorMessage?: StringNullableWithAggregatesFilter<"Refund"> | string | null
  }

  export type ServiceTypeWhereInput = {
    AND?: ServiceTypeWhereInput | ServiceTypeWhereInput[]
    OR?: ServiceTypeWhereInput[]
    NOT?: ServiceTypeWhereInput | ServiceTypeWhereInput[]
    id?: StringFilter<"ServiceType"> | string
    name?: StringFilter<"ServiceType"> | string
    slug?: StringFilter<"ServiceType"> | string
    description?: StringNullableFilter<"ServiceType"> | string | null
    icon?: StringNullableFilter<"ServiceType"> | string | null
    color?: StringNullableFilter<"ServiceType"> | string | null
    isActive?: BoolFilter<"ServiceType"> | boolean
    sortOrder?: IntFilter<"ServiceType"> | number
    createdAt?: DateTimeFilter<"ServiceType"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceType"> | Date | string
    services?: ServiceListRelationFilter
  }

  export type ServiceTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type ServiceTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceTypeWhereInput | ServiceTypeWhereInput[]
    OR?: ServiceTypeWhereInput[]
    NOT?: ServiceTypeWhereInput | ServiceTypeWhereInput[]
    name?: StringFilter<"ServiceType"> | string
    description?: StringNullableFilter<"ServiceType"> | string | null
    icon?: StringNullableFilter<"ServiceType"> | string | null
    color?: StringNullableFilter<"ServiceType"> | string | null
    isActive?: BoolFilter<"ServiceType"> | boolean
    sortOrder?: IntFilter<"ServiceType"> | number
    createdAt?: DateTimeFilter<"ServiceType"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceType"> | Date | string
    services?: ServiceListRelationFilter
  }, "id" | "slug">

  export type ServiceTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTypeCountOrderByAggregateInput
    _avg?: ServiceTypeAvgOrderByAggregateInput
    _max?: ServiceTypeMaxOrderByAggregateInput
    _min?: ServiceTypeMinOrderByAggregateInput
    _sum?: ServiceTypeSumOrderByAggregateInput
  }

  export type ServiceTypeScalarWhereWithAggregatesInput = {
    AND?: ServiceTypeScalarWhereWithAggregatesInput | ServiceTypeScalarWhereWithAggregatesInput[]
    OR?: ServiceTypeScalarWhereWithAggregatesInput[]
    NOT?: ServiceTypeScalarWhereWithAggregatesInput | ServiceTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceType"> | string
    name?: StringWithAggregatesFilter<"ServiceType"> | string
    slug?: StringWithAggregatesFilter<"ServiceType"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceType"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ServiceType"> | string | null
    color?: StringNullableWithAggregatesFilter<"ServiceType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ServiceType"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ServiceType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServiceType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceType"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    shortDescription?: StringNullableFilter<"Service"> | string | null
    basePriceCents?: IntFilter<"Service"> | number
    price?: IntFilter<"Service"> | number
    minPrice?: IntNullableFilter<"Service"> | number | null
    maxPrice?: IntNullableFilter<"Service"> | number | null
    priceType?: StringFilter<"Service"> | string
    duration?: IntFilter<"Service"> | number
    typeId?: StringNullableFilter<"Service"> | string | null
    images?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    isFeatured?: BoolFilter<"Service"> | boolean
    seoTitle?: StringNullableFilter<"Service"> | string | null
    seoDescription?: StringNullableFilter<"Service"> | string | null
    type?: StringNullableFilter<"Service"> | string | null
    tags?: StringNullableFilter<"Service"> | string | null
    features?: StringNullableFilter<"Service"> | string | null
    requirements?: StringNullableFilter<"Service"> | string | null
    metadata?: StringNullableFilter<"Service"> | string | null
    viewCount?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    bookings?: ServiceBookingListRelationFilter
    items?: ServiceItemListRelationFilter
    views?: ServiceViewListRelationFilter
    serviceType?: XOR<ServiceTypeNullableRelationFilter, ServiceTypeWhereInput> | null
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    basePriceCents?: SortOrder
    price?: SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    priceType?: SortOrder
    duration?: SortOrder
    typeId?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: ServiceBookingOrderByRelationAggregateInput
    items?: ServiceItemOrderByRelationAggregateInput
    views?: ServiceViewOrderByRelationAggregateInput
    serviceType?: ServiceTypeOrderByWithRelationInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    shortDescription?: StringNullableFilter<"Service"> | string | null
    basePriceCents?: IntFilter<"Service"> | number
    price?: IntFilter<"Service"> | number
    minPrice?: IntNullableFilter<"Service"> | number | null
    maxPrice?: IntNullableFilter<"Service"> | number | null
    priceType?: StringFilter<"Service"> | string
    duration?: IntFilter<"Service"> | number
    typeId?: StringNullableFilter<"Service"> | string | null
    images?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    isFeatured?: BoolFilter<"Service"> | boolean
    seoTitle?: StringNullableFilter<"Service"> | string | null
    seoDescription?: StringNullableFilter<"Service"> | string | null
    type?: StringNullableFilter<"Service"> | string | null
    tags?: StringNullableFilter<"Service"> | string | null
    features?: StringNullableFilter<"Service"> | string | null
    requirements?: StringNullableFilter<"Service"> | string | null
    metadata?: StringNullableFilter<"Service"> | string | null
    viewCount?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    bookings?: ServiceBookingListRelationFilter
    items?: ServiceItemListRelationFilter
    views?: ServiceViewListRelationFilter
    serviceType?: XOR<ServiceTypeNullableRelationFilter, ServiceTypeWhereInput> | null
  }, "id" | "slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    basePriceCents?: SortOrder
    price?: SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    priceType?: SortOrder
    duration?: SortOrder
    typeId?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    slug?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    shortDescription?: StringNullableWithAggregatesFilter<"Service"> | string | null
    basePriceCents?: IntWithAggregatesFilter<"Service"> | number
    price?: IntWithAggregatesFilter<"Service"> | number
    minPrice?: IntNullableWithAggregatesFilter<"Service"> | number | null
    maxPrice?: IntNullableWithAggregatesFilter<"Service"> | number | null
    priceType?: StringWithAggregatesFilter<"Service"> | string
    duration?: IntWithAggregatesFilter<"Service"> | number
    typeId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    images?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Service"> | boolean
    seoTitle?: StringNullableWithAggregatesFilter<"Service"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"Service"> | string | null
    type?: StringNullableWithAggregatesFilter<"Service"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Service"> | string | null
    features?: StringNullableWithAggregatesFilter<"Service"> | string | null
    requirements?: StringNullableWithAggregatesFilter<"Service"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Service"> | string | null
    viewCount?: IntWithAggregatesFilter<"Service"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    productId?: StringFilter<"Inventory"> | string
    stock?: IntFilter<"Inventory"> | number
    reserved?: IntFilter<"Inventory"> | number
    lowStockThreshold?: IntFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    stock?: SortOrder
    reserved?: SortOrder
    lowStockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    stock?: IntFilter<"Inventory"> | number
    reserved?: IntFilter<"Inventory"> | number
    lowStockThreshold?: IntFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "productId">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    stock?: SortOrder
    reserved?: SortOrder
    lowStockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    productId?: StringWithAggregatesFilter<"Inventory"> | string
    stock?: IntWithAggregatesFilter<"Inventory"> | number
    reserved?: IntWithAggregatesFilter<"Inventory"> | number
    lowStockThreshold?: IntWithAggregatesFilter<"Inventory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    productId?: StringFilter<"InventoryMovement"> | string
    type?: StringFilter<"InventoryMovement"> | string
    quantity?: IntFilter<"InventoryMovement"> | number
    previousStock?: IntFilter<"InventoryMovement"> | number
    newStock?: IntFilter<"InventoryMovement"> | number
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceId?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableFilter<"InventoryMovement"> | string | null
    userId?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    productId?: StringFilter<"InventoryMovement"> | string
    type?: StringFilter<"InventoryMovement"> | string
    quantity?: IntFilter<"InventoryMovement"> | number
    previousStock?: IntFilter<"InventoryMovement"> | number
    newStock?: IntFilter<"InventoryMovement"> | number
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceId?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableFilter<"InventoryMovement"> | string | null
    userId?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryMovement"> | string
    productId?: StringWithAggregatesFilter<"InventoryMovement"> | string
    type?: StringWithAggregatesFilter<"InventoryMovement"> | string
    quantity?: IntWithAggregatesFilter<"InventoryMovement"> | number
    previousStock?: IntWithAggregatesFilter<"InventoryMovement"> | number
    newStock?: IntWithAggregatesFilter<"InventoryMovement"> | number
    reason?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    referenceId?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    userId?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
  }

  export type InventoryAlertWhereInput = {
    AND?: InventoryAlertWhereInput | InventoryAlertWhereInput[]
    OR?: InventoryAlertWhereInput[]
    NOT?: InventoryAlertWhereInput | InventoryAlertWhereInput[]
    id?: StringFilter<"InventoryAlert"> | string
    productId?: StringFilter<"InventoryAlert"> | string
    type?: StringFilter<"InventoryAlert"> | string
    message?: StringFilter<"InventoryAlert"> | string
    threshold?: IntNullableFilter<"InventoryAlert"> | number | null
    currentStock?: IntFilter<"InventoryAlert"> | number
    isResolved?: BoolFilter<"InventoryAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"InventoryAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"InventoryAlert"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAlert"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type InventoryAlertOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    threshold?: SortOrderInput | SortOrder
    currentStock?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type InventoryAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryAlertWhereInput | InventoryAlertWhereInput[]
    OR?: InventoryAlertWhereInput[]
    NOT?: InventoryAlertWhereInput | InventoryAlertWhereInput[]
    productId?: StringFilter<"InventoryAlert"> | string
    type?: StringFilter<"InventoryAlert"> | string
    message?: StringFilter<"InventoryAlert"> | string
    threshold?: IntNullableFilter<"InventoryAlert"> | number | null
    currentStock?: IntFilter<"InventoryAlert"> | number
    isResolved?: BoolFilter<"InventoryAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"InventoryAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"InventoryAlert"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAlert"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type InventoryAlertOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    threshold?: SortOrderInput | SortOrder
    currentStock?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryAlertCountOrderByAggregateInput
    _avg?: InventoryAlertAvgOrderByAggregateInput
    _max?: InventoryAlertMaxOrderByAggregateInput
    _min?: InventoryAlertMinOrderByAggregateInput
    _sum?: InventoryAlertSumOrderByAggregateInput
  }

  export type InventoryAlertScalarWhereWithAggregatesInput = {
    AND?: InventoryAlertScalarWhereWithAggregatesInput | InventoryAlertScalarWhereWithAggregatesInput[]
    OR?: InventoryAlertScalarWhereWithAggregatesInput[]
    NOT?: InventoryAlertScalarWhereWithAggregatesInput | InventoryAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryAlert"> | string
    productId?: StringWithAggregatesFilter<"InventoryAlert"> | string
    type?: StringWithAggregatesFilter<"InventoryAlert"> | string
    message?: StringWithAggregatesFilter<"InventoryAlert"> | string
    threshold?: IntNullableWithAggregatesFilter<"InventoryAlert"> | number | null
    currentStock?: IntWithAggregatesFilter<"InventoryAlert"> | number
    isResolved?: BoolWithAggregatesFilter<"InventoryAlert"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"InventoryAlert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryAlert"> | Date | string
  }

  export type InventoryReportWhereInput = {
    AND?: InventoryReportWhereInput | InventoryReportWhereInput[]
    OR?: InventoryReportWhereInput[]
    NOT?: InventoryReportWhereInput | InventoryReportWhereInput[]
    id?: StringFilter<"InventoryReport"> | string
    type?: StringFilter<"InventoryReport"> | string
    title?: StringFilter<"InventoryReport"> | string
    description?: StringNullableFilter<"InventoryReport"> | string | null
    parameters?: StringNullableFilter<"InventoryReport"> | string | null
    data?: StringNullableFilter<"InventoryReport"> | string | null
    generatedBy?: StringNullableFilter<"InventoryReport"> | string | null
    generatedAt?: DateTimeFilter<"InventoryReport"> | Date | string
    createdAt?: DateTimeFilter<"InventoryReport"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryReport"> | Date | string
  }

  export type InventoryReportOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    generatedBy?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryReportWhereInput | InventoryReportWhereInput[]
    OR?: InventoryReportWhereInput[]
    NOT?: InventoryReportWhereInput | InventoryReportWhereInput[]
    type?: StringFilter<"InventoryReport"> | string
    title?: StringFilter<"InventoryReport"> | string
    description?: StringNullableFilter<"InventoryReport"> | string | null
    parameters?: StringNullableFilter<"InventoryReport"> | string | null
    data?: StringNullableFilter<"InventoryReport"> | string | null
    generatedBy?: StringNullableFilter<"InventoryReport"> | string | null
    generatedAt?: DateTimeFilter<"InventoryReport"> | Date | string
    createdAt?: DateTimeFilter<"InventoryReport"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryReport"> | Date | string
  }, "id">

  export type InventoryReportOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    generatedBy?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryReportCountOrderByAggregateInput
    _max?: InventoryReportMaxOrderByAggregateInput
    _min?: InventoryReportMinOrderByAggregateInput
  }

  export type InventoryReportScalarWhereWithAggregatesInput = {
    AND?: InventoryReportScalarWhereWithAggregatesInput | InventoryReportScalarWhereWithAggregatesInput[]
    OR?: InventoryReportScalarWhereWithAggregatesInput[]
    NOT?: InventoryReportScalarWhereWithAggregatesInput | InventoryReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryReport"> | string
    type?: StringWithAggregatesFilter<"InventoryReport"> | string
    title?: StringWithAggregatesFilter<"InventoryReport"> | string
    description?: StringNullableWithAggregatesFilter<"InventoryReport"> | string | null
    parameters?: StringNullableWithAggregatesFilter<"InventoryReport"> | string | null
    data?: StringNullableWithAggregatesFilter<"InventoryReport"> | string | null
    generatedBy?: StringNullableWithAggregatesFilter<"InventoryReport"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"InventoryReport"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"InventoryReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryReport"> | Date | string
  }

  export type WishlistItemWhereInput = {
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WishlistItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WishlistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_productId?: WishlistItemUserIdProductIdCompoundUniqueInput
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_productId">

  export type WishlistItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    _count?: WishlistItemCountOrderByAggregateInput
    _max?: WishlistItemMaxOrderByAggregateInput
    _min?: WishlistItemMinOrderByAggregateInput
  }

  export type WishlistItemScalarWhereWithAggregatesInput = {
    AND?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    OR?: WishlistItemScalarWhereWithAggregatesInput[]
    NOT?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WishlistItem"> | string
    userId?: StringWithAggregatesFilter<"WishlistItem"> | string
    productId?: StringWithAggregatesFilter<"WishlistItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string
  }

  export type ProductReviewWhereInput = {
    AND?: ProductReviewWhereInput | ProductReviewWhereInput[]
    OR?: ProductReviewWhereInput[]
    NOT?: ProductReviewWhereInput | ProductReviewWhereInput[]
    id?: StringFilter<"ProductReview"> | string
    userId?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    title?: StringNullableFilter<"ProductReview"> | string | null
    comment?: StringNullableFilter<"ProductReview"> | string | null
    isVerified?: BoolFilter<"ProductReview"> | boolean
    status?: EnumReviewStatusFilter<"ProductReview"> | $Enums.ReviewStatus
    upvotes?: IntFilter<"ProductReview"> | number
    downvotes?: IntFilter<"ProductReview"> | number
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string
    reports?: ProductReviewReportListRelationFilter
    votes?: ProductReviewVoteListRelationFilter
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProductReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reports?: ProductReviewReportOrderByRelationAggregateInput
    votes?: ProductReviewVoteOrderByRelationAggregateInput
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProductReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductReviewWhereInput | ProductReviewWhereInput[]
    OR?: ProductReviewWhereInput[]
    NOT?: ProductReviewWhereInput | ProductReviewWhereInput[]
    userId?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    title?: StringNullableFilter<"ProductReview"> | string | null
    comment?: StringNullableFilter<"ProductReview"> | string | null
    isVerified?: BoolFilter<"ProductReview"> | boolean
    status?: EnumReviewStatusFilter<"ProductReview"> | $Enums.ReviewStatus
    upvotes?: IntFilter<"ProductReview"> | number
    downvotes?: IntFilter<"ProductReview"> | number
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string
    reports?: ProductReviewReportListRelationFilter
    votes?: ProductReviewVoteListRelationFilter
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ProductReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductReviewCountOrderByAggregateInput
    _avg?: ProductReviewAvgOrderByAggregateInput
    _max?: ProductReviewMaxOrderByAggregateInput
    _min?: ProductReviewMinOrderByAggregateInput
    _sum?: ProductReviewSumOrderByAggregateInput
  }

  export type ProductReviewScalarWhereWithAggregatesInput = {
    AND?: ProductReviewScalarWhereWithAggregatesInput | ProductReviewScalarWhereWithAggregatesInput[]
    OR?: ProductReviewScalarWhereWithAggregatesInput[]
    NOT?: ProductReviewScalarWhereWithAggregatesInput | ProductReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductReview"> | string
    userId?: StringWithAggregatesFilter<"ProductReview"> | string
    productId?: StringWithAggregatesFilter<"ProductReview"> | string
    rating?: IntWithAggregatesFilter<"ProductReview"> | number
    title?: StringNullableWithAggregatesFilter<"ProductReview"> | string | null
    comment?: StringNullableWithAggregatesFilter<"ProductReview"> | string | null
    isVerified?: BoolWithAggregatesFilter<"ProductReview"> | boolean
    status?: EnumReviewStatusWithAggregatesFilter<"ProductReview"> | $Enums.ReviewStatus
    upvotes?: IntWithAggregatesFilter<"ProductReview"> | number
    downvotes?: IntWithAggregatesFilter<"ProductReview"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductReview"> | Date | string
  }

  export type ProductReviewVoteWhereInput = {
    AND?: ProductReviewVoteWhereInput | ProductReviewVoteWhereInput[]
    OR?: ProductReviewVoteWhereInput[]
    NOT?: ProductReviewVoteWhereInput | ProductReviewVoteWhereInput[]
    id?: StringFilter<"ProductReviewVote"> | string
    reviewId?: StringFilter<"ProductReviewVote"> | string
    userId?: StringFilter<"ProductReviewVote"> | string
    isUpvote?: BoolFilter<"ProductReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ProductReviewVote"> | Date | string
    review?: XOR<ProductReviewRelationFilter, ProductReviewWhereInput>
  }

  export type ProductReviewVoteOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
    review?: ProductReviewOrderByWithRelationInput
  }

  export type ProductReviewVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId_userId?: ProductReviewVoteReviewIdUserIdCompoundUniqueInput
    AND?: ProductReviewVoteWhereInput | ProductReviewVoteWhereInput[]
    OR?: ProductReviewVoteWhereInput[]
    NOT?: ProductReviewVoteWhereInput | ProductReviewVoteWhereInput[]
    reviewId?: StringFilter<"ProductReviewVote"> | string
    userId?: StringFilter<"ProductReviewVote"> | string
    isUpvote?: BoolFilter<"ProductReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ProductReviewVote"> | Date | string
    review?: XOR<ProductReviewRelationFilter, ProductReviewWhereInput>
  }, "id" | "reviewId_userId">

  export type ProductReviewVoteOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
    _count?: ProductReviewVoteCountOrderByAggregateInput
    _max?: ProductReviewVoteMaxOrderByAggregateInput
    _min?: ProductReviewVoteMinOrderByAggregateInput
  }

  export type ProductReviewVoteScalarWhereWithAggregatesInput = {
    AND?: ProductReviewVoteScalarWhereWithAggregatesInput | ProductReviewVoteScalarWhereWithAggregatesInput[]
    OR?: ProductReviewVoteScalarWhereWithAggregatesInput[]
    NOT?: ProductReviewVoteScalarWhereWithAggregatesInput | ProductReviewVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductReviewVote"> | string
    reviewId?: StringWithAggregatesFilter<"ProductReviewVote"> | string
    userId?: StringWithAggregatesFilter<"ProductReviewVote"> | string
    isUpvote?: BoolWithAggregatesFilter<"ProductReviewVote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductReviewVote"> | Date | string
  }

  export type ProductReviewReportWhereInput = {
    AND?: ProductReviewReportWhereInput | ProductReviewReportWhereInput[]
    OR?: ProductReviewReportWhereInput[]
    NOT?: ProductReviewReportWhereInput | ProductReviewReportWhereInput[]
    id?: StringFilter<"ProductReviewReport"> | string
    reviewId?: StringFilter<"ProductReviewReport"> | string
    userId?: StringFilter<"ProductReviewReport"> | string
    reason?: StringFilter<"ProductReviewReport"> | string
    createdAt?: DateTimeFilter<"ProductReviewReport"> | Date | string
    review?: XOR<ProductReviewRelationFilter, ProductReviewWhereInput>
  }

  export type ProductReviewReportOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    review?: ProductReviewOrderByWithRelationInput
  }

  export type ProductReviewReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductReviewReportWhereInput | ProductReviewReportWhereInput[]
    OR?: ProductReviewReportWhereInput[]
    NOT?: ProductReviewReportWhereInput | ProductReviewReportWhereInput[]
    reviewId?: StringFilter<"ProductReviewReport"> | string
    userId?: StringFilter<"ProductReviewReport"> | string
    reason?: StringFilter<"ProductReviewReport"> | string
    createdAt?: DateTimeFilter<"ProductReviewReport"> | Date | string
    review?: XOR<ProductReviewRelationFilter, ProductReviewWhereInput>
  }, "id">

  export type ProductReviewReportOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: ProductReviewReportCountOrderByAggregateInput
    _max?: ProductReviewReportMaxOrderByAggregateInput
    _min?: ProductReviewReportMinOrderByAggregateInput
  }

  export type ProductReviewReportScalarWhereWithAggregatesInput = {
    AND?: ProductReviewReportScalarWhereWithAggregatesInput | ProductReviewReportScalarWhereWithAggregatesInput[]
    OR?: ProductReviewReportScalarWhereWithAggregatesInput[]
    NOT?: ProductReviewReportScalarWhereWithAggregatesInput | ProductReviewReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductReviewReport"> | string
    reviewId?: StringWithAggregatesFilter<"ProductReviewReport"> | string
    userId?: StringWithAggregatesFilter<"ProductReviewReport"> | string
    reason?: StringWithAggregatesFilter<"ProductReviewReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductReviewReport"> | Date | string
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    isPublished?: BoolFilter<"Page"> | boolean
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    title?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    isPublished?: BoolFilter<"Page"> | boolean
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }, "id" | "slug">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    title?: StringWithAggregatesFilter<"Page"> | string
    content?: StringWithAggregatesFilter<"Page"> | string
    isPublished?: BoolWithAggregatesFilter<"Page"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
  }

  export type SearchQueryWhereInput = {
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    id?: StringFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    userId?: StringNullableFilter<"SearchQuery"> | string | null
    timestamp?: DateTimeFilter<"SearchQuery"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SearchQueryOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    query?: StringFilter<"SearchQuery"> | string
    userId?: StringNullableFilter<"SearchQuery"> | string | null
    timestamp?: DateTimeFilter<"SearchQuery"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SearchQueryOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: SearchQueryCountOrderByAggregateInput
    _max?: SearchQueryMaxOrderByAggregateInput
    _min?: SearchQueryMinOrderByAggregateInput
  }

  export type SearchQueryScalarWhereWithAggregatesInput = {
    AND?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    OR?: SearchQueryScalarWhereWithAggregatesInput[]
    NOT?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchQuery"> | string
    query?: StringWithAggregatesFilter<"SearchQuery"> | string
    userId?: StringNullableWithAggregatesFilter<"SearchQuery"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
  }

  export type ProductViewWhereInput = {
    AND?: ProductViewWhereInput | ProductViewWhereInput[]
    OR?: ProductViewWhereInput[]
    NOT?: ProductViewWhereInput | ProductViewWhereInput[]
    id?: StringFilter<"ProductView"> | string
    productId?: StringFilter<"ProductView"> | string
    userId?: StringNullableFilter<"ProductView"> | string | null
    timestamp?: DateTimeFilter<"ProductView"> | Date | string
    duration?: IntNullableFilter<"ProductView"> | number | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ProductViewOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    duration?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProductViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductViewWhereInput | ProductViewWhereInput[]
    OR?: ProductViewWhereInput[]
    NOT?: ProductViewWhereInput | ProductViewWhereInput[]
    productId?: StringFilter<"ProductView"> | string
    userId?: StringNullableFilter<"ProductView"> | string | null
    timestamp?: DateTimeFilter<"ProductView"> | Date | string
    duration?: IntNullableFilter<"ProductView"> | number | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProductViewOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    duration?: SortOrderInput | SortOrder
    _count?: ProductViewCountOrderByAggregateInput
    _avg?: ProductViewAvgOrderByAggregateInput
    _max?: ProductViewMaxOrderByAggregateInput
    _min?: ProductViewMinOrderByAggregateInput
    _sum?: ProductViewSumOrderByAggregateInput
  }

  export type ProductViewScalarWhereWithAggregatesInput = {
    AND?: ProductViewScalarWhereWithAggregatesInput | ProductViewScalarWhereWithAggregatesInput[]
    OR?: ProductViewScalarWhereWithAggregatesInput[]
    NOT?: ProductViewScalarWhereWithAggregatesInput | ProductViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductView"> | string
    productId?: StringWithAggregatesFilter<"ProductView"> | string
    userId?: StringNullableWithAggregatesFilter<"ProductView"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ProductView"> | Date | string
    duration?: IntNullableWithAggregatesFilter<"ProductView"> | number | null
  }

  export type ServiceViewWhereInput = {
    AND?: ServiceViewWhereInput | ServiceViewWhereInput[]
    OR?: ServiceViewWhereInput[]
    NOT?: ServiceViewWhereInput | ServiceViewWhereInput[]
    id?: StringFilter<"ServiceView"> | string
    serviceId?: StringFilter<"ServiceView"> | string
    userId?: StringNullableFilter<"ServiceView"> | string | null
    timestamp?: DateTimeFilter<"ServiceView"> | Date | string
    duration?: IntNullableFilter<"ServiceView"> | number | null
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ServiceViewOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    duration?: SortOrderInput | SortOrder
    service?: ServiceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ServiceViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceViewWhereInput | ServiceViewWhereInput[]
    OR?: ServiceViewWhereInput[]
    NOT?: ServiceViewWhereInput | ServiceViewWhereInput[]
    serviceId?: StringFilter<"ServiceView"> | string
    userId?: StringNullableFilter<"ServiceView"> | string | null
    timestamp?: DateTimeFilter<"ServiceView"> | Date | string
    duration?: IntNullableFilter<"ServiceView"> | number | null
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ServiceViewOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    duration?: SortOrderInput | SortOrder
    _count?: ServiceViewCountOrderByAggregateInput
    _avg?: ServiceViewAvgOrderByAggregateInput
    _max?: ServiceViewMaxOrderByAggregateInput
    _min?: ServiceViewMinOrderByAggregateInput
    _sum?: ServiceViewSumOrderByAggregateInput
  }

  export type ServiceViewScalarWhereWithAggregatesInput = {
    AND?: ServiceViewScalarWhereWithAggregatesInput | ServiceViewScalarWhereWithAggregatesInput[]
    OR?: ServiceViewScalarWhereWithAggregatesInput[]
    NOT?: ServiceViewScalarWhereWithAggregatesInput | ServiceViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceView"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceView"> | string
    userId?: StringNullableWithAggregatesFilter<"ServiceView"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ServiceView"> | Date | string
    duration?: IntNullableWithAggregatesFilter<"ServiceView"> | number | null
  }

  export type CustomerQuestionWhereInput = {
    AND?: CustomerQuestionWhereInput | CustomerQuestionWhereInput[]
    OR?: CustomerQuestionWhereInput[]
    NOT?: CustomerQuestionWhereInput | CustomerQuestionWhereInput[]
    id?: StringFilter<"CustomerQuestion"> | string
    userId?: StringNullableFilter<"CustomerQuestion"> | string | null
    question?: StringFilter<"CustomerQuestion"> | string
    category?: StringNullableFilter<"CustomerQuestion"> | string | null
    satisfaction?: IntNullableFilter<"CustomerQuestion"> | number | null
    timestamp?: DateTimeFilter<"CustomerQuestion"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CustomerQuestionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    question?: SortOrder
    category?: SortOrderInput | SortOrder
    satisfaction?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CustomerQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerQuestionWhereInput | CustomerQuestionWhereInput[]
    OR?: CustomerQuestionWhereInput[]
    NOT?: CustomerQuestionWhereInput | CustomerQuestionWhereInput[]
    userId?: StringNullableFilter<"CustomerQuestion"> | string | null
    question?: StringFilter<"CustomerQuestion"> | string
    category?: StringNullableFilter<"CustomerQuestion"> | string | null
    satisfaction?: IntNullableFilter<"CustomerQuestion"> | number | null
    timestamp?: DateTimeFilter<"CustomerQuestion"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CustomerQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    question?: SortOrder
    category?: SortOrderInput | SortOrder
    satisfaction?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: CustomerQuestionCountOrderByAggregateInput
    _avg?: CustomerQuestionAvgOrderByAggregateInput
    _max?: CustomerQuestionMaxOrderByAggregateInput
    _min?: CustomerQuestionMinOrderByAggregateInput
    _sum?: CustomerQuestionSumOrderByAggregateInput
  }

  export type CustomerQuestionScalarWhereWithAggregatesInput = {
    AND?: CustomerQuestionScalarWhereWithAggregatesInput | CustomerQuestionScalarWhereWithAggregatesInput[]
    OR?: CustomerQuestionScalarWhereWithAggregatesInput[]
    NOT?: CustomerQuestionScalarWhereWithAggregatesInput | CustomerQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerQuestion"> | string
    userId?: StringNullableWithAggregatesFilter<"CustomerQuestion"> | string | null
    question?: StringWithAggregatesFilter<"CustomerQuestion"> | string
    category?: StringNullableWithAggregatesFilter<"CustomerQuestion"> | string | null
    satisfaction?: IntNullableWithAggregatesFilter<"CustomerQuestion"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"CustomerQuestion"> | Date | string
  }

  export type TechnicianWhereInput = {
    AND?: TechnicianWhereInput | TechnicianWhereInput[]
    OR?: TechnicianWhereInput[]
    NOT?: TechnicianWhereInput | TechnicianWhereInput[]
    id?: StringFilter<"Technician"> | string
    name?: StringFilter<"Technician"> | string
    email?: StringFilter<"Technician"> | string
    phone?: StringNullableFilter<"Technician"> | string | null
    specialties?: StringNullableFilter<"Technician"> | string | null
    isActive?: BoolFilter<"Technician"> | boolean
    createdAt?: DateTimeFilter<"Technician"> | Date | string
    bookings?: ServiceBookingListRelationFilter
    schedules?: TechnicianScheduleListRelationFilter
  }

  export type TechnicianOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    specialties?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    bookings?: ServiceBookingOrderByRelationAggregateInput
    schedules?: TechnicianScheduleOrderByRelationAggregateInput
  }

  export type TechnicianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: TechnicianWhereInput | TechnicianWhereInput[]
    OR?: TechnicianWhereInput[]
    NOT?: TechnicianWhereInput | TechnicianWhereInput[]
    name?: StringFilter<"Technician"> | string
    phone?: StringNullableFilter<"Technician"> | string | null
    specialties?: StringNullableFilter<"Technician"> | string | null
    isActive?: BoolFilter<"Technician"> | boolean
    createdAt?: DateTimeFilter<"Technician"> | Date | string
    bookings?: ServiceBookingListRelationFilter
    schedules?: TechnicianScheduleListRelationFilter
  }, "id" | "email">

  export type TechnicianOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    specialties?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: TechnicianCountOrderByAggregateInput
    _max?: TechnicianMaxOrderByAggregateInput
    _min?: TechnicianMinOrderByAggregateInput
  }

  export type TechnicianScalarWhereWithAggregatesInput = {
    AND?: TechnicianScalarWhereWithAggregatesInput | TechnicianScalarWhereWithAggregatesInput[]
    OR?: TechnicianScalarWhereWithAggregatesInput[]
    NOT?: TechnicianScalarWhereWithAggregatesInput | TechnicianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Technician"> | string
    name?: StringWithAggregatesFilter<"Technician"> | string
    email?: StringWithAggregatesFilter<"Technician"> | string
    phone?: StringNullableWithAggregatesFilter<"Technician"> | string | null
    specialties?: StringNullableWithAggregatesFilter<"Technician"> | string | null
    isActive?: BoolWithAggregatesFilter<"Technician"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Technician"> | Date | string
  }

  export type ServiceItemWhereInput = {
    AND?: ServiceItemWhereInput | ServiceItemWhereInput[]
    OR?: ServiceItemWhereInput[]
    NOT?: ServiceItemWhereInput | ServiceItemWhereInput[]
    id?: StringFilter<"ServiceItem"> | string
    serviceId?: StringFilter<"ServiceItem"> | string
    name?: StringFilter<"ServiceItem"> | string
    price?: IntFilter<"ServiceItem"> | number
    quantity?: IntFilter<"ServiceItem"> | number
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
    bookingItems?: ServiceBookingItemListRelationFilter
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type ServiceItemOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    bookingItems?: ServiceBookingItemOrderByRelationAggregateInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceItemWhereInput | ServiceItemWhereInput[]
    OR?: ServiceItemWhereInput[]
    NOT?: ServiceItemWhereInput | ServiceItemWhereInput[]
    serviceId?: StringFilter<"ServiceItem"> | string
    name?: StringFilter<"ServiceItem"> | string
    price?: IntFilter<"ServiceItem"> | number
    quantity?: IntFilter<"ServiceItem"> | number
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
    bookingItems?: ServiceBookingItemListRelationFilter
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id">

  export type ServiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceItemCountOrderByAggregateInput
    _avg?: ServiceItemAvgOrderByAggregateInput
    _max?: ServiceItemMaxOrderByAggregateInput
    _min?: ServiceItemMinOrderByAggregateInput
    _sum?: ServiceItemSumOrderByAggregateInput
  }

  export type ServiceItemScalarWhereWithAggregatesInput = {
    AND?: ServiceItemScalarWhereWithAggregatesInput | ServiceItemScalarWhereWithAggregatesInput[]
    OR?: ServiceItemScalarWhereWithAggregatesInput[]
    NOT?: ServiceItemScalarWhereWithAggregatesInput | ServiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceItem"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceItem"> | string
    name?: StringWithAggregatesFilter<"ServiceItem"> | string
    price?: IntWithAggregatesFilter<"ServiceItem"> | number
    quantity?: IntWithAggregatesFilter<"ServiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServiceItem"> | Date | string
  }

  export type ServiceBookingWhereInput = {
    AND?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    OR?: ServiceBookingWhereInput[]
    NOT?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    id?: StringFilter<"ServiceBooking"> | string
    userId?: StringFilter<"ServiceBooking"> | string
    serviceId?: StringFilter<"ServiceBooking"> | string
    technicianId?: StringNullableFilter<"ServiceBooking"> | string | null
    status?: StringFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    scheduledTime?: StringNullableFilter<"ServiceBooking"> | string | null
    completedAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    notes?: StringNullableFilter<"ServiceBooking"> | string | null
    estimatedCosts?: IntNullableFilter<"ServiceBooking"> | number | null
    actualCosts?: IntNullableFilter<"ServiceBooking"> | number | null
    createdAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    items?: ServiceBookingItemListRelationFilter
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    technician?: XOR<TechnicianNullableRelationFilter, TechnicianWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: ServicePaymentListRelationFilter
    history?: ServiceStatusHistoryListRelationFilter
  }

  export type ServiceBookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    technicianId?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    estimatedCosts?: SortOrderInput | SortOrder
    actualCosts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: ServiceBookingItemOrderByRelationAggregateInput
    service?: ServiceOrderByWithRelationInput
    technician?: TechnicianOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    payments?: ServicePaymentOrderByRelationAggregateInput
    history?: ServiceStatusHistoryOrderByRelationAggregateInput
  }

  export type ServiceBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    OR?: ServiceBookingWhereInput[]
    NOT?: ServiceBookingWhereInput | ServiceBookingWhereInput[]
    userId?: StringFilter<"ServiceBooking"> | string
    serviceId?: StringFilter<"ServiceBooking"> | string
    technicianId?: StringNullableFilter<"ServiceBooking"> | string | null
    status?: StringFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    scheduledTime?: StringNullableFilter<"ServiceBooking"> | string | null
    completedAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    notes?: StringNullableFilter<"ServiceBooking"> | string | null
    estimatedCosts?: IntNullableFilter<"ServiceBooking"> | number | null
    actualCosts?: IntNullableFilter<"ServiceBooking"> | number | null
    createdAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    items?: ServiceBookingItemListRelationFilter
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    technician?: XOR<TechnicianNullableRelationFilter, TechnicianWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: ServicePaymentListRelationFilter
    history?: ServiceStatusHistoryListRelationFilter
  }, "id">

  export type ServiceBookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    technicianId?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    estimatedCosts?: SortOrderInput | SortOrder
    actualCosts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceBookingCountOrderByAggregateInput
    _avg?: ServiceBookingAvgOrderByAggregateInput
    _max?: ServiceBookingMaxOrderByAggregateInput
    _min?: ServiceBookingMinOrderByAggregateInput
    _sum?: ServiceBookingSumOrderByAggregateInput
  }

  export type ServiceBookingScalarWhereWithAggregatesInput = {
    AND?: ServiceBookingScalarWhereWithAggregatesInput | ServiceBookingScalarWhereWithAggregatesInput[]
    OR?: ServiceBookingScalarWhereWithAggregatesInput[]
    NOT?: ServiceBookingScalarWhereWithAggregatesInput | ServiceBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceBooking"> | string
    userId?: StringWithAggregatesFilter<"ServiceBooking"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceBooking"> | string
    technicianId?: StringNullableWithAggregatesFilter<"ServiceBooking"> | string | null
    status?: StringWithAggregatesFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ServiceBooking"> | Date | string | null
    scheduledTime?: StringNullableWithAggregatesFilter<"ServiceBooking"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ServiceBooking"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ServiceBooking"> | string | null
    estimatedCosts?: IntNullableWithAggregatesFilter<"ServiceBooking"> | number | null
    actualCosts?: IntNullableWithAggregatesFilter<"ServiceBooking"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceBooking"> | Date | string
  }

  export type ServiceBookingItemWhereInput = {
    AND?: ServiceBookingItemWhereInput | ServiceBookingItemWhereInput[]
    OR?: ServiceBookingItemWhereInput[]
    NOT?: ServiceBookingItemWhereInput | ServiceBookingItemWhereInput[]
    id?: StringFilter<"ServiceBookingItem"> | string
    bookingId?: StringFilter<"ServiceBookingItem"> | string
    serviceItemId?: StringFilter<"ServiceBookingItem"> | string
    quantity?: IntFilter<"ServiceBookingItem"> | number
    price?: IntFilter<"ServiceBookingItem"> | number
    createdAt?: DateTimeFilter<"ServiceBookingItem"> | Date | string
    booking?: XOR<ServiceBookingRelationFilter, ServiceBookingWhereInput>
    serviceItem?: XOR<ServiceItemRelationFilter, ServiceItemWhereInput>
  }

  export type ServiceBookingItemOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    booking?: ServiceBookingOrderByWithRelationInput
    serviceItem?: ServiceItemOrderByWithRelationInput
  }

  export type ServiceBookingItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceBookingItemWhereInput | ServiceBookingItemWhereInput[]
    OR?: ServiceBookingItemWhereInput[]
    NOT?: ServiceBookingItemWhereInput | ServiceBookingItemWhereInput[]
    bookingId?: StringFilter<"ServiceBookingItem"> | string
    serviceItemId?: StringFilter<"ServiceBookingItem"> | string
    quantity?: IntFilter<"ServiceBookingItem"> | number
    price?: IntFilter<"ServiceBookingItem"> | number
    createdAt?: DateTimeFilter<"ServiceBookingItem"> | Date | string
    booking?: XOR<ServiceBookingRelationFilter, ServiceBookingWhereInput>
    serviceItem?: XOR<ServiceItemRelationFilter, ServiceItemWhereInput>
  }, "id">

  export type ServiceBookingItemOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceBookingItemCountOrderByAggregateInput
    _avg?: ServiceBookingItemAvgOrderByAggregateInput
    _max?: ServiceBookingItemMaxOrderByAggregateInput
    _min?: ServiceBookingItemMinOrderByAggregateInput
    _sum?: ServiceBookingItemSumOrderByAggregateInput
  }

  export type ServiceBookingItemScalarWhereWithAggregatesInput = {
    AND?: ServiceBookingItemScalarWhereWithAggregatesInput | ServiceBookingItemScalarWhereWithAggregatesInput[]
    OR?: ServiceBookingItemScalarWhereWithAggregatesInput[]
    NOT?: ServiceBookingItemScalarWhereWithAggregatesInput | ServiceBookingItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceBookingItem"> | string
    bookingId?: StringWithAggregatesFilter<"ServiceBookingItem"> | string
    serviceItemId?: StringWithAggregatesFilter<"ServiceBookingItem"> | string
    quantity?: IntWithAggregatesFilter<"ServiceBookingItem"> | number
    price?: IntWithAggregatesFilter<"ServiceBookingItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServiceBookingItem"> | Date | string
  }

  export type TechnicianScheduleWhereInput = {
    AND?: TechnicianScheduleWhereInput | TechnicianScheduleWhereInput[]
    OR?: TechnicianScheduleWhereInput[]
    NOT?: TechnicianScheduleWhereInput | TechnicianScheduleWhereInput[]
    id?: StringFilter<"TechnicianSchedule"> | string
    technicianId?: StringFilter<"TechnicianSchedule"> | string
    date?: DateTimeFilter<"TechnicianSchedule"> | Date | string
    startTime?: StringFilter<"TechnicianSchedule"> | string
    endTime?: StringFilter<"TechnicianSchedule"> | string
    isAvailable?: BoolFilter<"TechnicianSchedule"> | boolean
    createdAt?: DateTimeFilter<"TechnicianSchedule"> | Date | string
    technician?: XOR<TechnicianRelationFilter, TechnicianWhereInput>
  }

  export type TechnicianScheduleOrderByWithRelationInput = {
    id?: SortOrder
    technicianId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    technician?: TechnicianOrderByWithRelationInput
  }

  export type TechnicianScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TechnicianScheduleWhereInput | TechnicianScheduleWhereInput[]
    OR?: TechnicianScheduleWhereInput[]
    NOT?: TechnicianScheduleWhereInput | TechnicianScheduleWhereInput[]
    technicianId?: StringFilter<"TechnicianSchedule"> | string
    date?: DateTimeFilter<"TechnicianSchedule"> | Date | string
    startTime?: StringFilter<"TechnicianSchedule"> | string
    endTime?: StringFilter<"TechnicianSchedule"> | string
    isAvailable?: BoolFilter<"TechnicianSchedule"> | boolean
    createdAt?: DateTimeFilter<"TechnicianSchedule"> | Date | string
    technician?: XOR<TechnicianRelationFilter, TechnicianWhereInput>
  }, "id">

  export type TechnicianScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    technicianId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    _count?: TechnicianScheduleCountOrderByAggregateInput
    _max?: TechnicianScheduleMaxOrderByAggregateInput
    _min?: TechnicianScheduleMinOrderByAggregateInput
  }

  export type TechnicianScheduleScalarWhereWithAggregatesInput = {
    AND?: TechnicianScheduleScalarWhereWithAggregatesInput | TechnicianScheduleScalarWhereWithAggregatesInput[]
    OR?: TechnicianScheduleScalarWhereWithAggregatesInput[]
    NOT?: TechnicianScheduleScalarWhereWithAggregatesInput | TechnicianScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TechnicianSchedule"> | string
    technicianId?: StringWithAggregatesFilter<"TechnicianSchedule"> | string
    date?: DateTimeWithAggregatesFilter<"TechnicianSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"TechnicianSchedule"> | string
    endTime?: StringWithAggregatesFilter<"TechnicianSchedule"> | string
    isAvailable?: BoolWithAggregatesFilter<"TechnicianSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TechnicianSchedule"> | Date | string
  }

  export type ServiceStatusHistoryWhereInput = {
    AND?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[]
    OR?: ServiceStatusHistoryWhereInput[]
    NOT?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[]
    id?: StringFilter<"ServiceStatusHistory"> | string
    bookingId?: StringFilter<"ServiceStatusHistory"> | string
    status?: StringFilter<"ServiceStatusHistory"> | string
    newStatus?: StringFilter<"ServiceStatusHistory"> | string
    note?: StringNullableFilter<"ServiceStatusHistory"> | string | null
    changedBy?: StringNullableFilter<"ServiceStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"ServiceStatusHistory"> | Date | string
    booking?: XOR<ServiceBookingRelationFilter, ServiceBookingWhereInput>
  }

  export type ServiceStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    status?: SortOrder
    newStatus?: SortOrder
    note?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: ServiceBookingOrderByWithRelationInput
  }

  export type ServiceStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[]
    OR?: ServiceStatusHistoryWhereInput[]
    NOT?: ServiceStatusHistoryWhereInput | ServiceStatusHistoryWhereInput[]
    bookingId?: StringFilter<"ServiceStatusHistory"> | string
    status?: StringFilter<"ServiceStatusHistory"> | string
    newStatus?: StringFilter<"ServiceStatusHistory"> | string
    note?: StringNullableFilter<"ServiceStatusHistory"> | string | null
    changedBy?: StringNullableFilter<"ServiceStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"ServiceStatusHistory"> | Date | string
    booking?: XOR<ServiceBookingRelationFilter, ServiceBookingWhereInput>
  }, "id">

  export type ServiceStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    status?: SortOrder
    newStatus?: SortOrder
    note?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceStatusHistoryCountOrderByAggregateInput
    _max?: ServiceStatusHistoryMaxOrderByAggregateInput
    _min?: ServiceStatusHistoryMinOrderByAggregateInput
  }

  export type ServiceStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: ServiceStatusHistoryScalarWhereWithAggregatesInput | ServiceStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: ServiceStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceStatusHistoryScalarWhereWithAggregatesInput | ServiceStatusHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceStatusHistory"> | string
    bookingId?: StringWithAggregatesFilter<"ServiceStatusHistory"> | string
    status?: StringWithAggregatesFilter<"ServiceStatusHistory"> | string
    newStatus?: StringWithAggregatesFilter<"ServiceStatusHistory"> | string
    note?: StringNullableWithAggregatesFilter<"ServiceStatusHistory"> | string | null
    changedBy?: StringNullableWithAggregatesFilter<"ServiceStatusHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceStatusHistory"> | Date | string
  }

  export type ServicePaymentWhereInput = {
    AND?: ServicePaymentWhereInput | ServicePaymentWhereInput[]
    OR?: ServicePaymentWhereInput[]
    NOT?: ServicePaymentWhereInput | ServicePaymentWhereInput[]
    id?: StringFilter<"ServicePayment"> | string
    bookingId?: StringFilter<"ServicePayment"> | string
    provider?: StringFilter<"ServicePayment"> | string
    amountCents?: IntFilter<"ServicePayment"> | number
    status?: StringFilter<"ServicePayment"> | string
    transactionId?: StringNullableFilter<"ServicePayment"> | string | null
    paidAt?: DateTimeNullableFilter<"ServicePayment"> | Date | string | null
    createdAt?: DateTimeFilter<"ServicePayment"> | Date | string
    booking?: XOR<ServiceBookingRelationFilter, ServiceBookingWhereInput>
  }

  export type ServicePaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: ServiceBookingOrderByWithRelationInput
  }

  export type ServicePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServicePaymentWhereInput | ServicePaymentWhereInput[]
    OR?: ServicePaymentWhereInput[]
    NOT?: ServicePaymentWhereInput | ServicePaymentWhereInput[]
    bookingId?: StringFilter<"ServicePayment"> | string
    provider?: StringFilter<"ServicePayment"> | string
    amountCents?: IntFilter<"ServicePayment"> | number
    status?: StringFilter<"ServicePayment"> | string
    transactionId?: StringNullableFilter<"ServicePayment"> | string | null
    paidAt?: DateTimeNullableFilter<"ServicePayment"> | Date | string | null
    createdAt?: DateTimeFilter<"ServicePayment"> | Date | string
    booking?: XOR<ServiceBookingRelationFilter, ServiceBookingWhereInput>
  }, "id">

  export type ServicePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServicePaymentCountOrderByAggregateInput
    _avg?: ServicePaymentAvgOrderByAggregateInput
    _max?: ServicePaymentMaxOrderByAggregateInput
    _min?: ServicePaymentMinOrderByAggregateInput
    _sum?: ServicePaymentSumOrderByAggregateInput
  }

  export type ServicePaymentScalarWhereWithAggregatesInput = {
    AND?: ServicePaymentScalarWhereWithAggregatesInput | ServicePaymentScalarWhereWithAggregatesInput[]
    OR?: ServicePaymentScalarWhereWithAggregatesInput[]
    NOT?: ServicePaymentScalarWhereWithAggregatesInput | ServicePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicePayment"> | string
    bookingId?: StringWithAggregatesFilter<"ServicePayment"> | string
    provider?: StringWithAggregatesFilter<"ServicePayment"> | string
    amountCents?: IntWithAggregatesFilter<"ServicePayment"> | number
    status?: StringWithAggregatesFilter<"ServicePayment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"ServicePayment"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"ServicePayment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServicePayment"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    code?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    type?: StringFilter<"Promotion"> | string
    value?: IntFilter<"Promotion"> | number
    isActive?: BoolFilter<"Promotion"> | boolean
    expiresAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    type?: StringFilter<"Promotion"> | string
    value?: IntFilter<"Promotion"> | number
    isActive?: BoolFilter<"Promotion"> | boolean
    expiresAt?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
  }, "id" | "code">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    code?: StringWithAggregatesFilter<"Promotion"> | string
    name?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    type?: StringWithAggregatesFilter<"Promotion"> | string
    value?: IntWithAggregatesFilter<"Promotion"> | number
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    title?: StringFilter<"Banner"> | string
    subtitle?: StringNullableFilter<"Banner"> | string | null
    description?: StringNullableFilter<"Banner"> | string | null
    imageUrl?: StringFilter<"Banner"> | string
    mobileImageUrl?: StringNullableFilter<"Banner"> | string | null
    linkUrl?: StringNullableFilter<"Banner"> | string | null
    buttonLabel?: StringNullableFilter<"Banner"> | string | null
    page?: StringFilter<"Banner"> | string
    locale?: StringNullableFilter<"Banner"> | string | null
    position?: IntFilter<"Banner"> | number
    isActive?: BoolFilter<"Banner"> | boolean
    startAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isDeleted?: BoolFilter<"Banner"> | boolean
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    mobileImageUrl?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    buttonLabel?: SortOrderInput | SortOrder
    page?: SortOrder
    locale?: SortOrderInput | SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    title?: StringFilter<"Banner"> | string
    subtitle?: StringNullableFilter<"Banner"> | string | null
    description?: StringNullableFilter<"Banner"> | string | null
    imageUrl?: StringFilter<"Banner"> | string
    mobileImageUrl?: StringNullableFilter<"Banner"> | string | null
    linkUrl?: StringNullableFilter<"Banner"> | string | null
    buttonLabel?: StringNullableFilter<"Banner"> | string | null
    page?: StringFilter<"Banner"> | string
    locale?: StringNullableFilter<"Banner"> | string | null
    position?: IntFilter<"Banner"> | number
    isActive?: BoolFilter<"Banner"> | boolean
    startAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isDeleted?: BoolFilter<"Banner"> | boolean
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    mobileImageUrl?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    buttonLabel?: SortOrderInput | SortOrder
    page?: SortOrder
    locale?: SortOrderInput | SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    title?: StringWithAggregatesFilter<"Banner"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    description?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    imageUrl?: StringWithAggregatesFilter<"Banner"> | string
    mobileImageUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    linkUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    buttonLabel?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    page?: StringWithAggregatesFilter<"Banner"> | string
    locale?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    position?: IntWithAggregatesFilter<"Banner"> | number
    isActive?: BoolWithAggregatesFilter<"Banner"> | boolean
    startAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Banner"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    type?: StringFilter<"SystemConfig"> | string
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    type?: StringFilter<"SystemConfig"> | string
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    type?: StringWithAggregatesFilter<"SystemConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type LoyaltyAccountWhereInput = {
    AND?: LoyaltyAccountWhereInput | LoyaltyAccountWhereInput[]
    OR?: LoyaltyAccountWhereInput[]
    NOT?: LoyaltyAccountWhereInput | LoyaltyAccountWhereInput[]
    id?: StringFilter<"LoyaltyAccount"> | string
    userId?: StringFilter<"LoyaltyAccount"> | string
    points?: IntFilter<"LoyaltyAccount"> | number
    tier?: StringFilter<"LoyaltyAccount"> | string
    isActive?: BoolFilter<"LoyaltyAccount"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyAccount"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: PointTransactionListRelationFilter
    redemptions?: RedemptionHistoryListRelationFilter
  }

  export type LoyaltyAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    tier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: PointTransactionOrderByRelationAggregateInput
    redemptions?: RedemptionHistoryOrderByRelationAggregateInput
  }

  export type LoyaltyAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LoyaltyAccountWhereInput | LoyaltyAccountWhereInput[]
    OR?: LoyaltyAccountWhereInput[]
    NOT?: LoyaltyAccountWhereInput | LoyaltyAccountWhereInput[]
    points?: IntFilter<"LoyaltyAccount"> | number
    tier?: StringFilter<"LoyaltyAccount"> | string
    isActive?: BoolFilter<"LoyaltyAccount"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyAccount"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: PointTransactionListRelationFilter
    redemptions?: RedemptionHistoryListRelationFilter
  }, "id" | "userId">

  export type LoyaltyAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    tier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyAccountCountOrderByAggregateInput
    _avg?: LoyaltyAccountAvgOrderByAggregateInput
    _max?: LoyaltyAccountMaxOrderByAggregateInput
    _min?: LoyaltyAccountMinOrderByAggregateInput
    _sum?: LoyaltyAccountSumOrderByAggregateInput
  }

  export type LoyaltyAccountScalarWhereWithAggregatesInput = {
    AND?: LoyaltyAccountScalarWhereWithAggregatesInput | LoyaltyAccountScalarWhereWithAggregatesInput[]
    OR?: LoyaltyAccountScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyAccountScalarWhereWithAggregatesInput | LoyaltyAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyAccount"> | string
    userId?: StringWithAggregatesFilter<"LoyaltyAccount"> | string
    points?: IntWithAggregatesFilter<"LoyaltyAccount"> | number
    tier?: StringWithAggregatesFilter<"LoyaltyAccount"> | string
    isActive?: BoolWithAggregatesFilter<"LoyaltyAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoyaltyAccount"> | Date | string
  }

  export type PointTransactionWhereInput = {
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    id?: StringFilter<"PointTransaction"> | string
    accountId?: StringFilter<"PointTransaction"> | string
    amount?: IntFilter<"PointTransaction"> | number
    type?: StringFilter<"PointTransaction"> | string
    description?: StringNullableFilter<"PointTransaction"> | string | null
    expiresAt?: DateTimeNullableFilter<"PointTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PointTransaction"> | Date | string
    account?: XOR<LoyaltyAccountRelationFilter, LoyaltyAccountWhereInput>
  }

  export type PointTransactionOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    account?: LoyaltyAccountOrderByWithRelationInput
  }

  export type PointTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    accountId?: StringFilter<"PointTransaction"> | string
    amount?: IntFilter<"PointTransaction"> | number
    type?: StringFilter<"PointTransaction"> | string
    description?: StringNullableFilter<"PointTransaction"> | string | null
    expiresAt?: DateTimeNullableFilter<"PointTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PointTransaction"> | Date | string
    account?: XOR<LoyaltyAccountRelationFilter, LoyaltyAccountWhereInput>
  }, "id">

  export type PointTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PointTransactionCountOrderByAggregateInput
    _avg?: PointTransactionAvgOrderByAggregateInput
    _max?: PointTransactionMaxOrderByAggregateInput
    _min?: PointTransactionMinOrderByAggregateInput
    _sum?: PointTransactionSumOrderByAggregateInput
  }

  export type PointTransactionScalarWhereWithAggregatesInput = {
    AND?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    OR?: PointTransactionScalarWhereWithAggregatesInput[]
    NOT?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointTransaction"> | string
    accountId?: StringWithAggregatesFilter<"PointTransaction"> | string
    amount?: IntWithAggregatesFilter<"PointTransaction"> | number
    type?: StringWithAggregatesFilter<"PointTransaction"> | string
    description?: StringNullableWithAggregatesFilter<"PointTransaction"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PointTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PointTransaction"> | Date | string
  }

  export type RedemptionHistoryWhereInput = {
    AND?: RedemptionHistoryWhereInput | RedemptionHistoryWhereInput[]
    OR?: RedemptionHistoryWhereInput[]
    NOT?: RedemptionHistoryWhereInput | RedemptionHistoryWhereInput[]
    id?: StringFilter<"RedemptionHistory"> | string
    accountId?: StringFilter<"RedemptionHistory"> | string
    rewardId?: StringFilter<"RedemptionHistory"> | string
    pointsUsed?: IntFilter<"RedemptionHistory"> | number
    status?: StringFilter<"RedemptionHistory"> | string
    createdAt?: DateTimeFilter<"RedemptionHistory"> | Date | string
    account?: XOR<LoyaltyAccountRelationFilter, LoyaltyAccountWhereInput>
    reward?: XOR<LoyaltyRewardRelationFilter, LoyaltyRewardWhereInput>
  }

  export type RedemptionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    rewardId?: SortOrder
    pointsUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    account?: LoyaltyAccountOrderByWithRelationInput
    reward?: LoyaltyRewardOrderByWithRelationInput
  }

  export type RedemptionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RedemptionHistoryWhereInput | RedemptionHistoryWhereInput[]
    OR?: RedemptionHistoryWhereInput[]
    NOT?: RedemptionHistoryWhereInput | RedemptionHistoryWhereInput[]
    accountId?: StringFilter<"RedemptionHistory"> | string
    rewardId?: StringFilter<"RedemptionHistory"> | string
    pointsUsed?: IntFilter<"RedemptionHistory"> | number
    status?: StringFilter<"RedemptionHistory"> | string
    createdAt?: DateTimeFilter<"RedemptionHistory"> | Date | string
    account?: XOR<LoyaltyAccountRelationFilter, LoyaltyAccountWhereInput>
    reward?: XOR<LoyaltyRewardRelationFilter, LoyaltyRewardWhereInput>
  }, "id">

  export type RedemptionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    rewardId?: SortOrder
    pointsUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: RedemptionHistoryCountOrderByAggregateInput
    _avg?: RedemptionHistoryAvgOrderByAggregateInput
    _max?: RedemptionHistoryMaxOrderByAggregateInput
    _min?: RedemptionHistoryMinOrderByAggregateInput
    _sum?: RedemptionHistorySumOrderByAggregateInput
  }

  export type RedemptionHistoryScalarWhereWithAggregatesInput = {
    AND?: RedemptionHistoryScalarWhereWithAggregatesInput | RedemptionHistoryScalarWhereWithAggregatesInput[]
    OR?: RedemptionHistoryScalarWhereWithAggregatesInput[]
    NOT?: RedemptionHistoryScalarWhereWithAggregatesInput | RedemptionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RedemptionHistory"> | string
    accountId?: StringWithAggregatesFilter<"RedemptionHistory"> | string
    rewardId?: StringWithAggregatesFilter<"RedemptionHistory"> | string
    pointsUsed?: IntWithAggregatesFilter<"RedemptionHistory"> | number
    status?: StringWithAggregatesFilter<"RedemptionHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RedemptionHistory"> | Date | string
  }

  export type LoyaltyRewardWhereInput = {
    AND?: LoyaltyRewardWhereInput | LoyaltyRewardWhereInput[]
    OR?: LoyaltyRewardWhereInput[]
    NOT?: LoyaltyRewardWhereInput | LoyaltyRewardWhereInput[]
    id?: StringFilter<"LoyaltyReward"> | string
    name?: StringFilter<"LoyaltyReward"> | string
    description?: StringNullableFilter<"LoyaltyReward"> | string | null
    pointsCost?: IntFilter<"LoyaltyReward"> | number
    value?: IntFilter<"LoyaltyReward"> | number
    type?: StringFilter<"LoyaltyReward"> | string
    isActive?: BoolFilter<"LoyaltyReward"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyReward"> | Date | string
    redemptions?: RedemptionHistoryListRelationFilter
  }

  export type LoyaltyRewardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsCost?: SortOrder
    value?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    redemptions?: RedemptionHistoryOrderByRelationAggregateInput
  }

  export type LoyaltyRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyRewardWhereInput | LoyaltyRewardWhereInput[]
    OR?: LoyaltyRewardWhereInput[]
    NOT?: LoyaltyRewardWhereInput | LoyaltyRewardWhereInput[]
    name?: StringFilter<"LoyaltyReward"> | string
    description?: StringNullableFilter<"LoyaltyReward"> | string | null
    pointsCost?: IntFilter<"LoyaltyReward"> | number
    value?: IntFilter<"LoyaltyReward"> | number
    type?: StringFilter<"LoyaltyReward"> | string
    isActive?: BoolFilter<"LoyaltyReward"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyReward"> | Date | string
    redemptions?: RedemptionHistoryListRelationFilter
  }, "id">

  export type LoyaltyRewardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsCost?: SortOrder
    value?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: LoyaltyRewardCountOrderByAggregateInput
    _avg?: LoyaltyRewardAvgOrderByAggregateInput
    _max?: LoyaltyRewardMaxOrderByAggregateInput
    _min?: LoyaltyRewardMinOrderByAggregateInput
    _sum?: LoyaltyRewardSumOrderByAggregateInput
  }

  export type LoyaltyRewardScalarWhereWithAggregatesInput = {
    AND?: LoyaltyRewardScalarWhereWithAggregatesInput | LoyaltyRewardScalarWhereWithAggregatesInput[]
    OR?: LoyaltyRewardScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyRewardScalarWhereWithAggregatesInput | LoyaltyRewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyReward"> | string
    name?: StringWithAggregatesFilter<"LoyaltyReward"> | string
    description?: StringNullableWithAggregatesFilter<"LoyaltyReward"> | string | null
    pointsCost?: IntWithAggregatesFilter<"LoyaltyReward"> | number
    value?: IntWithAggregatesFilter<"LoyaltyReward"> | number
    type?: StringWithAggregatesFilter<"LoyaltyReward"> | string
    isActive?: BoolWithAggregatesFilter<"LoyaltyReward"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyReward"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    events?: StringWithAggregatesFilter<"Webhook"> | string
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type KnowledgeBaseEntryWhereInput = {
    AND?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    OR?: KnowledgeBaseEntryWhereInput[]
    NOT?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    id?: StringFilter<"KnowledgeBaseEntry"> | string
    kind?: StringFilter<"KnowledgeBaseEntry"> | string
    title?: StringFilter<"KnowledgeBaseEntry"> | string
    content?: StringFilter<"KnowledgeBaseEntry"> | string
    productId?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    tags?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    embedding?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    isActive?: BoolFilter<"KnowledgeBaseEntry"> | boolean
    createdAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type KnowledgeBaseEntryOrderByWithRelationInput = {
    id?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    content?: SortOrder
    productId?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type KnowledgeBaseEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    OR?: KnowledgeBaseEntryWhereInput[]
    NOT?: KnowledgeBaseEntryWhereInput | KnowledgeBaseEntryWhereInput[]
    kind?: StringFilter<"KnowledgeBaseEntry"> | string
    title?: StringFilter<"KnowledgeBaseEntry"> | string
    content?: StringFilter<"KnowledgeBaseEntry"> | string
    productId?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    tags?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    embedding?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    isActive?: BoolFilter<"KnowledgeBaseEntry"> | boolean
    createdAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type KnowledgeBaseEntryOrderByWithAggregationInput = {
    id?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    content?: SortOrder
    productId?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeBaseEntryCountOrderByAggregateInput
    _max?: KnowledgeBaseEntryMaxOrderByAggregateInput
    _min?: KnowledgeBaseEntryMinOrderByAggregateInput
  }

  export type KnowledgeBaseEntryScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseEntryScalarWhereWithAggregatesInput | KnowledgeBaseEntryScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseEntryScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseEntryScalarWhereWithAggregatesInput | KnowledgeBaseEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    kind?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    title?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    content?: StringWithAggregatesFilter<"KnowledgeBaseEntry"> | string
    productId?: StringNullableWithAggregatesFilter<"KnowledgeBaseEntry"> | string | null
    tags?: StringNullableWithAggregatesFilter<"KnowledgeBaseEntry"> | string | null
    embedding?: StringNullableWithAggregatesFilter<"KnowledgeBaseEntry"> | string | null
    isActive?: BoolWithAggregatesFilter<"KnowledgeBaseEntry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseEntry"> | Date | string
  }

  export type PaymentIntentWhereInput = {
    AND?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    OR?: PaymentIntentWhereInput[]
    NOT?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    id?: StringFilter<"PaymentIntent"> | string
    orderId?: StringFilter<"PaymentIntent"> | string
    provider?: StringFilter<"PaymentIntent"> | string
    amountCents?: IntFilter<"PaymentIntent"> | number
    status?: StringFilter<"PaymentIntent"> | string
    clientSecret?: StringNullableFilter<"PaymentIntent"> | string | null
    returnUrl?: StringNullableFilter<"PaymentIntent"> | string | null
    metadata?: StringNullableFilter<"PaymentIntent"> | string | null
    createdAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type PaymentIntentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    clientSecret?: SortOrderInput | SortOrder
    returnUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type PaymentIntentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    OR?: PaymentIntentWhereInput[]
    NOT?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    orderId?: StringFilter<"PaymentIntent"> | string
    provider?: StringFilter<"PaymentIntent"> | string
    amountCents?: IntFilter<"PaymentIntent"> | number
    status?: StringFilter<"PaymentIntent"> | string
    clientSecret?: StringNullableFilter<"PaymentIntent"> | string | null
    returnUrl?: StringNullableFilter<"PaymentIntent"> | string | null
    metadata?: StringNullableFilter<"PaymentIntent"> | string | null
    createdAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    payments?: PaymentListRelationFilter
  }, "id">

  export type PaymentIntentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    clientSecret?: SortOrderInput | SortOrder
    returnUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentIntentCountOrderByAggregateInput
    _avg?: PaymentIntentAvgOrderByAggregateInput
    _max?: PaymentIntentMaxOrderByAggregateInput
    _min?: PaymentIntentMinOrderByAggregateInput
    _sum?: PaymentIntentSumOrderByAggregateInput
  }

  export type PaymentIntentScalarWhereWithAggregatesInput = {
    AND?: PaymentIntentScalarWhereWithAggregatesInput | PaymentIntentScalarWhereWithAggregatesInput[]
    OR?: PaymentIntentScalarWhereWithAggregatesInput[]
    NOT?: PaymentIntentScalarWhereWithAggregatesInput | PaymentIntentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentIntent"> | string
    orderId?: StringWithAggregatesFilter<"PaymentIntent"> | string
    provider?: StringWithAggregatesFilter<"PaymentIntent"> | string
    amountCents?: IntWithAggregatesFilter<"PaymentIntent"> | number
    status?: StringWithAggregatesFilter<"PaymentIntent"> | string
    clientSecret?: StringNullableWithAggregatesFilter<"PaymentIntent"> | string | null
    returnUrl?: StringNullableWithAggregatesFilter<"PaymentIntent"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"PaymentIntent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentIntent"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    shortDescription?: StringNullableFilter<"Project"> | string | null
    client?: StringNullableFilter<"Project"> | string | null
    clientLogo?: StringNullableFilter<"Project"> | string | null
    category?: StringNullableFilter<"Project"> | string | null
    technologies?: StringNullableFilter<"Project"> | string | null
    features?: StringNullableFilter<"Project"> | string | null
    images?: StringNullableFilter<"Project"> | string | null
    thumbnailImage?: StringNullableFilter<"Project"> | string | null
    coverImage?: StringNullableFilter<"Project"> | string | null
    youtubeVideoId?: StringNullableFilter<"Project"> | string | null
    youtubeVideoUrl?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    githubUrl?: StringNullableFilter<"Project"> | string | null
    liveUrl?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    teamSize?: IntNullableFilter<"Project"> | number | null
    budget?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    isActive?: BoolFilter<"Project"> | boolean
    isFeatured?: BoolFilter<"Project"> | boolean
    displayOrder?: IntFilter<"Project"> | number
    viewCount?: IntFilter<"Project"> | number
    userId?: StringFilter<"Project"> | string
    tags?: StringNullableFilter<"Project"> | string | null
    testimonial?: StringNullableFilter<"Project"> | string | null
    results?: StringNullableFilter<"Project"> | string | null
    challenges?: StringNullableFilter<"Project"> | string | null
    solutions?: StringNullableFilter<"Project"> | string | null
    metaTitle?: StringNullableFilter<"Project"> | string | null
    metaDescription?: StringNullableFilter<"Project"> | string | null
    metaKeywords?: StringNullableFilter<"Project"> | string | null
    ogTitle?: StringNullableFilter<"Project"> | string | null
    ogDescription?: StringNullableFilter<"Project"> | string | null
    ogImage?: StringNullableFilter<"Project"> | string | null
    structuredData?: StringNullableFilter<"Project"> | string | null
    canonicalUrl?: StringNullableFilter<"Project"> | string | null
    content?: StringNullableFilter<"Project"> | string | null
    galleryImages?: StringNullableFilter<"Project"> | string | null
    clientLogoUrl?: StringNullableFilter<"Project"> | string | null
    projectDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    featured?: BoolFilter<"Project"> | boolean
    isDeleted?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    client?: SortOrderInput | SortOrder
    clientLogo?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    technologies?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    thumbnailImage?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    youtubeVideoId?: SortOrderInput | SortOrder
    youtubeVideoUrl?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    liveUrl?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    viewCount?: SortOrder
    userId?: SortOrder
    tags?: SortOrderInput | SortOrder
    testimonial?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    challenges?: SortOrderInput | SortOrder
    solutions?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    structuredData?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    galleryImages?: SortOrderInput | SortOrder
    clientLogoUrl?: SortOrderInput | SortOrder
    projectDate?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    featured?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    shortDescription?: StringNullableFilter<"Project"> | string | null
    client?: StringNullableFilter<"Project"> | string | null
    clientLogo?: StringNullableFilter<"Project"> | string | null
    category?: StringNullableFilter<"Project"> | string | null
    technologies?: StringNullableFilter<"Project"> | string | null
    features?: StringNullableFilter<"Project"> | string | null
    images?: StringNullableFilter<"Project"> | string | null
    thumbnailImage?: StringNullableFilter<"Project"> | string | null
    coverImage?: StringNullableFilter<"Project"> | string | null
    youtubeVideoId?: StringNullableFilter<"Project"> | string | null
    youtubeVideoUrl?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    githubUrl?: StringNullableFilter<"Project"> | string | null
    liveUrl?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    teamSize?: IntNullableFilter<"Project"> | number | null
    budget?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    isActive?: BoolFilter<"Project"> | boolean
    isFeatured?: BoolFilter<"Project"> | boolean
    displayOrder?: IntFilter<"Project"> | number
    viewCount?: IntFilter<"Project"> | number
    userId?: StringFilter<"Project"> | string
    tags?: StringNullableFilter<"Project"> | string | null
    testimonial?: StringNullableFilter<"Project"> | string | null
    results?: StringNullableFilter<"Project"> | string | null
    challenges?: StringNullableFilter<"Project"> | string | null
    solutions?: StringNullableFilter<"Project"> | string | null
    metaTitle?: StringNullableFilter<"Project"> | string | null
    metaDescription?: StringNullableFilter<"Project"> | string | null
    metaKeywords?: StringNullableFilter<"Project"> | string | null
    ogTitle?: StringNullableFilter<"Project"> | string | null
    ogDescription?: StringNullableFilter<"Project"> | string | null
    ogImage?: StringNullableFilter<"Project"> | string | null
    structuredData?: StringNullableFilter<"Project"> | string | null
    canonicalUrl?: StringNullableFilter<"Project"> | string | null
    content?: StringNullableFilter<"Project"> | string | null
    galleryImages?: StringNullableFilter<"Project"> | string | null
    clientLogoUrl?: StringNullableFilter<"Project"> | string | null
    projectDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    featured?: BoolFilter<"Project"> | boolean
    isDeleted?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    client?: SortOrderInput | SortOrder
    clientLogo?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    technologies?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    thumbnailImage?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    youtubeVideoId?: SortOrderInput | SortOrder
    youtubeVideoUrl?: SortOrderInput | SortOrder
    demoUrl?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    liveUrl?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    viewCount?: SortOrder
    userId?: SortOrder
    tags?: SortOrderInput | SortOrder
    testimonial?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    challenges?: SortOrderInput | SortOrder
    solutions?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    ogTitle?: SortOrderInput | SortOrder
    ogDescription?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    structuredData?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    galleryImages?: SortOrderInput | SortOrder
    clientLogoUrl?: SortOrderInput | SortOrder
    projectDate?: SortOrderInput | SortOrder
    completionDate?: SortOrderInput | SortOrder
    featured?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    slug?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    shortDescription?: StringNullableWithAggregatesFilter<"Project"> | string | null
    client?: StringNullableWithAggregatesFilter<"Project"> | string | null
    clientLogo?: StringNullableWithAggregatesFilter<"Project"> | string | null
    category?: StringNullableWithAggregatesFilter<"Project"> | string | null
    technologies?: StringNullableWithAggregatesFilter<"Project"> | string | null
    features?: StringNullableWithAggregatesFilter<"Project"> | string | null
    images?: StringNullableWithAggregatesFilter<"Project"> | string | null
    thumbnailImage?: StringNullableWithAggregatesFilter<"Project"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Project"> | string | null
    youtubeVideoId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    youtubeVideoUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    demoUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    githubUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    liveUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    duration?: StringNullableWithAggregatesFilter<"Project"> | string | null
    teamSize?: IntNullableWithAggregatesFilter<"Project"> | number | null
    budget?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: StringWithAggregatesFilter<"Project"> | string
    isActive?: BoolWithAggregatesFilter<"Project"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Project"> | boolean
    displayOrder?: IntWithAggregatesFilter<"Project"> | number
    viewCount?: IntWithAggregatesFilter<"Project"> | number
    userId?: StringWithAggregatesFilter<"Project"> | string
    tags?: StringNullableWithAggregatesFilter<"Project"> | string | null
    testimonial?: StringNullableWithAggregatesFilter<"Project"> | string | null
    results?: StringNullableWithAggregatesFilter<"Project"> | string | null
    challenges?: StringNullableWithAggregatesFilter<"Project"> | string | null
    solutions?: StringNullableWithAggregatesFilter<"Project"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Project"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Project"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"Project"> | string | null
    ogTitle?: StringNullableWithAggregatesFilter<"Project"> | string | null
    ogDescription?: StringNullableWithAggregatesFilter<"Project"> | string | null
    ogImage?: StringNullableWithAggregatesFilter<"Project"> | string | null
    structuredData?: StringNullableWithAggregatesFilter<"Project"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    content?: StringNullableWithAggregatesFilter<"Project"> | string | null
    galleryImages?: StringNullableWithAggregatesFilter<"Project"> | string | null
    clientLogoUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    projectDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    completionDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    featured?: BoolWithAggregatesFilter<"Project"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Project"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    resource?: StringNullableFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableFilter<"ActivityLog"> | string | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    method?: StringNullableFilter<"ActivityLog"> | string | null
    url?: StringNullableFilter<"ActivityLog"> | string | null
    statusCode?: IntNullableFilter<"ActivityLog"> | number | null
    duration?: IntNullableFilter<"ActivityLog"> | number | null
    category?: StringFilter<"ActivityLog"> | string
    severity?: StringFilter<"ActivityLog"> | string
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    category?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    resource?: StringNullableFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableFilter<"ActivityLog"> | string | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    method?: StringNullableFilter<"ActivityLog"> | string | null
    url?: StringNullableFilter<"ActivityLog"> | string | null
    statusCode?: IntNullableFilter<"ActivityLog"> | number | null
    duration?: IntNullableFilter<"ActivityLog"> | number | null
    category?: StringFilter<"ActivityLog"> | string
    severity?: StringFilter<"ActivityLog"> | string
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    category?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    resource?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    details?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    method?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    url?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    statusCode?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    duration?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    category?: StringWithAggregatesFilter<"ActivityLog"> | string
    severity?: StringWithAggregatesFilter<"ActivityLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    type?: EnumCampaignTypeFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    targetAudience?: StringNullableFilter<"Campaign"> | string | null
    discountPercent?: IntNullableFilter<"Campaign"> | number | null
    discountAmount?: IntNullableFilter<"Campaign"> | number | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    clicks?: CampaignClickListRelationFilter
    opens?: CampaignOpenListRelationFilter
    recipients?: CampaignRecipientListRelationFilter
    emailLogs?: EmailLogListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    discountPercent?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clicks?: CampaignClickOrderByRelationAggregateInput
    opens?: CampaignOpenOrderByRelationAggregateInput
    recipients?: CampaignRecipientOrderByRelationAggregateInput
    emailLogs?: EmailLogOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    type?: EnumCampaignTypeFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    targetAudience?: StringNullableFilter<"Campaign"> | string | null
    discountPercent?: IntNullableFilter<"Campaign"> | number | null
    discountAmount?: IntNullableFilter<"Campaign"> | number | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    clicks?: CampaignClickListRelationFilter
    opens?: CampaignOpenListRelationFilter
    recipients?: CampaignRecipientListRelationFilter
    emailLogs?: EmailLogListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    discountPercent?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringWithAggregatesFilter<"Campaign"> | string
    type?: EnumCampaignTypeWithAggregatesFilter<"Campaign"> | $Enums.CampaignType
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    targetAudience?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    discountPercent?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    discountAmount?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignRecipientWhereInput = {
    AND?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    OR?: CampaignRecipientWhereInput[]
    NOT?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    id?: StringFilter<"CampaignRecipient"> | string
    campaignId?: StringFilter<"CampaignRecipient"> | string
    email?: StringFilter<"CampaignRecipient"> | string
    name?: StringNullableFilter<"CampaignRecipient"> | string | null
    createdAt?: DateTimeFilter<"CampaignRecipient"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignRecipientOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    OR?: CampaignRecipientWhereInput[]
    NOT?: CampaignRecipientWhereInput | CampaignRecipientWhereInput[]
    campaignId?: StringFilter<"CampaignRecipient"> | string
    email?: StringFilter<"CampaignRecipient"> | string
    name?: StringNullableFilter<"CampaignRecipient"> | string | null
    createdAt?: DateTimeFilter<"CampaignRecipient"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignRecipientCountOrderByAggregateInput
    _max?: CampaignRecipientMaxOrderByAggregateInput
    _min?: CampaignRecipientMinOrderByAggregateInput
  }

  export type CampaignRecipientScalarWhereWithAggregatesInput = {
    AND?: CampaignRecipientScalarWhereWithAggregatesInput | CampaignRecipientScalarWhereWithAggregatesInput[]
    OR?: CampaignRecipientScalarWhereWithAggregatesInput[]
    NOT?: CampaignRecipientScalarWhereWithAggregatesInput | CampaignRecipientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignRecipient"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignRecipient"> | string
    email?: StringWithAggregatesFilter<"CampaignRecipient"> | string
    name?: StringNullableWithAggregatesFilter<"CampaignRecipient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignRecipient"> | Date | string
  }

  export type CampaignOpenWhereInput = {
    AND?: CampaignOpenWhereInput | CampaignOpenWhereInput[]
    OR?: CampaignOpenWhereInput[]
    NOT?: CampaignOpenWhereInput | CampaignOpenWhereInput[]
    id?: StringFilter<"CampaignOpen"> | string
    campaignId?: StringFilter<"CampaignOpen"> | string
    recipientEmail?: StringNullableFilter<"CampaignOpen"> | string | null
    createdAt?: DateTimeFilter<"CampaignOpen"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignOpenOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignOpenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignOpenWhereInput | CampaignOpenWhereInput[]
    OR?: CampaignOpenWhereInput[]
    NOT?: CampaignOpenWhereInput | CampaignOpenWhereInput[]
    campaignId?: StringFilter<"CampaignOpen"> | string
    recipientEmail?: StringNullableFilter<"CampaignOpen"> | string | null
    createdAt?: DateTimeFilter<"CampaignOpen"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignOpenOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignOpenCountOrderByAggregateInput
    _max?: CampaignOpenMaxOrderByAggregateInput
    _min?: CampaignOpenMinOrderByAggregateInput
  }

  export type CampaignOpenScalarWhereWithAggregatesInput = {
    AND?: CampaignOpenScalarWhereWithAggregatesInput | CampaignOpenScalarWhereWithAggregatesInput[]
    OR?: CampaignOpenScalarWhereWithAggregatesInput[]
    NOT?: CampaignOpenScalarWhereWithAggregatesInput | CampaignOpenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignOpen"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignOpen"> | string
    recipientEmail?: StringNullableWithAggregatesFilter<"CampaignOpen"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignOpen"> | Date | string
  }

  export type CampaignClickWhereInput = {
    AND?: CampaignClickWhereInput | CampaignClickWhereInput[]
    OR?: CampaignClickWhereInput[]
    NOT?: CampaignClickWhereInput | CampaignClickWhereInput[]
    id?: StringFilter<"CampaignClick"> | string
    campaignId?: StringFilter<"CampaignClick"> | string
    recipientEmail?: StringNullableFilter<"CampaignClick"> | string | null
    url?: StringNullableFilter<"CampaignClick"> | string | null
    createdAt?: DateTimeFilter<"CampaignClick"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignClickOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignClickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignClickWhereInput | CampaignClickWhereInput[]
    OR?: CampaignClickWhereInput[]
    NOT?: CampaignClickWhereInput | CampaignClickWhereInput[]
    campaignId?: StringFilter<"CampaignClick"> | string
    recipientEmail?: StringNullableFilter<"CampaignClick"> | string | null
    url?: StringNullableFilter<"CampaignClick"> | string | null
    createdAt?: DateTimeFilter<"CampaignClick"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignClickOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignClickCountOrderByAggregateInput
    _max?: CampaignClickMaxOrderByAggregateInput
    _min?: CampaignClickMinOrderByAggregateInput
  }

  export type CampaignClickScalarWhereWithAggregatesInput = {
    AND?: CampaignClickScalarWhereWithAggregatesInput | CampaignClickScalarWhereWithAggregatesInput[]
    OR?: CampaignClickScalarWhereWithAggregatesInput[]
    NOT?: CampaignClickScalarWhereWithAggregatesInput | CampaignClickScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignClick"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignClick"> | string
    recipientEmail?: StringNullableWithAggregatesFilter<"CampaignClick"> | string | null
    url?: StringNullableWithAggregatesFilter<"CampaignClick"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignClick"> | Date | string
  }

  export type EmailLogWhereInput = {
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    campaignId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    status?: StringFilter<"EmailLog"> | string
    error?: StringNullableFilter<"EmailLog"> | string | null
    sentAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
  }

  export type EmailLogOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type EmailLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    campaignId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    status?: StringFilter<"EmailLog"> | string
    error?: StringNullableFilter<"EmailLog"> | string | null
    sentAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
  }, "id">

  export type EmailLogOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailLogCountOrderByAggregateInput
    _max?: EmailLogMaxOrderByAggregateInput
    _min?: EmailLogMinOrderByAggregateInput
  }

  export type EmailLogScalarWhereWithAggregatesInput = {
    AND?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    OR?: EmailLogScalarWhereWithAggregatesInput[]
    NOT?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLog"> | string
    campaignId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    recipientEmail?: StringWithAggregatesFilter<"EmailLog"> | string
    subject?: StringWithAggregatesFilter<"EmailLog"> | string
    status?: StringWithAggregatesFilter<"EmailLog"> | string
    error?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"EmailLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
  }

  export type contact_messagesWhereInput = {
    AND?: contact_messagesWhereInput | contact_messagesWhereInput[]
    OR?: contact_messagesWhereInput[]
    NOT?: contact_messagesWhereInput | contact_messagesWhereInput[]
    id?: StringFilter<"contact_messages"> | string
    name?: StringFilter<"contact_messages"> | string
    email?: StringFilter<"contact_messages"> | string
    phone?: StringNullableFilter<"contact_messages"> | string | null
    subject?: StringFilter<"contact_messages"> | string
    message?: StringFilter<"contact_messages"> | string
    company?: StringNullableFilter<"contact_messages"> | string | null
    serviceType?: StringNullableFilter<"contact_messages"> | string | null
    isRead?: BoolFilter<"contact_messages"> | boolean
    createdAt?: DateTimeFilter<"contact_messages"> | Date | string
    updatedAt?: DateTimeFilter<"contact_messages"> | Date | string
  }

  export type contact_messagesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    company?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contact_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: contact_messagesWhereInput | contact_messagesWhereInput[]
    OR?: contact_messagesWhereInput[]
    NOT?: contact_messagesWhereInput | contact_messagesWhereInput[]
    name?: StringFilter<"contact_messages"> | string
    email?: StringFilter<"contact_messages"> | string
    phone?: StringNullableFilter<"contact_messages"> | string | null
    subject?: StringFilter<"contact_messages"> | string
    message?: StringFilter<"contact_messages"> | string
    company?: StringNullableFilter<"contact_messages"> | string | null
    serviceType?: StringNullableFilter<"contact_messages"> | string | null
    isRead?: BoolFilter<"contact_messages"> | boolean
    createdAt?: DateTimeFilter<"contact_messages"> | Date | string
    updatedAt?: DateTimeFilter<"contact_messages"> | Date | string
  }, "id">

  export type contact_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    company?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: contact_messagesCountOrderByAggregateInput
    _max?: contact_messagesMaxOrderByAggregateInput
    _min?: contact_messagesMinOrderByAggregateInput
  }

  export type contact_messagesScalarWhereWithAggregatesInput = {
    AND?: contact_messagesScalarWhereWithAggregatesInput | contact_messagesScalarWhereWithAggregatesInput[]
    OR?: contact_messagesScalarWhereWithAggregatesInput[]
    NOT?: contact_messagesScalarWhereWithAggregatesInput | contact_messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contact_messages"> | string
    name?: StringWithAggregatesFilter<"contact_messages"> | string
    email?: StringWithAggregatesFilter<"contact_messages"> | string
    phone?: StringNullableWithAggregatesFilter<"contact_messages"> | string | null
    subject?: StringWithAggregatesFilter<"contact_messages"> | string
    message?: StringWithAggregatesFilter<"contact_messages"> | string
    company?: StringNullableWithAggregatesFilter<"contact_messages"> | string | null
    serviceType?: StringNullableWithAggregatesFilter<"contact_messages"> | string | null
    isRead?: BoolWithAggregatesFilter<"contact_messages"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"contact_messages"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"contact_messages"> | Date | string
  }

  export type site_settingsWhereInput = {
    AND?: site_settingsWhereInput | site_settingsWhereInput[]
    OR?: site_settingsWhereInput[]
    NOT?: site_settingsWhereInput | site_settingsWhereInput[]
    id?: StringFilter<"site_settings"> | string
    key?: StringFilter<"site_settings"> | string
    value?: StringFilter<"site_settings"> | string
    createdAt?: DateTimeFilter<"site_settings"> | Date | string
    updatedAt?: DateTimeFilter<"site_settings"> | Date | string
  }

  export type site_settingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type site_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: site_settingsWhereInput | site_settingsWhereInput[]
    OR?: site_settingsWhereInput[]
    NOT?: site_settingsWhereInput | site_settingsWhereInput[]
    value?: StringFilter<"site_settings"> | string
    createdAt?: DateTimeFilter<"site_settings"> | Date | string
    updatedAt?: DateTimeFilter<"site_settings"> | Date | string
  }, "id" | "key">

  export type site_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: site_settingsCountOrderByAggregateInput
    _max?: site_settingsMaxOrderByAggregateInput
    _min?: site_settingsMinOrderByAggregateInput
  }

  export type site_settingsScalarWhereWithAggregatesInput = {
    AND?: site_settingsScalarWhereWithAggregatesInput | site_settingsScalarWhereWithAggregatesInput[]
    OR?: site_settingsScalarWhereWithAggregatesInput[]
    NOT?: site_settingsScalarWhereWithAggregatesInput | site_settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"site_settings"> | string
    key?: StringWithAggregatesFilter<"site_settings"> | string
    value?: StringWithAggregatesFilter<"site_settings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"site_settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"site_settings"> | Date | string
  }

  export type softwareWhereInput = {
    AND?: softwareWhereInput | softwareWhereInput[]
    OR?: softwareWhereInput[]
    NOT?: softwareWhereInput | softwareWhereInput[]
    id?: StringFilter<"software"> | string
    name?: StringFilter<"software"> | string
    slug?: StringFilter<"software"> | string
    description?: StringNullableFilter<"software"> | string | null
    category?: StringFilter<"software"> | string
    platform?: StringFilter<"software"> | string
    version?: StringNullableFilter<"software"> | string | null
    downloadUrl?: StringNullableFilter<"software"> | string | null
    websiteUrl?: StringNullableFilter<"software"> | string | null
    imageUrl?: StringNullableFilter<"software"> | string | null
    features?: StringNullableFilter<"software"> | string | null
    isActive?: BoolFilter<"software"> | boolean
    isDeleted?: BoolFilter<"software"> | boolean
    createdAt?: DateTimeFilter<"software"> | Date | string
    updatedAt?: DateTimeFilter<"software"> | Date | string
  }

  export type softwareOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    platform?: SortOrder
    version?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type softwareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: softwareWhereInput | softwareWhereInput[]
    OR?: softwareWhereInput[]
    NOT?: softwareWhereInput | softwareWhereInput[]
    name?: StringFilter<"software"> | string
    description?: StringNullableFilter<"software"> | string | null
    category?: StringFilter<"software"> | string
    platform?: StringFilter<"software"> | string
    version?: StringNullableFilter<"software"> | string | null
    downloadUrl?: StringNullableFilter<"software"> | string | null
    websiteUrl?: StringNullableFilter<"software"> | string | null
    imageUrl?: StringNullableFilter<"software"> | string | null
    features?: StringNullableFilter<"software"> | string | null
    isActive?: BoolFilter<"software"> | boolean
    isDeleted?: BoolFilter<"software"> | boolean
    createdAt?: DateTimeFilter<"software"> | Date | string
    updatedAt?: DateTimeFilter<"software"> | Date | string
  }, "id" | "slug">

  export type softwareOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    platform?: SortOrder
    version?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: softwareCountOrderByAggregateInput
    _max?: softwareMaxOrderByAggregateInput
    _min?: softwareMinOrderByAggregateInput
  }

  export type softwareScalarWhereWithAggregatesInput = {
    AND?: softwareScalarWhereWithAggregatesInput | softwareScalarWhereWithAggregatesInput[]
    OR?: softwareScalarWhereWithAggregatesInput[]
    NOT?: softwareScalarWhereWithAggregatesInput | softwareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"software"> | string
    name?: StringWithAggregatesFilter<"software"> | string
    slug?: StringWithAggregatesFilter<"software"> | string
    description?: StringNullableWithAggregatesFilter<"software"> | string | null
    category?: StringWithAggregatesFilter<"software"> | string
    platform?: StringWithAggregatesFilter<"software"> | string
    version?: StringNullableWithAggregatesFilter<"software"> | string | null
    downloadUrl?: StringNullableWithAggregatesFilter<"software"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"software"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"software"> | string | null
    features?: StringNullableWithAggregatesFilter<"software"> | string | null
    isActive?: BoolWithAggregatesFilter<"software"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"software"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"software"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"software"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartCreateInput = {
    id?: string
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemCreateNestedManyWithoutCartInput
    user?: UserCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    userId?: string | null
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUpdateManyWithoutCartNestedInput
    user?: UserUpdateOneWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    userId?: string | null
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNo: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNo: string
    userId: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNo: string
    userId: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intent?: PaymentIntentCreateNestedOneWithoutPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderId: string
    intentId?: string | null
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intent?: PaymentIntentUpdateOneWithoutPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    intentId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderId: string
    intentId?: string | null
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    intentId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateInput = {
    id?: string
    amountCents: number
    reason?: string | null
    status?: string
    providerRefundId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errorMessage?: string | null
    payment: PaymentCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateInput = {
    id?: string
    paymentId: string
    amountCents: number
    reason?: string | null
    status?: string
    providerRefundId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errorMessage?: string | null
  }

  export type RefundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUpdateOneRequiredWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundCreateManyInput = {
    id?: string
    paymentId: string
    amountCents: number
    reason?: string | null
    status?: string
    providerRefundId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errorMessage?: string | null
  }

  export type RefundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceTypeCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutServiceTypeInput
  }

  export type ServiceTypeUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutServiceTypeInput
  }

  export type ServiceTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutServiceTypeNestedInput
  }

  export type ServiceTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutServiceTypeNestedInput
  }

  export type ServiceTypeCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingCreateNestedManyWithoutServiceInput
    items?: ServiceItemCreateNestedManyWithoutServiceInput
    views?: ServiceViewCreateNestedManyWithoutServiceInput
    serviceType?: ServiceTypeCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    typeId?: string | null
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutServiceInput
    items?: ServiceItemUncheckedCreateNestedManyWithoutServiceInput
    views?: ServiceViewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUpdateManyWithoutServiceNestedInput
    items?: ServiceItemUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUpdateManyWithoutServiceNestedInput
    serviceType?: ServiceTypeUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput
    items?: ServiceItemUncheckedUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    typeId?: string | null
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    stock?: number
    reserved?: number
    lowStockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    productId: string
    stock?: number
    reserved?: number
    lowStockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    reserved?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    reserved?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyInput = {
    id?: string
    productId: string
    stock?: number
    reserved?: number
    lowStockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    reserved?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    reserved?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateInput = {
    id?: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryMovementInput
    user?: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: string
    productId: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    userId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryMovementNestedInput
    user?: UserUpdateOneWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: string
    productId: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    userId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAlertCreateInput = {
    id?: string
    type: string
    message: string
    threshold?: number | null
    currentStock: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryAlertInput
  }

  export type InventoryAlertUncheckedCreateInput = {
    id?: string
    productId: string
    type: string
    message: string
    threshold?: number | null
    currentStock: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    currentStock?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryAlertNestedInput
  }

  export type InventoryAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    currentStock?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAlertCreateManyInput = {
    id?: string
    productId: string
    type: string
    message: string
    threshold?: number | null
    currentStock: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    currentStock?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    currentStock?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryReportCreateInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    parameters?: string | null
    data?: string | null
    generatedBy?: string | null
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryReportUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    parameters?: string | null
    data?: string | null
    generatedBy?: string | null
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryReportCreateManyInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    parameters?: string | null
    data?: string | null
    generatedBy?: string | null
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    generatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateInput = {
    id?: string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutWishlistItemsInput
    user: UserCreateNestedOneWithoutWishlistItemsInput
  }

  export type WishlistItemUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    createdAt?: Date | string
  }

  export type WishlistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutWishlistItemsNestedInput
    user?: UserUpdateOneRequiredWithoutWishlistItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateManyInput = {
    id?: string
    userId: string
    productId: string
    createdAt?: Date | string
  }

  export type WishlistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewCreateInput = {
    id?: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportCreateNestedManyWithoutReviewInput
    votes?: ProductReviewVoteCreateNestedManyWithoutReviewInput
    product: ProductCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ProductReviewUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportUncheckedCreateNestedManyWithoutReviewInput
    votes?: ProductReviewVoteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUpdateManyWithoutReviewNestedInput
    votes?: ProductReviewVoteUpdateManyWithoutReviewNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ProductReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ProductReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewCreateManyInput = {
    id?: string
    userId: string
    productId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewVoteCreateInput = {
    id?: string
    userId: string
    isUpvote?: boolean
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutVotesInput
  }

  export type ProductReviewVoteUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    isUpvote?: boolean
    createdAt?: Date | string
  }

  export type ProductReviewVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutVotesNestedInput
  }

  export type ProductReviewVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewVoteCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    isUpvote?: boolean
    createdAt?: Date | string
  }

  export type ProductReviewVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewReportCreateInput = {
    id?: string
    userId: string
    reason: string
    createdAt?: Date | string
    review: ProductReviewCreateNestedOneWithoutReportsInput
  }

  export type ProductReviewReportUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ProductReviewReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ProductReviewUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ProductReviewReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewReportCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ProductReviewReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateInput = {
    id?: string
    slug: string
    title: string
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateManyInput = {
    id?: string
    slug: string
    title: string
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateInput = {
    id?: string
    query: string
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutSearchQueriesInput
  }

  export type SearchQueryUncheckedCreateInput = {
    id?: string
    query: string
    userId?: string | null
    timestamp?: Date | string
  }

  export type SearchQueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSearchQueriesNestedInput
  }

  export type SearchQueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateManyInput = {
    id?: string
    query: string
    userId?: string | null
    timestamp?: Date | string
  }

  export type SearchQueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewCreateInput = {
    id?: string
    timestamp?: Date | string
    duration?: number | null
    product: ProductCreateNestedOneWithoutViewsInput
    user?: UserCreateNestedOneWithoutProductViewsInput
  }

  export type ProductViewUncheckedCreateInput = {
    id?: string
    productId: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type ProductViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductUpdateOneRequiredWithoutViewsNestedInput
    user?: UserUpdateOneWithoutProductViewsNestedInput
  }

  export type ProductViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductViewCreateManyInput = {
    id?: string
    productId: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type ProductViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceViewCreateInput = {
    id?: string
    timestamp?: Date | string
    duration?: number | null
    service: ServiceCreateNestedOneWithoutViewsInput
    user?: UserCreateNestedOneWithoutServiceViewsInput
  }

  export type ServiceViewUncheckedCreateInput = {
    id?: string
    serviceId: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type ServiceViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    service?: ServiceUpdateOneRequiredWithoutViewsNestedInput
    user?: UserUpdateOneWithoutServiceViewsNestedInput
  }

  export type ServiceViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceViewCreateManyInput = {
    id?: string
    serviceId: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type ServiceViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CustomerQuestionCreateInput = {
    id?: string
    question: string
    category?: string | null
    satisfaction?: number | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutQuestionsInput
  }

  export type CustomerQuestionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    question: string
    category?: string | null
    satisfaction?: number | null
    timestamp?: Date | string
  }

  export type CustomerQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutQuestionsNestedInput
  }

  export type CustomerQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerQuestionCreateManyInput = {
    id?: string
    userId?: string | null
    question: string
    category?: string | null
    satisfaction?: number | null
    timestamp?: Date | string
  }

  export type CustomerQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    specialties?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bookings?: ServiceBookingCreateNestedManyWithoutTechnicianInput
    schedules?: TechnicianScheduleCreateNestedManyWithoutTechnicianInput
  }

  export type TechnicianUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    specialties?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutTechnicianInput
    schedules?: TechnicianScheduleUncheckedCreateNestedManyWithoutTechnicianInput
  }

  export type TechnicianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUpdateManyWithoutTechnicianNestedInput
    schedules?: TechnicianScheduleUpdateManyWithoutTechnicianNestedInput
  }

  export type TechnicianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutTechnicianNestedInput
    schedules?: TechnicianScheduleUncheckedUpdateManyWithoutTechnicianNestedInput
  }

  export type TechnicianCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    specialties?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TechnicianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceItemCreateInput = {
    id?: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
    bookingItems?: ServiceBookingItemCreateNestedManyWithoutServiceItemInput
    service: ServiceCreateNestedOneWithoutItemsInput
  }

  export type ServiceItemUncheckedCreateInput = {
    id?: string
    serviceId: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
    bookingItems?: ServiceBookingItemUncheckedCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingItems?: ServiceBookingItemUpdateManyWithoutServiceItemNestedInput
    service?: ServiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ServiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingItems?: ServiceBookingItemUncheckedUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemCreateManyInput = {
    id?: string
    serviceId: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
  }

  export type ServiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingCreateInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemCreateNestedManyWithoutBookingInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    technician?: TechnicianCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingInput
    payments?: ServicePaymentCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemUncheckedCreateNestedManyWithoutBookingInput
    payments?: ServicePaymentUncheckedCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUpdateManyWithoutBookingNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    technician?: TechnicianUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingNestedInput
    payments?: ServicePaymentUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUncheckedUpdateManyWithoutBookingNestedInput
    payments?: ServicePaymentUncheckedUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingItemCreateInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    booking: ServiceBookingCreateNestedOneWithoutItemsInput
    serviceItem: ServiceItemCreateNestedOneWithoutBookingItemsInput
  }

  export type ServiceBookingItemUncheckedCreateInput = {
    id?: string
    bookingId: string
    serviceItemId: string
    quantity: number
    price: number
    createdAt?: Date | string
  }

  export type ServiceBookingItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: ServiceBookingUpdateOneRequiredWithoutItemsNestedInput
    serviceItem?: ServiceItemUpdateOneRequiredWithoutBookingItemsNestedInput
  }

  export type ServiceBookingItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingItemCreateManyInput = {
    id?: string
    bookingId: string
    serviceItemId: string
    quantity: number
    price: number
    createdAt?: Date | string
  }

  export type ServiceBookingItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianScheduleCreateInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
    technician: TechnicianCreateNestedOneWithoutSchedulesInput
  }

  export type TechnicianScheduleUncheckedCreateInput = {
    id?: string
    technicianId: string
    date: Date | string
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type TechnicianScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    technician?: TechnicianUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type TechnicianScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianScheduleCreateManyInput = {
    id?: string
    technicianId: string
    date: Date | string
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type TechnicianScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    technicianId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusHistoryCreateInput = {
    id?: string
    status: string
    newStatus: string
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
    booking: ServiceBookingCreateNestedOneWithoutHistoryInput
  }

  export type ServiceStatusHistoryUncheckedCreateInput = {
    id?: string
    bookingId: string
    status: string
    newStatus: string
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceStatusHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: ServiceBookingUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ServiceStatusHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusHistoryCreateManyInput = {
    id?: string
    bookingId: string
    status: string
    newStatus: string
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceStatusHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePaymentCreateInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    booking: ServiceBookingCreateNestedOneWithoutPaymentsInput
  }

  export type ServicePaymentUncheckedCreateInput = {
    id?: string
    bookingId: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServicePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: ServiceBookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type ServicePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePaymentCreateManyInput = {
    id?: string
    bookingId: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServicePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type?: string
    value: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type?: string
    value: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type?: string
    value: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    description?: string | null
    imageUrl: string
    mobileImageUrl?: string | null
    linkUrl?: string | null
    buttonLabel?: string | null
    page?: string
    locale?: string | null
    position?: number
    isActive?: boolean
    startAt?: Date | string | null
    endAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    description?: string | null
    imageUrl: string
    mobileImageUrl?: string | null
    linkUrl?: string | null
    buttonLabel?: string | null
    page?: string
    locale?: string | null
    position?: number
    isActive?: boolean
    startAt?: Date | string | null
    endAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonLabel?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonLabel?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateManyInput = {
    id?: string
    title: string
    subtitle?: string | null
    description?: string | null
    imageUrl: string
    mobileImageUrl?: string | null
    linkUrl?: string | null
    buttonLabel?: string | null
    page?: string
    locale?: string | null
    position?: number
    isActive?: boolean
    startAt?: Date | string | null
    endAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonLabel?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    mobileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    buttonLabel?: NullableStringFieldUpdateOperationsInput | string | null
    page?: StringFieldUpdateOperationsInput | string
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyAccountCreateInput = {
    id?: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLoyaltyAccountInput
    transactions?: PointTransactionCreateNestedManyWithoutAccountInput
    redemptions?: RedemptionHistoryCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountUncheckedCreateInput = {
    id?: string
    userId: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutAccountInput
    redemptions?: RedemptionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoyaltyAccountNestedInput
    transactions?: PointTransactionUpdateManyWithoutAccountNestedInput
    redemptions?: RedemptionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type LoyaltyAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: PointTransactionUncheckedUpdateManyWithoutAccountNestedInput
    redemptions?: RedemptionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type LoyaltyAccountCreateManyInput = {
    id?: string
    userId: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionCreateInput = {
    id?: string
    amount: number
    type: string
    description?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    account: LoyaltyAccountCreateNestedOneWithoutTransactionsInput
  }

  export type PointTransactionUncheckedCreateInput = {
    id?: string
    accountId: string
    amount: number
    type: string
    description?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PointTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: LoyaltyAccountUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type PointTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionCreateManyInput = {
    id?: string
    accountId: string
    amount: number
    type: string
    description?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PointTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryCreateInput = {
    id?: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
    account: LoyaltyAccountCreateNestedOneWithoutRedemptionsInput
    reward: LoyaltyRewardCreateNestedOneWithoutRedemptionsInput
  }

  export type RedemptionHistoryUncheckedCreateInput = {
    id?: string
    accountId: string
    rewardId: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
  }

  export type RedemptionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: LoyaltyAccountUpdateOneRequiredWithoutRedemptionsNestedInput
    reward?: LoyaltyRewardUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type RedemptionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryCreateManyInput = {
    id?: string
    accountId: string
    rewardId: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
  }

  export type RedemptionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyRewardCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsCost: number
    value: number
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    redemptions?: RedemptionHistoryCreateNestedManyWithoutRewardInput
  }

  export type LoyaltyRewardUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsCost: number
    value: number
    type?: string
    isActive?: boolean
    createdAt?: Date | string
    redemptions?: RedemptionHistoryUncheckedCreateNestedManyWithoutRewardInput
  }

  export type LoyaltyRewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsCost?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: RedemptionHistoryUpdateManyWithoutRewardNestedInput
  }

  export type LoyaltyRewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsCost?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: RedemptionHistoryUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type LoyaltyRewardCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    pointsCost: number
    value: number
    type?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type LoyaltyRewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsCost?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyRewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsCost?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    id?: string
    url: string
    secret: string
    events: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    url: string
    secret: string
    events: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateManyInput = {
    id?: string
    url: string
    secret: string
    events: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryCreateInput = {
    id?: string
    kind: string
    title: string
    content: string
    tags?: string | null
    embedding?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutKnowledgeEntriesInput
  }

  export type KnowledgeBaseEntryUncheckedCreateInput = {
    id?: string
    kind: string
    title: string
    content: string
    productId?: string | null
    tags?: string | null
    embedding?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutKnowledgeEntriesNestedInput
  }

  export type KnowledgeBaseEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryCreateManyInput = {
    id?: string
    kind: string
    title: string
    content: string
    productId?: string | null
    tags?: string | null
    embedding?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentCreateInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentIntentsInput
    payments?: PaymentCreateNestedManyWithoutIntentInput
  }

  export type PaymentIntentUncheckedCreateInput = {
    id?: string
    orderId: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutIntentInput
  }

  export type PaymentIntentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentIntentsNestedInput
    payments?: PaymentUpdateManyWithoutIntentNestedInput
  }

  export type PaymentIntentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutIntentNestedInput
  }

  export type PaymentIntentCreateManyInput = {
    id?: string
    orderId: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentIntentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    client?: string | null
    clientLogo?: string | null
    category?: string | null
    technologies?: string | null
    features?: string | null
    images?: string | null
    thumbnailImage?: string | null
    coverImage?: string | null
    youtubeVideoId?: string | null
    youtubeVideoUrl?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    liveUrl?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: string | null
    teamSize?: number | null
    budget?: string | null
    status?: string
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: number
    viewCount?: number
    tags?: string | null
    testimonial?: string | null
    results?: string | null
    challenges?: string | null
    solutions?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    structuredData?: string | null
    canonicalUrl?: string | null
    content?: string | null
    galleryImages?: string | null
    clientLogoUrl?: string | null
    projectDate?: Date | string | null
    completionDate?: Date | string | null
    featured?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    client?: string | null
    clientLogo?: string | null
    category?: string | null
    technologies?: string | null
    features?: string | null
    images?: string | null
    thumbnailImage?: string | null
    coverImage?: string | null
    youtubeVideoId?: string | null
    youtubeVideoUrl?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    liveUrl?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: string | null
    teamSize?: number | null
    budget?: string | null
    status?: string
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: number
    viewCount?: number
    userId: string
    tags?: string | null
    testimonial?: string | null
    results?: string | null
    challenges?: string | null
    solutions?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    structuredData?: string | null
    canonicalUrl?: string | null
    content?: string | null
    galleryImages?: string | null
    clientLogoUrl?: string | null
    projectDate?: Date | string | null
    completionDate?: Date | string | null
    featured?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    technologies?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: NullableStringFieldUpdateOperationsInput | string | null
    solutions?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    structuredData?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    projectDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    technologies?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: NullableStringFieldUpdateOperationsInput | string | null
    solutions?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    structuredData?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    projectDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    client?: string | null
    clientLogo?: string | null
    category?: string | null
    technologies?: string | null
    features?: string | null
    images?: string | null
    thumbnailImage?: string | null
    coverImage?: string | null
    youtubeVideoId?: string | null
    youtubeVideoUrl?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    liveUrl?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: string | null
    teamSize?: number | null
    budget?: string | null
    status?: string
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: number
    viewCount?: number
    userId: string
    tags?: string | null
    testimonial?: string | null
    results?: string | null
    challenges?: string | null
    solutions?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    structuredData?: string | null
    canonicalUrl?: string | null
    content?: string | null
    galleryImages?: string | null
    clientLogoUrl?: string | null
    projectDate?: Date | string | null
    completionDate?: Date | string | null
    featured?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    technologies?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: NullableStringFieldUpdateOperationsInput | string | null
    solutions?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    structuredData?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    projectDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    technologies?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: NullableStringFieldUpdateOperationsInput | string | null
    solutions?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    structuredData?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    projectDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    method?: string | null
    url?: string | null
    statusCode?: number | null
    duration?: number | null
    category?: string
    severity?: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    method?: string | null
    url?: string | null
    statusCode?: number | null
    duration?: number | null
    category?: string
    severity?: string
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    method?: string | null
    url?: string | null
    statusCode?: number | null
    duration?: number | null
    category?: string
    severity?: string
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickCreateNestedManyWithoutCampaignInput
    opens?: CampaignOpenCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickUncheckedCreateNestedManyWithoutCampaignInput
    opens?: CampaignOpenUncheckedCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUpdateManyWithoutCampaignNestedInput
    opens?: CampaignOpenUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUncheckedUpdateManyWithoutCampaignNestedInput
    opens?: CampaignOpenUncheckedUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientCreateInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutRecipientsInput
  }

  export type CampaignRecipientUncheckedCreateInput = {
    id?: string
    campaignId: string
    email: string
    name?: string | null
    createdAt?: Date | string
  }

  export type CampaignRecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type CampaignRecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientCreateManyInput = {
    id?: string
    campaignId: string
    email: string
    name?: string | null
    createdAt?: Date | string
  }

  export type CampaignRecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOpenCreateInput = {
    id?: string
    recipientEmail?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutOpensInput
  }

  export type CampaignOpenUncheckedCreateInput = {
    id?: string
    campaignId: string
    recipientEmail?: string | null
    createdAt?: Date | string
  }

  export type CampaignOpenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutOpensNestedInput
  }

  export type CampaignOpenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOpenCreateManyInput = {
    id?: string
    campaignId: string
    recipientEmail?: string | null
    createdAt?: Date | string
  }

  export type CampaignOpenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOpenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignClickCreateInput = {
    id?: string
    recipientEmail?: string | null
    url?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutClicksInput
  }

  export type CampaignClickUncheckedCreateInput = {
    id?: string
    campaignId: string
    recipientEmail?: string | null
    url?: string | null
    createdAt?: Date | string
  }

  export type CampaignClickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutClicksNestedInput
  }

  export type CampaignClickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignClickCreateManyInput = {
    id?: string
    campaignId: string
    recipientEmail?: string | null
    url?: string | null
    createdAt?: Date | string
  }

  export type CampaignClickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignClickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutEmailLogsInput
  }

  export type EmailLogUncheckedCreateInput = {
    id?: string
    campaignId?: string | null
    recipientEmail: string
    subject: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutEmailLogsNestedInput
  }

  export type EmailLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateManyInput = {
    id?: string
    campaignId?: string | null
    recipientEmail: string
    subject: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesCreateInput = {
    id: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    company?: string | null
    serviceType?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type contact_messagesUncheckedCreateInput = {
    id: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    company?: string | null
    serviceType?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type contact_messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesCreateManyInput = {
    id: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    company?: string | null
    serviceType?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type contact_messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contact_messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type site_settingsCreateInput = {
    id: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type site_settingsUncheckedCreateInput = {
    id: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type site_settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type site_settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type site_settingsCreateManyInput = {
    id: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type site_settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type site_settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type softwareCreateInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    category: string
    platform: string
    version?: string | null
    downloadUrl?: string | null
    websiteUrl?: string | null
    imageUrl?: string | null
    features?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type softwareUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    category: string
    platform: string
    version?: string | null
    downloadUrl?: string | null
    websiteUrl?: string | null
    imageUrl?: string | null
    features?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type softwareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type softwareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type softwareCreateManyInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    category: string
    platform: string
    version?: string | null
    downloadUrl?: string | null
    websiteUrl?: string | null
    imageUrl?: string | null
    features?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type softwareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type softwareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type CustomerQuestionListRelationFilter = {
    every?: CustomerQuestionWhereInput
    some?: CustomerQuestionWhereInput
    none?: CustomerQuestionWhereInput
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type LoyaltyAccountNullableRelationFilter = {
    is?: LoyaltyAccountWhereInput | null
    isNot?: LoyaltyAccountWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ProductReviewListRelationFilter = {
    every?: ProductReviewWhereInput
    some?: ProductReviewWhereInput
    none?: ProductReviewWhereInput
  }

  export type ProductViewListRelationFilter = {
    every?: ProductViewWhereInput
    some?: ProductViewWhereInput
    none?: ProductViewWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type SearchQueryListRelationFilter = {
    every?: SearchQueryWhereInput
    some?: SearchQueryWhereInput
    none?: SearchQueryWhereInput
  }

  export type ServiceBookingListRelationFilter = {
    every?: ServiceBookingWhereInput
    some?: ServiceBookingWhereInput
    none?: ServiceBookingWhereInput
  }

  export type ServiceViewListRelationFilter = {
    every?: ServiceViewWhereInput
    some?: ServiceViewWhereInput
    none?: ServiceViewWhereInput
  }

  export type WishlistItemListRelationFilter = {
    every?: WishlistItemWhereInput
    some?: WishlistItemWhereInput
    none?: WishlistItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchQueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type InventoryNullableRelationFilter = {
    is?: InventoryWhereInput | null
    isNot?: InventoryWhereInput | null
  }

  export type InventoryAlertListRelationFilter = {
    every?: InventoryAlertWhereInput
    some?: InventoryAlertWhereInput
    none?: InventoryAlertWhereInput
  }

  export type KnowledgeBaseEntryListRelationFilter = {
    every?: KnowledgeBaseEntryWhereInput
    some?: KnowledgeBaseEntryWhereInput
    none?: KnowledgeBaseEntryWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeBaseEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    priceCents?: SortOrder
    originalPriceCents?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    sku?: SortOrder
    specifications?: SortOrder
    features?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    maxOrderQuantity?: SortOrder
    maxStock?: SortOrder
    tags?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    canonicalUrl?: SortOrder
    featured?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    priceCents?: SortOrder
    originalPriceCents?: SortOrder
    weight?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    maxOrderQuantity?: SortOrder
    maxStock?: SortOrder
    viewCount?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    priceCents?: SortOrder
    originalPriceCents?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    sku?: SortOrder
    specifications?: SortOrder
    features?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    maxOrderQuantity?: SortOrder
    maxStock?: SortOrder
    tags?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    canonicalUrl?: SortOrder
    featured?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    priceCents?: SortOrder
    originalPriceCents?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    sku?: SortOrder
    specifications?: SortOrder
    features?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    maxOrderQuantity?: SortOrder
    maxStock?: SortOrder
    tags?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    canonicalUrl?: SortOrder
    featured?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    priceCents?: SortOrder
    originalPriceCents?: SortOrder
    weight?: SortOrder
    stockQuantity?: SortOrder
    minOrderQuantity?: SortOrder
    maxOrderQuantity?: SortOrder
    maxStock?: SortOrder
    viewCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canonicalUrl?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    metaTitle?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canonicalUrl?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    metaTitle?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canonicalUrl?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    metaTitle?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CartRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type CartItemCartIdProductIdCompoundUniqueInput = {
    cartId: string
    productId: string
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PaymentIntentListRelationFilter = {
    every?: PaymentIntentWhereInput
    some?: PaymentIntentWhereInput
    none?: PaymentIntentWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentIntentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    shippingCents?: SortOrder
    totalCents?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrder
    shippingCoordinates?: SortOrder
    promotionCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    shippingCents?: SortOrder
    totalCents?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    shippingCents?: SortOrder
    totalCents?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrder
    shippingCoordinates?: SortOrder
    promotionCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    shippingCents?: SortOrder
    totalCents?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrder
    shippingCoordinates?: SortOrder
    promotionCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    shippingCents?: SortOrder
    totalCents?: SortOrder
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
  }

  export type PaymentIntentNullableRelationFilter = {
    is?: PaymentIntentWhereInput | null
    isNot?: PaymentIntentWhereInput | null
  }

  export type RefundListRelationFilter = {
    every?: RefundWhereInput
    some?: RefundWhereInput
    none?: RefundWhereInput
  }

  export type RefundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    intentId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    intentId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    intentId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amountCents?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type RefundAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amountCents?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amountCents?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type RefundSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTypeAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ServiceTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTypeSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ServiceItemListRelationFilter = {
    every?: ServiceItemWhereInput
    some?: ServiceItemWhereInput
    none?: ServiceItemWhereInput
  }

  export type ServiceTypeNullableRelationFilter = {
    is?: ServiceTypeWhereInput | null
    isNot?: ServiceTypeWhereInput | null
  }

  export type ServiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    basePriceCents?: SortOrder
    price?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    priceType?: SortOrder
    duration?: SortOrder
    typeId?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    features?: SortOrder
    requirements?: SortOrder
    metadata?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    basePriceCents?: SortOrder
    price?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    duration?: SortOrder
    viewCount?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    basePriceCents?: SortOrder
    price?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    priceType?: SortOrder
    duration?: SortOrder
    typeId?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    features?: SortOrder
    requirements?: SortOrder
    metadata?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    basePriceCents?: SortOrder
    price?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    priceType?: SortOrder
    duration?: SortOrder
    typeId?: SortOrder
    images?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    features?: SortOrder
    requirements?: SortOrder
    metadata?: SortOrder
    viewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    basePriceCents?: SortOrder
    price?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    duration?: SortOrder
    viewCount?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    stock?: SortOrder
    reserved?: SortOrder
    lowStockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    stock?: SortOrder
    reserved?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    stock?: SortOrder
    reserved?: SortOrder
    lowStockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    stock?: SortOrder
    reserved?: SortOrder
    lowStockThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    stock?: SortOrder
    reserved?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrder
    referenceId?: SortOrder
    referenceType?: SortOrder
    userId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrder
    referenceId?: SortOrder
    referenceType?: SortOrder
    userId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrder
    referenceId?: SortOrder
    referenceType?: SortOrder
    userId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
  }

  export type InventoryAlertCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    threshold?: SortOrder
    currentStock?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAlertAvgOrderByAggregateInput = {
    threshold?: SortOrder
    currentStock?: SortOrder
  }

  export type InventoryAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    threshold?: SortOrder
    currentStock?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAlertMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    threshold?: SortOrder
    currentStock?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAlertSumOrderByAggregateInput = {
    threshold?: SortOrder
    currentStock?: SortOrder
  }

  export type InventoryReportCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    parameters?: SortOrder
    data?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryReportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    parameters?: SortOrder
    data?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryReportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    parameters?: SortOrder
    data?: SortOrder
    generatedBy?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WishlistItemUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type WishlistItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type WishlistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type WishlistItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type ProductReviewReportListRelationFilter = {
    every?: ProductReviewReportWhereInput
    some?: ProductReviewReportWhereInput
    none?: ProductReviewReportWhereInput
  }

  export type ProductReviewVoteListRelationFilter = {
    every?: ProductReviewVoteWhereInput
    some?: ProductReviewVoteWhereInput
    none?: ProductReviewVoteWhereInput
  }

  export type ProductReviewReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductReviewVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    isVerified?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type ProductReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    isVerified?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    isVerified?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductReviewSumOrderByAggregateInput = {
    rating?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type ProductReviewRelationFilter = {
    is?: ProductReviewWhereInput
    isNot?: ProductReviewWhereInput
  }

  export type ProductReviewVoteReviewIdUserIdCompoundUniqueInput = {
    reviewId: string
    userId: string
  }

  export type ProductReviewVoteCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReviewVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReviewVoteMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    isUpvote?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReviewReportCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReviewReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReviewReportMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchQueryCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type SearchQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type SearchQueryMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
  }

  export type ProductViewCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ProductViewAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ProductViewMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ProductViewMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ProductViewSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceViewCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ServiceViewAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ServiceViewMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ServiceViewMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ServiceViewSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CustomerQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    category?: SortOrder
    satisfaction?: SortOrder
    timestamp?: SortOrder
  }

  export type CustomerQuestionAvgOrderByAggregateInput = {
    satisfaction?: SortOrder
  }

  export type CustomerQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    category?: SortOrder
    satisfaction?: SortOrder
    timestamp?: SortOrder
  }

  export type CustomerQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    question?: SortOrder
    category?: SortOrder
    satisfaction?: SortOrder
    timestamp?: SortOrder
  }

  export type CustomerQuestionSumOrderByAggregateInput = {
    satisfaction?: SortOrder
  }

  export type TechnicianScheduleListRelationFilter = {
    every?: TechnicianScheduleWhereInput
    some?: TechnicianScheduleWhereInput
    none?: TechnicianScheduleWhereInput
  }

  export type TechnicianScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechnicianCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    specialties?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicianMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    specialties?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicianMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    specialties?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceBookingItemListRelationFilter = {
    every?: ServiceBookingItemWhereInput
    some?: ServiceBookingItemWhereInput
    none?: ServiceBookingItemWhereInput
  }

  export type ServiceBookingItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceItemAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type ServiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceItemSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type TechnicianNullableRelationFilter = {
    is?: TechnicianWhereInput | null
    isNot?: TechnicianWhereInput | null
  }

  export type ServicePaymentListRelationFilter = {
    every?: ServicePaymentWhereInput
    some?: ServicePaymentWhereInput
    none?: ServicePaymentWhereInput
  }

  export type ServiceStatusHistoryListRelationFilter = {
    every?: ServiceStatusHistoryWhereInput
    some?: ServiceStatusHistoryWhereInput
    none?: ServiceStatusHistoryWhereInput
  }

  export type ServicePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceBookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    technicianId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledTime?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    estimatedCosts?: SortOrder
    actualCosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceBookingAvgOrderByAggregateInput = {
    estimatedCosts?: SortOrder
    actualCosts?: SortOrder
  }

  export type ServiceBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    technicianId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledTime?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    estimatedCosts?: SortOrder
    actualCosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceBookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    technicianId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    scheduledTime?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    estimatedCosts?: SortOrder
    actualCosts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceBookingSumOrderByAggregateInput = {
    estimatedCosts?: SortOrder
    actualCosts?: SortOrder
  }

  export type ServiceBookingRelationFilter = {
    is?: ServiceBookingWhereInput
    isNot?: ServiceBookingWhereInput
  }

  export type ServiceItemRelationFilter = {
    is?: ServiceItemWhereInput
    isNot?: ServiceItemWhereInput
  }

  export type ServiceBookingItemCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceBookingItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ServiceBookingItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceBookingItemMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceBookingItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type TechnicianRelationFilter = {
    is?: TechnicianWhereInput
    isNot?: TechnicianWhereInput
  }

  export type TechnicianScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    technicianId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicianScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    technicianId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicianScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    technicianId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    status?: SortOrder
    newStatus?: SortOrder
    note?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    status?: SortOrder
    newStatus?: SortOrder
    note?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    status?: SortOrder
    newStatus?: SortOrder
    note?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePaymentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type ServicePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePaymentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    mobileImageUrl?: SortOrder
    linkUrl?: SortOrder
    buttonLabel?: SortOrder
    page?: SortOrder
    locale?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    mobileImageUrl?: SortOrder
    linkUrl?: SortOrder
    buttonLabel?: SortOrder
    page?: SortOrder
    locale?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    mobileImageUrl?: SortOrder
    linkUrl?: SortOrder
    buttonLabel?: SortOrder
    page?: SortOrder
    locale?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointTransactionListRelationFilter = {
    every?: PointTransactionWhereInput
    some?: PointTransactionWhereInput
    none?: PointTransactionWhereInput
  }

  export type RedemptionHistoryListRelationFilter = {
    every?: RedemptionHistoryWhereInput
    some?: RedemptionHistoryWhereInput
    none?: RedemptionHistoryWhereInput
  }

  export type PointTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RedemptionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoyaltyAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    tier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyAccountAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type LoyaltyAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    tier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    tier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyAccountSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type LoyaltyAccountRelationFilter = {
    is?: LoyaltyAccountWhereInput
    isNot?: LoyaltyAccountWhereInput
  }

  export type PointTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PointTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PointTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PointTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PointTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type LoyaltyRewardRelationFilter = {
    is?: LoyaltyRewardWhereInput
    isNot?: LoyaltyRewardWhereInput
  }

  export type RedemptionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    rewardId?: SortOrder
    pointsUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RedemptionHistoryAvgOrderByAggregateInput = {
    pointsUsed?: SortOrder
  }

  export type RedemptionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    rewardId?: SortOrder
    pointsUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RedemptionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    rewardId?: SortOrder
    pointsUsed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type RedemptionHistorySumOrderByAggregateInput = {
    pointsUsed?: SortOrder
  }

  export type LoyaltyRewardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsCost?: SortOrder
    value?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyRewardAvgOrderByAggregateInput = {
    pointsCost?: SortOrder
    value?: SortOrder
  }

  export type LoyaltyRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsCost?: SortOrder
    value?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyRewardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsCost?: SortOrder
    value?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyRewardSumOrderByAggregateInput = {
    pointsCost?: SortOrder
    value?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type KnowledgeBaseEntryCountOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    content?: SortOrder
    productId?: SortOrder
    tags?: SortOrder
    embedding?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    content?: SortOrder
    productId?: SortOrder
    tags?: SortOrder
    embedding?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseEntryMinOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    content?: SortOrder
    productId?: SortOrder
    tags?: SortOrder
    embedding?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentIntentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    clientSecret?: SortOrder
    returnUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentIntentAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type PaymentIntentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    clientSecret?: SortOrder
    returnUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentIntentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    clientSecret?: SortOrder
    returnUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentIntentSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    client?: SortOrder
    clientLogo?: SortOrder
    category?: SortOrder
    technologies?: SortOrder
    features?: SortOrder
    images?: SortOrder
    thumbnailImage?: SortOrder
    coverImage?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeVideoUrl?: SortOrder
    demoUrl?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    viewCount?: SortOrder
    userId?: SortOrder
    tags?: SortOrder
    testimonial?: SortOrder
    results?: SortOrder
    challenges?: SortOrder
    solutions?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    structuredData?: SortOrder
    canonicalUrl?: SortOrder
    content?: SortOrder
    galleryImages?: SortOrder
    clientLogoUrl?: SortOrder
    projectDate?: SortOrder
    completionDate?: SortOrder
    featured?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    teamSize?: SortOrder
    displayOrder?: SortOrder
    viewCount?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    client?: SortOrder
    clientLogo?: SortOrder
    category?: SortOrder
    technologies?: SortOrder
    features?: SortOrder
    images?: SortOrder
    thumbnailImage?: SortOrder
    coverImage?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeVideoUrl?: SortOrder
    demoUrl?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    viewCount?: SortOrder
    userId?: SortOrder
    tags?: SortOrder
    testimonial?: SortOrder
    results?: SortOrder
    challenges?: SortOrder
    solutions?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    structuredData?: SortOrder
    canonicalUrl?: SortOrder
    content?: SortOrder
    galleryImages?: SortOrder
    clientLogoUrl?: SortOrder
    projectDate?: SortOrder
    completionDate?: SortOrder
    featured?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    client?: SortOrder
    clientLogo?: SortOrder
    category?: SortOrder
    technologies?: SortOrder
    features?: SortOrder
    images?: SortOrder
    thumbnailImage?: SortOrder
    coverImage?: SortOrder
    youtubeVideoId?: SortOrder
    youtubeVideoUrl?: SortOrder
    demoUrl?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    viewCount?: SortOrder
    userId?: SortOrder
    tags?: SortOrder
    testimonial?: SortOrder
    results?: SortOrder
    challenges?: SortOrder
    solutions?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    ogTitle?: SortOrder
    ogDescription?: SortOrder
    ogImage?: SortOrder
    structuredData?: SortOrder
    canonicalUrl?: SortOrder
    content?: SortOrder
    galleryImages?: SortOrder
    clientLogoUrl?: SortOrder
    projectDate?: SortOrder
    completionDate?: SortOrder
    featured?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    teamSize?: SortOrder
    displayOrder?: SortOrder
    viewCount?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    method?: SortOrder
    url?: SortOrder
    statusCode?: SortOrder
    duration?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    duration?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    method?: SortOrder
    url?: SortOrder
    statusCode?: SortOrder
    duration?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    method?: SortOrder
    url?: SortOrder
    statusCode?: SortOrder
    duration?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    duration?: SortOrder
  }

  export type EnumCampaignTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeFilter<$PrismaModel> | $Enums.CampaignType
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type CampaignClickListRelationFilter = {
    every?: CampaignClickWhereInput
    some?: CampaignClickWhereInput
    none?: CampaignClickWhereInput
  }

  export type CampaignOpenListRelationFilter = {
    every?: CampaignOpenWhereInput
    some?: CampaignOpenWhereInput
    none?: CampaignOpenWhereInput
  }

  export type CampaignRecipientListRelationFilter = {
    every?: CampaignRecipientWhereInput
    some?: CampaignRecipientWhereInput
    none?: CampaignRecipientWhereInput
  }

  export type EmailLogListRelationFilter = {
    every?: EmailLogWhereInput
    some?: EmailLogWhereInput
    none?: EmailLogWhereInput
  }

  export type CampaignClickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOpenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrder
    discountPercent?: SortOrder
    discountAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    discountPercent?: SortOrder
    discountAmount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrder
    discountPercent?: SortOrder
    discountAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrder
    discountPercent?: SortOrder
    discountAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    discountPercent?: SortOrder
    discountAmount?: SortOrder
  }

  export type EnumCampaignTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignTypeFilter<$PrismaModel>
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignOpenCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignOpenMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignOpenMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignClickCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignClickMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignClickMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignNullableRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type EmailLogCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientEmail?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    error?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type contact_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    company?: SortOrder
    serviceType?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contact_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    company?: SortOrder
    serviceType?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type contact_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    company?: SortOrder
    serviceType?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type site_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type site_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type site_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type softwareCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    downloadUrl?: SortOrder
    websiteUrl?: SortOrder
    imageUrl?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type softwareMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    downloadUrl?: SortOrder
    websiteUrl?: SortOrder
    imageUrl?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type softwareMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    version?: SortOrder
    downloadUrl?: SortOrder
    websiteUrl?: SortOrder
    imageUrl?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type CartCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type CustomerQuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomerQuestionCreateWithoutUserInput, CustomerQuestionUncheckedCreateWithoutUserInput> | CustomerQuestionCreateWithoutUserInput[] | CustomerQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerQuestionCreateOrConnectWithoutUserInput | CustomerQuestionCreateOrConnectWithoutUserInput[]
    createMany?: CustomerQuestionCreateManyUserInputEnvelope
    connect?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type LoyaltyAccountCreateNestedOneWithoutUserInput = {
    create?: XOR<LoyaltyAccountCreateWithoutUserInput, LoyaltyAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutUserInput
    connect?: LoyaltyAccountWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type ProductViewCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SearchQueryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
  }

  export type ServiceBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type ServiceViewCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceViewCreateWithoutUserInput, ServiceViewUncheckedCreateWithoutUserInput> | ServiceViewCreateWithoutUserInput[] | ServiceViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutUserInput | ServiceViewCreateOrConnectWithoutUserInput[]
    createMany?: ServiceViewCreateManyUserInputEnvelope
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type CustomerQuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomerQuestionCreateWithoutUserInput, CustomerQuestionUncheckedCreateWithoutUserInput> | CustomerQuestionCreateWithoutUserInput[] | CustomerQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerQuestionCreateOrConnectWithoutUserInput | CustomerQuestionCreateOrConnectWithoutUserInput[]
    createMany?: CustomerQuestionCreateManyUserInputEnvelope
    connect?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LoyaltyAccountCreateWithoutUserInput, LoyaltyAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutUserInput
    connect?: LoyaltyAccountWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type ProductViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SearchQueryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
  }

  export type ServiceBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type ServiceViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceViewCreateWithoutUserInput, ServiceViewUncheckedCreateWithoutUserInput> | ServiceViewCreateWithoutUserInput[] | ServiceViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutUserInput | ServiceViewCreateOrConnectWithoutUserInput[]
    createMany?: ServiceViewCreateManyUserInputEnvelope
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type CartUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type CustomerQuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomerQuestionCreateWithoutUserInput, CustomerQuestionUncheckedCreateWithoutUserInput> | CustomerQuestionCreateWithoutUserInput[] | CustomerQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerQuestionCreateOrConnectWithoutUserInput | CustomerQuestionCreateOrConnectWithoutUserInput[]
    upsert?: CustomerQuestionUpsertWithWhereUniqueWithoutUserInput | CustomerQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomerQuestionCreateManyUserInputEnvelope
    set?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    disconnect?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    delete?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    connect?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    update?: CustomerQuestionUpdateWithWhereUniqueWithoutUserInput | CustomerQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomerQuestionUpdateManyWithWhereWithoutUserInput | CustomerQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomerQuestionScalarWhereInput | CustomerQuestionScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutUserInput | InventoryMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutUserInput | InventoryMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutUserInput | InventoryMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type LoyaltyAccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<LoyaltyAccountCreateWithoutUserInput, LoyaltyAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutUserInput
    upsert?: LoyaltyAccountUpsertWithoutUserInput
    disconnect?: LoyaltyAccountWhereInput | boolean
    delete?: LoyaltyAccountWhereInput | boolean
    connect?: LoyaltyAccountWhereUniqueInput
    update?: XOR<XOR<LoyaltyAccountUpdateToOneWithWhereWithoutUserInput, LoyaltyAccountUpdateWithoutUserInput>, LoyaltyAccountUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutUserInput | ProductReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutUserInput | ProductReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutUserInput | ProductReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type ProductViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutUserInput | ProductViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutUserInput | ProductViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutUserInput | ProductViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SearchQueryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    upsert?: SearchQueryUpsertWithWhereUniqueWithoutUserInput | SearchQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    set?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    disconnect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    delete?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    update?: SearchQueryUpdateWithWhereUniqueWithoutUserInput | SearchQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchQueryUpdateManyWithWhereWithoutUserInput | SearchQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
  }

  export type ServiceBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutUserInput | ServiceBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutUserInput | ServiceBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutUserInput | ServiceBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceViewCreateWithoutUserInput, ServiceViewUncheckedCreateWithoutUserInput> | ServiceViewCreateWithoutUserInput[] | ServiceViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutUserInput | ServiceViewCreateOrConnectWithoutUserInput[]
    upsert?: ServiceViewUpsertWithWhereUniqueWithoutUserInput | ServiceViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceViewCreateManyUserInputEnvelope
    set?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    disconnect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    delete?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    update?: ServiceViewUpdateWithWhereUniqueWithoutUserInput | ServiceViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceViewUpdateManyWithWhereWithoutUserInput | ServiceViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceViewScalarWhereInput | ServiceViewScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutUserInput | WishlistItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutUserInput | WishlistItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutUserInput | WishlistItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomerQuestionCreateWithoutUserInput, CustomerQuestionUncheckedCreateWithoutUserInput> | CustomerQuestionCreateWithoutUserInput[] | CustomerQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerQuestionCreateOrConnectWithoutUserInput | CustomerQuestionCreateOrConnectWithoutUserInput[]
    upsert?: CustomerQuestionUpsertWithWhereUniqueWithoutUserInput | CustomerQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomerQuestionCreateManyUserInputEnvelope
    set?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    disconnect?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    delete?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    connect?: CustomerQuestionWhereUniqueInput | CustomerQuestionWhereUniqueInput[]
    update?: CustomerQuestionUpdateWithWhereUniqueWithoutUserInput | CustomerQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomerQuestionUpdateManyWithWhereWithoutUserInput | CustomerQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomerQuestionScalarWhereInput | CustomerQuestionScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutUserInput | InventoryMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutUserInput | InventoryMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutUserInput | InventoryMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LoyaltyAccountCreateWithoutUserInput, LoyaltyAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutUserInput
    upsert?: LoyaltyAccountUpsertWithoutUserInput
    disconnect?: LoyaltyAccountWhereInput | boolean
    delete?: LoyaltyAccountWhereInput | boolean
    connect?: LoyaltyAccountWhereUniqueInput
    update?: XOR<XOR<LoyaltyAccountUpdateToOneWithWhereWithoutUserInput, LoyaltyAccountUpdateWithoutUserInput>, LoyaltyAccountUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutUserInput | ProductReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutUserInput | ProductReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutUserInput | ProductReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type ProductViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput> | ProductViewCreateWithoutUserInput[] | ProductViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutUserInput | ProductViewCreateOrConnectWithoutUserInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutUserInput | ProductViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductViewCreateManyUserInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutUserInput | ProductViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutUserInput | ProductViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SearchQueryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    upsert?: SearchQueryUpsertWithWhereUniqueWithoutUserInput | SearchQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    set?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    disconnect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    delete?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    update?: SearchQueryUpdateWithWhereUniqueWithoutUserInput | SearchQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchQueryUpdateManyWithWhereWithoutUserInput | SearchQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
  }

  export type ServiceBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput> | ServiceBookingCreateWithoutUserInput[] | ServiceBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutUserInput | ServiceBookingCreateOrConnectWithoutUserInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutUserInput | ServiceBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceBookingCreateManyUserInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutUserInput | ServiceBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutUserInput | ServiceBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceViewCreateWithoutUserInput, ServiceViewUncheckedCreateWithoutUserInput> | ServiceViewCreateWithoutUserInput[] | ServiceViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutUserInput | ServiceViewCreateOrConnectWithoutUserInput[]
    upsert?: ServiceViewUpsertWithWhereUniqueWithoutUserInput | ServiceViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceViewCreateManyUserInputEnvelope
    set?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    disconnect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    delete?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    update?: ServiceViewUpdateWithWhereUniqueWithoutUserInput | ServiceViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceViewUpdateManyWithWhereWithoutUserInput | ServiceViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceViewScalarWhereInput | ServiceViewScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutUserInput | WishlistItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutUserInput | WishlistItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutUserInput | WishlistItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type InventoryCreateNestedOneWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    connect?: InventoryWhereUniqueInput
  }

  export type InventoryAlertCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryAlertCreateWithoutProductInput, InventoryAlertUncheckedCreateWithoutProductInput> | InventoryAlertCreateWithoutProductInput[] | InventoryAlertUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAlertCreateOrConnectWithoutProductInput | InventoryAlertCreateOrConnectWithoutProductInput[]
    createMany?: InventoryAlertCreateManyProductInputEnvelope
    connect?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type KnowledgeBaseEntryCreateNestedManyWithoutProductInput = {
    create?: XOR<KnowledgeBaseEntryCreateWithoutProductInput, KnowledgeBaseEntryUncheckedCreateWithoutProductInput> | KnowledgeBaseEntryCreateWithoutProductInput[] | KnowledgeBaseEntryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: KnowledgeBaseEntryCreateOrConnectWithoutProductInput | KnowledgeBaseEntryCreateOrConnectWithoutProductInput[]
    createMany?: KnowledgeBaseEntryCreateManyProductInputEnvelope
    connect?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type ProductViewCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type WishlistItemCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    connect?: InventoryWhereUniqueInput
  }

  export type InventoryAlertUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryAlertCreateWithoutProductInput, InventoryAlertUncheckedCreateWithoutProductInput> | InventoryAlertCreateWithoutProductInput[] | InventoryAlertUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAlertCreateOrConnectWithoutProductInput | InventoryAlertCreateOrConnectWithoutProductInput[]
    createMany?: InventoryAlertCreateManyProductInputEnvelope
    connect?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<KnowledgeBaseEntryCreateWithoutProductInput, KnowledgeBaseEntryUncheckedCreateWithoutProductInput> | KnowledgeBaseEntryCreateWithoutProductInput[] | KnowledgeBaseEntryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: KnowledgeBaseEntryCreateOrConnectWithoutProductInput | KnowledgeBaseEntryCreateOrConnectWithoutProductInput[]
    createMany?: KnowledgeBaseEntryCreateManyProductInputEnvelope
    connect?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type ProductViewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type InventoryUpdateOneWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    upsert?: InventoryUpsertWithoutProductInput
    disconnect?: InventoryWhereInput | boolean
    delete?: InventoryWhereInput | boolean
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutProductInput, InventoryUpdateWithoutProductInput>, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryAlertUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryAlertCreateWithoutProductInput, InventoryAlertUncheckedCreateWithoutProductInput> | InventoryAlertCreateWithoutProductInput[] | InventoryAlertUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAlertCreateOrConnectWithoutProductInput | InventoryAlertCreateOrConnectWithoutProductInput[]
    upsert?: InventoryAlertUpsertWithWhereUniqueWithoutProductInput | InventoryAlertUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryAlertCreateManyProductInputEnvelope
    set?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    disconnect?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    delete?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    connect?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    update?: InventoryAlertUpdateWithWhereUniqueWithoutProductInput | InventoryAlertUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryAlertUpdateManyWithWhereWithoutProductInput | InventoryAlertUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryAlertScalarWhereInput | InventoryAlertScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutProductInput | InventoryMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutProductInput | InventoryMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutProductInput | InventoryMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type KnowledgeBaseEntryUpdateManyWithoutProductNestedInput = {
    create?: XOR<KnowledgeBaseEntryCreateWithoutProductInput, KnowledgeBaseEntryUncheckedCreateWithoutProductInput> | KnowledgeBaseEntryCreateWithoutProductInput[] | KnowledgeBaseEntryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: KnowledgeBaseEntryCreateOrConnectWithoutProductInput | KnowledgeBaseEntryCreateOrConnectWithoutProductInput[]
    upsert?: KnowledgeBaseEntryUpsertWithWhereUniqueWithoutProductInput | KnowledgeBaseEntryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: KnowledgeBaseEntryCreateManyProductInputEnvelope
    set?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    disconnect?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    delete?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    connect?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    update?: KnowledgeBaseEntryUpdateWithWhereUniqueWithoutProductInput | KnowledgeBaseEntryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: KnowledgeBaseEntryUpdateManyWithWhereWithoutProductInput | KnowledgeBaseEntryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: KnowledgeBaseEntryScalarWhereInput | KnowledgeBaseEntryScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutProductInput | ProductReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutProductInput | ProductReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutProductInput | ProductReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type ProductViewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutProductInput | ProductViewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutProductInput | ProductViewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutProductInput | ProductViewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type WishlistItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput
    upsert?: InventoryUpsertWithoutProductInput
    disconnect?: InventoryWhereInput | boolean
    delete?: InventoryWhereInput | boolean
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutProductInput, InventoryUpdateWithoutProductInput>, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryAlertUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryAlertCreateWithoutProductInput, InventoryAlertUncheckedCreateWithoutProductInput> | InventoryAlertCreateWithoutProductInput[] | InventoryAlertUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryAlertCreateOrConnectWithoutProductInput | InventoryAlertCreateOrConnectWithoutProductInput[]
    upsert?: InventoryAlertUpsertWithWhereUniqueWithoutProductInput | InventoryAlertUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryAlertCreateManyProductInputEnvelope
    set?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    disconnect?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    delete?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    connect?: InventoryAlertWhereUniqueInput | InventoryAlertWhereUniqueInput[]
    update?: InventoryAlertUpdateWithWhereUniqueWithoutProductInput | InventoryAlertUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryAlertUpdateManyWithWhereWithoutProductInput | InventoryAlertUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryAlertScalarWhereInput | InventoryAlertScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutProductInput | InventoryMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutProductInput | InventoryMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutProductInput | InventoryMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<KnowledgeBaseEntryCreateWithoutProductInput, KnowledgeBaseEntryUncheckedCreateWithoutProductInput> | KnowledgeBaseEntryCreateWithoutProductInput[] | KnowledgeBaseEntryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: KnowledgeBaseEntryCreateOrConnectWithoutProductInput | KnowledgeBaseEntryCreateOrConnectWithoutProductInput[]
    upsert?: KnowledgeBaseEntryUpsertWithWhereUniqueWithoutProductInput | KnowledgeBaseEntryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: KnowledgeBaseEntryCreateManyProductInputEnvelope
    set?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    disconnect?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    delete?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    connect?: KnowledgeBaseEntryWhereUniqueInput | KnowledgeBaseEntryWhereUniqueInput[]
    update?: KnowledgeBaseEntryUpdateWithWhereUniqueWithoutProductInput | KnowledgeBaseEntryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: KnowledgeBaseEntryUpdateManyWithWhereWithoutProductInput | KnowledgeBaseEntryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: KnowledgeBaseEntryScalarWhereInput | KnowledgeBaseEntryScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutProductInput | ProductReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutProductInput | ProductReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutProductInput | ProductReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type ProductViewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput> | ProductViewCreateWithoutProductInput[] | ProductViewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductViewCreateOrConnectWithoutProductInput | ProductViewCreateOrConnectWithoutProductInput[]
    upsert?: ProductViewUpsertWithWhereUniqueWithoutProductInput | ProductViewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductViewCreateManyProductInputEnvelope
    set?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    disconnect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    delete?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    connect?: ProductViewWhereUniqueInput | ProductViewWhereUniqueInput[]
    update?: ProductViewUpdateWithWhereUniqueWithoutProductInput | ProductViewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductViewUpdateManyWithWhereWithoutProductInput | ProductViewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCartsInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    connect?: UserWhereUniqueInput
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCartsNestedInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    upsert?: UserUpsertWithoutCartsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartsInput, UserUpdateWithoutCartsInput>, UserUncheckedUpdateWithoutCartsInput>
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    upsert?: CartUpsertWithoutItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutItemsInput, CartUpdateWithoutItemsInput>, CartUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    upsert?: ProductUpsertWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemsInput, ProductUpdateWithoutCartItemsInput>, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentIntentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentIntentCreateWithoutOrderInput, PaymentIntentUncheckedCreateWithoutOrderInput> | PaymentIntentCreateWithoutOrderInput[] | PaymentIntentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutOrderInput | PaymentIntentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentIntentCreateManyOrderInputEnvelope
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentIntentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentIntentCreateWithoutOrderInput, PaymentIntentUncheckedCreateWithoutOrderInput> | PaymentIntentCreateWithoutOrderInput[] | PaymentIntentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutOrderInput | PaymentIntentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentIntentCreateManyOrderInputEnvelope
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type PaymentIntentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentIntentCreateWithoutOrderInput, PaymentIntentUncheckedCreateWithoutOrderInput> | PaymentIntentCreateWithoutOrderInput[] | PaymentIntentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutOrderInput | PaymentIntentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentIntentUpsertWithWhereUniqueWithoutOrderInput | PaymentIntentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentIntentCreateManyOrderInputEnvelope
    set?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    disconnect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    delete?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    update?: PaymentIntentUpdateWithWhereUniqueWithoutOrderInput | PaymentIntentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentIntentUpdateManyWithWhereWithoutOrderInput | PaymentIntentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentIntentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentIntentCreateWithoutOrderInput, PaymentIntentUncheckedCreateWithoutOrderInput> | PaymentIntentCreateWithoutOrderInput[] | PaymentIntentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutOrderInput | PaymentIntentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentIntentUpsertWithWhereUniqueWithoutOrderInput | PaymentIntentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentIntentCreateManyOrderInputEnvelope
    set?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    disconnect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    delete?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    update?: PaymentIntentUpdateWithWhereUniqueWithoutOrderInput | PaymentIntentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentIntentUpdateManyWithWhereWithoutOrderInput | PaymentIntentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type PaymentIntentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentIntentCreateWithoutPaymentsInput, PaymentIntentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutPaymentsInput
    connect?: PaymentIntentWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type RefundCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type RefundUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type PaymentIntentUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<PaymentIntentCreateWithoutPaymentsInput, PaymentIntentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentIntentUpsertWithoutPaymentsInput
    disconnect?: PaymentIntentWhereInput | boolean
    delete?: PaymentIntentWhereInput | boolean
    connect?: PaymentIntentWhereUniqueInput
    update?: XOR<XOR<PaymentIntentUpdateToOneWithWhereWithoutPaymentsInput, PaymentIntentUpdateWithoutPaymentsInput>, PaymentIntentUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type RefundUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type RefundUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutRefundsInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutRefundsNestedInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    upsert?: PaymentUpsertWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutRefundsInput, PaymentUpdateWithoutRefundsInput>, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type ServiceCreateNestedManyWithoutServiceTypeInput = {
    create?: XOR<ServiceCreateWithoutServiceTypeInput, ServiceUncheckedCreateWithoutServiceTypeInput> | ServiceCreateWithoutServiceTypeInput[] | ServiceUncheckedCreateWithoutServiceTypeInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceTypeInput | ServiceCreateOrConnectWithoutServiceTypeInput[]
    createMany?: ServiceCreateManyServiceTypeInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutServiceTypeInput = {
    create?: XOR<ServiceCreateWithoutServiceTypeInput, ServiceUncheckedCreateWithoutServiceTypeInput> | ServiceCreateWithoutServiceTypeInput[] | ServiceUncheckedCreateWithoutServiceTypeInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceTypeInput | ServiceCreateOrConnectWithoutServiceTypeInput[]
    createMany?: ServiceCreateManyServiceTypeInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutServiceTypeNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceTypeInput, ServiceUncheckedCreateWithoutServiceTypeInput> | ServiceCreateWithoutServiceTypeInput[] | ServiceUncheckedCreateWithoutServiceTypeInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceTypeInput | ServiceCreateOrConnectWithoutServiceTypeInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceTypeInput | ServiceUpsertWithWhereUniqueWithoutServiceTypeInput[]
    createMany?: ServiceCreateManyServiceTypeInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceTypeInput | ServiceUpdateWithWhereUniqueWithoutServiceTypeInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceTypeInput | ServiceUpdateManyWithWhereWithoutServiceTypeInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutServiceTypeNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceTypeInput, ServiceUncheckedCreateWithoutServiceTypeInput> | ServiceCreateWithoutServiceTypeInput[] | ServiceUncheckedCreateWithoutServiceTypeInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceTypeInput | ServiceCreateOrConnectWithoutServiceTypeInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceTypeInput | ServiceUpsertWithWhereUniqueWithoutServiceTypeInput[]
    createMany?: ServiceCreateManyServiceTypeInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceTypeInput | ServiceUpdateWithWhereUniqueWithoutServiceTypeInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceTypeInput | ServiceUpdateManyWithWhereWithoutServiceTypeInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceBookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type ServiceItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceItemCreateWithoutServiceInput, ServiceItemUncheckedCreateWithoutServiceInput> | ServiceItemCreateWithoutServiceInput[] | ServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutServiceInput | ServiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceItemCreateManyServiceInputEnvelope
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
  }

  export type ServiceViewCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceViewCreateWithoutServiceInput, ServiceViewUncheckedCreateWithoutServiceInput> | ServiceViewCreateWithoutServiceInput[] | ServiceViewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutServiceInput | ServiceViewCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceViewCreateManyServiceInputEnvelope
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
  }

  export type ServiceTypeCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceTypeCreateWithoutServicesInput, ServiceTypeUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceTypeCreateOrConnectWithoutServicesInput
    connect?: ServiceTypeWhereUniqueInput
  }

  export type ServiceBookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type ServiceItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceItemCreateWithoutServiceInput, ServiceItemUncheckedCreateWithoutServiceInput> | ServiceItemCreateWithoutServiceInput[] | ServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutServiceInput | ServiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceItemCreateManyServiceInputEnvelope
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
  }

  export type ServiceViewUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceViewCreateWithoutServiceInput, ServiceViewUncheckedCreateWithoutServiceInput> | ServiceViewCreateWithoutServiceInput[] | ServiceViewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutServiceInput | ServiceViewCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceViewCreateManyServiceInputEnvelope
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
  }

  export type ServiceBookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutServiceInput | ServiceBookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutServiceInput | ServiceBookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutServiceInput | ServiceBookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceItemCreateWithoutServiceInput, ServiceItemUncheckedCreateWithoutServiceInput> | ServiceItemCreateWithoutServiceInput[] | ServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutServiceInput | ServiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceItemUpsertWithWhereUniqueWithoutServiceInput | ServiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceItemCreateManyServiceInputEnvelope
    set?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    disconnect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    delete?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    update?: ServiceItemUpdateWithWhereUniqueWithoutServiceInput | ServiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceItemUpdateManyWithWhereWithoutServiceInput | ServiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
  }

  export type ServiceViewUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceViewCreateWithoutServiceInput, ServiceViewUncheckedCreateWithoutServiceInput> | ServiceViewCreateWithoutServiceInput[] | ServiceViewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutServiceInput | ServiceViewCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceViewUpsertWithWhereUniqueWithoutServiceInput | ServiceViewUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceViewCreateManyServiceInputEnvelope
    set?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    disconnect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    delete?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    update?: ServiceViewUpdateWithWhereUniqueWithoutServiceInput | ServiceViewUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceViewUpdateManyWithWhereWithoutServiceInput | ServiceViewUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceViewScalarWhereInput | ServiceViewScalarWhereInput[]
  }

  export type ServiceTypeUpdateOneWithoutServicesNestedInput = {
    create?: XOR<ServiceTypeCreateWithoutServicesInput, ServiceTypeUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceTypeCreateOrConnectWithoutServicesInput
    upsert?: ServiceTypeUpsertWithoutServicesInput
    disconnect?: ServiceTypeWhereInput | boolean
    delete?: ServiceTypeWhereInput | boolean
    connect?: ServiceTypeWhereUniqueInput
    update?: XOR<XOR<ServiceTypeUpdateToOneWithWhereWithoutServicesInput, ServiceTypeUpdateWithoutServicesInput>, ServiceTypeUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput> | ServiceBookingCreateWithoutServiceInput[] | ServiceBookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutServiceInput | ServiceBookingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutServiceInput | ServiceBookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBookingCreateManyServiceInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutServiceInput | ServiceBookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutServiceInput | ServiceBookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type ServiceItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceItemCreateWithoutServiceInput, ServiceItemUncheckedCreateWithoutServiceInput> | ServiceItemCreateWithoutServiceInput[] | ServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutServiceInput | ServiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceItemUpsertWithWhereUniqueWithoutServiceInput | ServiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceItemCreateManyServiceInputEnvelope
    set?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    disconnect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    delete?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    update?: ServiceItemUpdateWithWhereUniqueWithoutServiceInput | ServiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceItemUpdateManyWithWhereWithoutServiceInput | ServiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
  }

  export type ServiceViewUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceViewCreateWithoutServiceInput, ServiceViewUncheckedCreateWithoutServiceInput> | ServiceViewCreateWithoutServiceInput[] | ServiceViewUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceViewCreateOrConnectWithoutServiceInput | ServiceViewCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceViewUpsertWithWhereUniqueWithoutServiceInput | ServiceViewUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceViewCreateManyServiceInputEnvelope
    set?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    disconnect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    delete?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    connect?: ServiceViewWhereUniqueInput | ServiceViewWhereUniqueInput[]
    update?: ServiceViewUpdateWithWhereUniqueWithoutServiceInput | ServiceViewUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceViewUpdateManyWithWhereWithoutServiceInput | ServiceViewUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceViewScalarWhereInput | ServiceViewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProductCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    upsert?: ProductUpsertWithoutInventoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryInput, ProductUpdateWithoutInventoryInput>, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductCreateNestedOneWithoutInventoryMovementInput = {
    create?: XOR<ProductCreateWithoutInventoryMovementInput, ProductUncheckedCreateWithoutInventoryMovementInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryMovementInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInventoryMovementNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryMovementInput, ProductUncheckedCreateWithoutInventoryMovementInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryMovementInput
    upsert?: ProductUpsertWithoutInventoryMovementInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryMovementInput, ProductUpdateWithoutInventoryMovementInput>, ProductUncheckedUpdateWithoutInventoryMovementInput>
  }

  export type UserUpdateOneWithoutInventoryMovementsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    upsert?: UserUpsertWithoutInventoryMovementsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryMovementsInput, UserUpdateWithoutInventoryMovementsInput>, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ProductCreateNestedOneWithoutInventoryAlertInput = {
    create?: XOR<ProductCreateWithoutInventoryAlertInput, ProductUncheckedCreateWithoutInventoryAlertInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryAlertInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInventoryAlertNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryAlertInput, ProductUncheckedCreateWithoutInventoryAlertInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryAlertInput
    upsert?: ProductUpsertWithoutInventoryAlertInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryAlertInput, ProductUpdateWithoutInventoryAlertInput>, ProductUncheckedUpdateWithoutInventoryAlertInput>
  }

  export type ProductCreateNestedOneWithoutWishlistItemsInput = {
    create?: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWishlistItemsInput = {
    create?: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistItemsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutWishlistItemsNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemsInput
    upsert?: ProductUpsertWithoutWishlistItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWishlistItemsInput, ProductUpdateWithoutWishlistItemsInput>, ProductUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type UserUpdateOneRequiredWithoutWishlistItemsNestedInput = {
    create?: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistItemsInput
    upsert?: UserUpsertWithoutWishlistItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishlistItemsInput, UserUpdateWithoutWishlistItemsInput>, UserUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type ProductReviewReportCreateNestedManyWithoutReviewInput = {
    create?: XOR<ProductReviewReportCreateWithoutReviewInput, ProductReviewReportUncheckedCreateWithoutReviewInput> | ProductReviewReportCreateWithoutReviewInput[] | ProductReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewReportCreateOrConnectWithoutReviewInput | ProductReviewReportCreateOrConnectWithoutReviewInput[]
    createMany?: ProductReviewReportCreateManyReviewInputEnvelope
    connect?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
  }

  export type ProductReviewVoteCreateNestedManyWithoutReviewInput = {
    create?: XOR<ProductReviewVoteCreateWithoutReviewInput, ProductReviewVoteUncheckedCreateWithoutReviewInput> | ProductReviewVoteCreateWithoutReviewInput[] | ProductReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewVoteCreateOrConnectWithoutReviewInput | ProductReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ProductReviewVoteCreateManyReviewInputEnvelope
    connect?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductReviewReportUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ProductReviewReportCreateWithoutReviewInput, ProductReviewReportUncheckedCreateWithoutReviewInput> | ProductReviewReportCreateWithoutReviewInput[] | ProductReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewReportCreateOrConnectWithoutReviewInput | ProductReviewReportCreateOrConnectWithoutReviewInput[]
    createMany?: ProductReviewReportCreateManyReviewInputEnvelope
    connect?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
  }

  export type ProductReviewVoteUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ProductReviewVoteCreateWithoutReviewInput, ProductReviewVoteUncheckedCreateWithoutReviewInput> | ProductReviewVoteCreateWithoutReviewInput[] | ProductReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewVoteCreateOrConnectWithoutReviewInput | ProductReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ProductReviewVoteCreateManyReviewInputEnvelope
    connect?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type ProductReviewReportUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ProductReviewReportCreateWithoutReviewInput, ProductReviewReportUncheckedCreateWithoutReviewInput> | ProductReviewReportCreateWithoutReviewInput[] | ProductReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewReportCreateOrConnectWithoutReviewInput | ProductReviewReportCreateOrConnectWithoutReviewInput[]
    upsert?: ProductReviewReportUpsertWithWhereUniqueWithoutReviewInput | ProductReviewReportUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ProductReviewReportCreateManyReviewInputEnvelope
    set?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    disconnect?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    delete?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    connect?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    update?: ProductReviewReportUpdateWithWhereUniqueWithoutReviewInput | ProductReviewReportUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ProductReviewReportUpdateManyWithWhereWithoutReviewInput | ProductReviewReportUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ProductReviewReportScalarWhereInput | ProductReviewReportScalarWhereInput[]
  }

  export type ProductReviewVoteUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ProductReviewVoteCreateWithoutReviewInput, ProductReviewVoteUncheckedCreateWithoutReviewInput> | ProductReviewVoteCreateWithoutReviewInput[] | ProductReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewVoteCreateOrConnectWithoutReviewInput | ProductReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ProductReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ProductReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ProductReviewVoteCreateManyReviewInputEnvelope
    set?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    disconnect?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    delete?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    connect?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    update?: ProductReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ProductReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ProductReviewVoteUpdateManyWithWhereWithoutReviewInput | ProductReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ProductReviewVoteScalarWhereInput | ProductReviewVoteScalarWhereInput[]
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReviewsInput, ProductUpdateWithoutReviewsInput>, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductReviewReportUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ProductReviewReportCreateWithoutReviewInput, ProductReviewReportUncheckedCreateWithoutReviewInput> | ProductReviewReportCreateWithoutReviewInput[] | ProductReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewReportCreateOrConnectWithoutReviewInput | ProductReviewReportCreateOrConnectWithoutReviewInput[]
    upsert?: ProductReviewReportUpsertWithWhereUniqueWithoutReviewInput | ProductReviewReportUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ProductReviewReportCreateManyReviewInputEnvelope
    set?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    disconnect?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    delete?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    connect?: ProductReviewReportWhereUniqueInput | ProductReviewReportWhereUniqueInput[]
    update?: ProductReviewReportUpdateWithWhereUniqueWithoutReviewInput | ProductReviewReportUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ProductReviewReportUpdateManyWithWhereWithoutReviewInput | ProductReviewReportUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ProductReviewReportScalarWhereInput | ProductReviewReportScalarWhereInput[]
  }

  export type ProductReviewVoteUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ProductReviewVoteCreateWithoutReviewInput, ProductReviewVoteUncheckedCreateWithoutReviewInput> | ProductReviewVoteCreateWithoutReviewInput[] | ProductReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ProductReviewVoteCreateOrConnectWithoutReviewInput | ProductReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ProductReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ProductReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ProductReviewVoteCreateManyReviewInputEnvelope
    set?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    disconnect?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    delete?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    connect?: ProductReviewVoteWhereUniqueInput | ProductReviewVoteWhereUniqueInput[]
    update?: ProductReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ProductReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ProductReviewVoteUpdateManyWithWhereWithoutReviewInput | ProductReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ProductReviewVoteScalarWhereInput | ProductReviewVoteScalarWhereInput[]
  }

  export type ProductReviewCreateNestedOneWithoutVotesInput = {
    create?: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutVotesInput
    connect?: ProductReviewWhereUniqueInput
  }

  export type ProductReviewUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutVotesInput
    upsert?: ProductReviewUpsertWithoutVotesInput
    connect?: ProductReviewWhereUniqueInput
    update?: XOR<XOR<ProductReviewUpdateToOneWithWhereWithoutVotesInput, ProductReviewUpdateWithoutVotesInput>, ProductReviewUncheckedUpdateWithoutVotesInput>
  }

  export type ProductReviewCreateNestedOneWithoutReportsInput = {
    create?: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutReportsInput
    connect?: ProductReviewWhereUniqueInput
  }

  export type ProductReviewUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ProductReviewCreateOrConnectWithoutReportsInput
    upsert?: ProductReviewUpsertWithoutReportsInput
    connect?: ProductReviewWhereUniqueInput
    update?: XOR<XOR<ProductReviewUpdateToOneWithWhereWithoutReportsInput, ProductReviewUpdateWithoutReportsInput>, ProductReviewUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutSearchQueriesInput = {
    create?: XOR<UserCreateWithoutSearchQueriesInput, UserUncheckedCreateWithoutSearchQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchQueriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSearchQueriesNestedInput = {
    create?: XOR<UserCreateWithoutSearchQueriesInput, UserUncheckedCreateWithoutSearchQueriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchQueriesInput
    upsert?: UserUpsertWithoutSearchQueriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchQueriesInput, UserUpdateWithoutSearchQueriesInput>, UserUncheckedUpdateWithoutSearchQueriesInput>
  }

  export type ProductCreateNestedOneWithoutViewsInput = {
    create?: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutViewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductViewsInput = {
    create?: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductViewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutViewsInput
    upsert?: ProductUpsertWithoutViewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutViewsInput, ProductUpdateWithoutViewsInput>, ProductUncheckedUpdateWithoutViewsInput>
  }

  export type UserUpdateOneWithoutProductViewsNestedInput = {
    create?: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductViewsInput
    upsert?: UserUpsertWithoutProductViewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductViewsInput, UserUpdateWithoutProductViewsInput>, UserUncheckedUpdateWithoutProductViewsInput>
  }

  export type ServiceCreateNestedOneWithoutViewsInput = {
    create?: XOR<ServiceCreateWithoutViewsInput, ServiceUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutViewsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceViewsInput = {
    create?: XOR<UserCreateWithoutServiceViewsInput, UserUncheckedCreateWithoutServiceViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceViewsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<ServiceCreateWithoutViewsInput, ServiceUncheckedCreateWithoutViewsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutViewsInput
    upsert?: ServiceUpsertWithoutViewsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutViewsInput, ServiceUpdateWithoutViewsInput>, ServiceUncheckedUpdateWithoutViewsInput>
  }

  export type UserUpdateOneWithoutServiceViewsNestedInput = {
    create?: XOR<UserCreateWithoutServiceViewsInput, UserUncheckedCreateWithoutServiceViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceViewsInput
    upsert?: UserUpsertWithoutServiceViewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceViewsInput, UserUpdateWithoutServiceViewsInput>, UserUncheckedUpdateWithoutServiceViewsInput>
  }

  export type UserCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionsInput
    upsert?: UserUpsertWithoutQuestionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestionsInput, UserUpdateWithoutQuestionsInput>, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type ServiceBookingCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<ServiceBookingCreateWithoutTechnicianInput, ServiceBookingUncheckedCreateWithoutTechnicianInput> | ServiceBookingCreateWithoutTechnicianInput[] | ServiceBookingUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutTechnicianInput | ServiceBookingCreateOrConnectWithoutTechnicianInput[]
    createMany?: ServiceBookingCreateManyTechnicianInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type TechnicianScheduleCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<TechnicianScheduleCreateWithoutTechnicianInput, TechnicianScheduleUncheckedCreateWithoutTechnicianInput> | TechnicianScheduleCreateWithoutTechnicianInput[] | TechnicianScheduleUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: TechnicianScheduleCreateOrConnectWithoutTechnicianInput | TechnicianScheduleCreateOrConnectWithoutTechnicianInput[]
    createMany?: TechnicianScheduleCreateManyTechnicianInputEnvelope
    connect?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
  }

  export type ServiceBookingUncheckedCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<ServiceBookingCreateWithoutTechnicianInput, ServiceBookingUncheckedCreateWithoutTechnicianInput> | ServiceBookingCreateWithoutTechnicianInput[] | ServiceBookingUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutTechnicianInput | ServiceBookingCreateOrConnectWithoutTechnicianInput[]
    createMany?: ServiceBookingCreateManyTechnicianInputEnvelope
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
  }

  export type TechnicianScheduleUncheckedCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<TechnicianScheduleCreateWithoutTechnicianInput, TechnicianScheduleUncheckedCreateWithoutTechnicianInput> | TechnicianScheduleCreateWithoutTechnicianInput[] | TechnicianScheduleUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: TechnicianScheduleCreateOrConnectWithoutTechnicianInput | TechnicianScheduleCreateOrConnectWithoutTechnicianInput[]
    createMany?: TechnicianScheduleCreateManyTechnicianInputEnvelope
    connect?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
  }

  export type ServiceBookingUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutTechnicianInput, ServiceBookingUncheckedCreateWithoutTechnicianInput> | ServiceBookingCreateWithoutTechnicianInput[] | ServiceBookingUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutTechnicianInput | ServiceBookingCreateOrConnectWithoutTechnicianInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutTechnicianInput | ServiceBookingUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: ServiceBookingCreateManyTechnicianInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutTechnicianInput | ServiceBookingUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutTechnicianInput | ServiceBookingUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type TechnicianScheduleUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<TechnicianScheduleCreateWithoutTechnicianInput, TechnicianScheduleUncheckedCreateWithoutTechnicianInput> | TechnicianScheduleCreateWithoutTechnicianInput[] | TechnicianScheduleUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: TechnicianScheduleCreateOrConnectWithoutTechnicianInput | TechnicianScheduleCreateOrConnectWithoutTechnicianInput[]
    upsert?: TechnicianScheduleUpsertWithWhereUniqueWithoutTechnicianInput | TechnicianScheduleUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: TechnicianScheduleCreateManyTechnicianInputEnvelope
    set?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    disconnect?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    delete?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    connect?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    update?: TechnicianScheduleUpdateWithWhereUniqueWithoutTechnicianInput | TechnicianScheduleUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: TechnicianScheduleUpdateManyWithWhereWithoutTechnicianInput | TechnicianScheduleUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: TechnicianScheduleScalarWhereInput | TechnicianScheduleScalarWhereInput[]
  }

  export type ServiceBookingUncheckedUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutTechnicianInput, ServiceBookingUncheckedCreateWithoutTechnicianInput> | ServiceBookingCreateWithoutTechnicianInput[] | ServiceBookingUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutTechnicianInput | ServiceBookingCreateOrConnectWithoutTechnicianInput[]
    upsert?: ServiceBookingUpsertWithWhereUniqueWithoutTechnicianInput | ServiceBookingUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: ServiceBookingCreateManyTechnicianInputEnvelope
    set?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    disconnect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    delete?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    connect?: ServiceBookingWhereUniqueInput | ServiceBookingWhereUniqueInput[]
    update?: ServiceBookingUpdateWithWhereUniqueWithoutTechnicianInput | ServiceBookingUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: ServiceBookingUpdateManyWithWhereWithoutTechnicianInput | ServiceBookingUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
  }

  export type TechnicianScheduleUncheckedUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<TechnicianScheduleCreateWithoutTechnicianInput, TechnicianScheduleUncheckedCreateWithoutTechnicianInput> | TechnicianScheduleCreateWithoutTechnicianInput[] | TechnicianScheduleUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: TechnicianScheduleCreateOrConnectWithoutTechnicianInput | TechnicianScheduleCreateOrConnectWithoutTechnicianInput[]
    upsert?: TechnicianScheduleUpsertWithWhereUniqueWithoutTechnicianInput | TechnicianScheduleUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: TechnicianScheduleCreateManyTechnicianInputEnvelope
    set?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    disconnect?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    delete?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    connect?: TechnicianScheduleWhereUniqueInput | TechnicianScheduleWhereUniqueInput[]
    update?: TechnicianScheduleUpdateWithWhereUniqueWithoutTechnicianInput | TechnicianScheduleUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: TechnicianScheduleUpdateManyWithWhereWithoutTechnicianInput | TechnicianScheduleUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: TechnicianScheduleScalarWhereInput | TechnicianScheduleScalarWhereInput[]
  }

  export type ServiceBookingItemCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<ServiceBookingItemCreateWithoutServiceItemInput, ServiceBookingItemUncheckedCreateWithoutServiceItemInput> | ServiceBookingItemCreateWithoutServiceItemInput[] | ServiceBookingItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutServiceItemInput | ServiceBookingItemCreateOrConnectWithoutServiceItemInput[]
    createMany?: ServiceBookingItemCreateManyServiceItemInputEnvelope
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
  }

  export type ServiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<ServiceCreateWithoutItemsInput, ServiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutItemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceBookingItemUncheckedCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<ServiceBookingItemCreateWithoutServiceItemInput, ServiceBookingItemUncheckedCreateWithoutServiceItemInput> | ServiceBookingItemCreateWithoutServiceItemInput[] | ServiceBookingItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutServiceItemInput | ServiceBookingItemCreateOrConnectWithoutServiceItemInput[]
    createMany?: ServiceBookingItemCreateManyServiceItemInputEnvelope
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
  }

  export type ServiceBookingItemUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<ServiceBookingItemCreateWithoutServiceItemInput, ServiceBookingItemUncheckedCreateWithoutServiceItemInput> | ServiceBookingItemCreateWithoutServiceItemInput[] | ServiceBookingItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutServiceItemInput | ServiceBookingItemCreateOrConnectWithoutServiceItemInput[]
    upsert?: ServiceBookingItemUpsertWithWhereUniqueWithoutServiceItemInput | ServiceBookingItemUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: ServiceBookingItemCreateManyServiceItemInputEnvelope
    set?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    disconnect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    delete?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    update?: ServiceBookingItemUpdateWithWhereUniqueWithoutServiceItemInput | ServiceBookingItemUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: ServiceBookingItemUpdateManyWithWhereWithoutServiceItemInput | ServiceBookingItemUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: ServiceBookingItemScalarWhereInput | ServiceBookingItemScalarWhereInput[]
  }

  export type ServiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ServiceCreateWithoutItemsInput, ServiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutItemsInput
    upsert?: ServiceUpsertWithoutItemsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutItemsInput, ServiceUpdateWithoutItemsInput>, ServiceUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceBookingItemUncheckedUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<ServiceBookingItemCreateWithoutServiceItemInput, ServiceBookingItemUncheckedCreateWithoutServiceItemInput> | ServiceBookingItemCreateWithoutServiceItemInput[] | ServiceBookingItemUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutServiceItemInput | ServiceBookingItemCreateOrConnectWithoutServiceItemInput[]
    upsert?: ServiceBookingItemUpsertWithWhereUniqueWithoutServiceItemInput | ServiceBookingItemUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: ServiceBookingItemCreateManyServiceItemInputEnvelope
    set?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    disconnect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    delete?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    update?: ServiceBookingItemUpdateWithWhereUniqueWithoutServiceItemInput | ServiceBookingItemUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: ServiceBookingItemUpdateManyWithWhereWithoutServiceItemInput | ServiceBookingItemUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: ServiceBookingItemScalarWhereInput | ServiceBookingItemScalarWhereInput[]
  }

  export type ServiceBookingItemCreateNestedManyWithoutBookingInput = {
    create?: XOR<ServiceBookingItemCreateWithoutBookingInput, ServiceBookingItemUncheckedCreateWithoutBookingInput> | ServiceBookingItemCreateWithoutBookingInput[] | ServiceBookingItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutBookingInput | ServiceBookingItemCreateOrConnectWithoutBookingInput[]
    createMany?: ServiceBookingItemCreateManyBookingInputEnvelope
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type TechnicianCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TechnicianCreateWithoutBookingsInput, TechnicianUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutBookingsInput
    connect?: TechnicianWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceBookingInput = {
    create?: XOR<UserCreateWithoutServiceBookingInput, UserUncheckedCreateWithoutServiceBookingInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceBookingInput
    connect?: UserWhereUniqueInput
  }

  export type ServicePaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<ServicePaymentCreateWithoutBookingInput, ServicePaymentUncheckedCreateWithoutBookingInput> | ServicePaymentCreateWithoutBookingInput[] | ServicePaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServicePaymentCreateOrConnectWithoutBookingInput | ServicePaymentCreateOrConnectWithoutBookingInput[]
    createMany?: ServicePaymentCreateManyBookingInputEnvelope
    connect?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
  }

  export type ServiceStatusHistoryCreateNestedManyWithoutBookingInput = {
    create?: XOR<ServiceStatusHistoryCreateWithoutBookingInput, ServiceStatusHistoryUncheckedCreateWithoutBookingInput> | ServiceStatusHistoryCreateWithoutBookingInput[] | ServiceStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceStatusHistoryCreateOrConnectWithoutBookingInput | ServiceStatusHistoryCreateOrConnectWithoutBookingInput[]
    createMany?: ServiceStatusHistoryCreateManyBookingInputEnvelope
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
  }

  export type ServiceBookingItemUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ServiceBookingItemCreateWithoutBookingInput, ServiceBookingItemUncheckedCreateWithoutBookingInput> | ServiceBookingItemCreateWithoutBookingInput[] | ServiceBookingItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutBookingInput | ServiceBookingItemCreateOrConnectWithoutBookingInput[]
    createMany?: ServiceBookingItemCreateManyBookingInputEnvelope
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
  }

  export type ServicePaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ServicePaymentCreateWithoutBookingInput, ServicePaymentUncheckedCreateWithoutBookingInput> | ServicePaymentCreateWithoutBookingInput[] | ServicePaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServicePaymentCreateOrConnectWithoutBookingInput | ServicePaymentCreateOrConnectWithoutBookingInput[]
    createMany?: ServicePaymentCreateManyBookingInputEnvelope
    connect?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
  }

  export type ServiceStatusHistoryUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ServiceStatusHistoryCreateWithoutBookingInput, ServiceStatusHistoryUncheckedCreateWithoutBookingInput> | ServiceStatusHistoryCreateWithoutBookingInput[] | ServiceStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceStatusHistoryCreateOrConnectWithoutBookingInput | ServiceStatusHistoryCreateOrConnectWithoutBookingInput[]
    createMany?: ServiceStatusHistoryCreateManyBookingInputEnvelope
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
  }

  export type ServiceBookingItemUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ServiceBookingItemCreateWithoutBookingInput, ServiceBookingItemUncheckedCreateWithoutBookingInput> | ServiceBookingItemCreateWithoutBookingInput[] | ServiceBookingItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutBookingInput | ServiceBookingItemCreateOrConnectWithoutBookingInput[]
    upsert?: ServiceBookingItemUpsertWithWhereUniqueWithoutBookingInput | ServiceBookingItemUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ServiceBookingItemCreateManyBookingInputEnvelope
    set?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    disconnect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    delete?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    update?: ServiceBookingItemUpdateWithWhereUniqueWithoutBookingInput | ServiceBookingItemUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ServiceBookingItemUpdateManyWithWhereWithoutBookingInput | ServiceBookingItemUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ServiceBookingItemScalarWhereInput | ServiceBookingItemScalarWhereInput[]
  }

  export type ServiceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type TechnicianUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<TechnicianCreateWithoutBookingsInput, TechnicianUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutBookingsInput
    upsert?: TechnicianUpsertWithoutBookingsInput
    disconnect?: TechnicianWhereInput | boolean
    delete?: TechnicianWhereInput | boolean
    connect?: TechnicianWhereUniqueInput
    update?: XOR<XOR<TechnicianUpdateToOneWithWhereWithoutBookingsInput, TechnicianUpdateWithoutBookingsInput>, TechnicianUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutServiceBookingNestedInput = {
    create?: XOR<UserCreateWithoutServiceBookingInput, UserUncheckedCreateWithoutServiceBookingInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceBookingInput
    upsert?: UserUpsertWithoutServiceBookingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceBookingInput, UserUpdateWithoutServiceBookingInput>, UserUncheckedUpdateWithoutServiceBookingInput>
  }

  export type ServicePaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ServicePaymentCreateWithoutBookingInput, ServicePaymentUncheckedCreateWithoutBookingInput> | ServicePaymentCreateWithoutBookingInput[] | ServicePaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServicePaymentCreateOrConnectWithoutBookingInput | ServicePaymentCreateOrConnectWithoutBookingInput[]
    upsert?: ServicePaymentUpsertWithWhereUniqueWithoutBookingInput | ServicePaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ServicePaymentCreateManyBookingInputEnvelope
    set?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    disconnect?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    delete?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    connect?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    update?: ServicePaymentUpdateWithWhereUniqueWithoutBookingInput | ServicePaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ServicePaymentUpdateManyWithWhereWithoutBookingInput | ServicePaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ServicePaymentScalarWhereInput | ServicePaymentScalarWhereInput[]
  }

  export type ServiceStatusHistoryUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ServiceStatusHistoryCreateWithoutBookingInput, ServiceStatusHistoryUncheckedCreateWithoutBookingInput> | ServiceStatusHistoryCreateWithoutBookingInput[] | ServiceStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceStatusHistoryCreateOrConnectWithoutBookingInput | ServiceStatusHistoryCreateOrConnectWithoutBookingInput[]
    upsert?: ServiceStatusHistoryUpsertWithWhereUniqueWithoutBookingInput | ServiceStatusHistoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ServiceStatusHistoryCreateManyBookingInputEnvelope
    set?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    disconnect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    delete?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    update?: ServiceStatusHistoryUpdateWithWhereUniqueWithoutBookingInput | ServiceStatusHistoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ServiceStatusHistoryUpdateManyWithWhereWithoutBookingInput | ServiceStatusHistoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[]
  }

  export type ServiceBookingItemUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ServiceBookingItemCreateWithoutBookingInput, ServiceBookingItemUncheckedCreateWithoutBookingInput> | ServiceBookingItemCreateWithoutBookingInput[] | ServiceBookingItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceBookingItemCreateOrConnectWithoutBookingInput | ServiceBookingItemCreateOrConnectWithoutBookingInput[]
    upsert?: ServiceBookingItemUpsertWithWhereUniqueWithoutBookingInput | ServiceBookingItemUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ServiceBookingItemCreateManyBookingInputEnvelope
    set?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    disconnect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    delete?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    connect?: ServiceBookingItemWhereUniqueInput | ServiceBookingItemWhereUniqueInput[]
    update?: ServiceBookingItemUpdateWithWhereUniqueWithoutBookingInput | ServiceBookingItemUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ServiceBookingItemUpdateManyWithWhereWithoutBookingInput | ServiceBookingItemUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ServiceBookingItemScalarWhereInput | ServiceBookingItemScalarWhereInput[]
  }

  export type ServicePaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ServicePaymentCreateWithoutBookingInput, ServicePaymentUncheckedCreateWithoutBookingInput> | ServicePaymentCreateWithoutBookingInput[] | ServicePaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServicePaymentCreateOrConnectWithoutBookingInput | ServicePaymentCreateOrConnectWithoutBookingInput[]
    upsert?: ServicePaymentUpsertWithWhereUniqueWithoutBookingInput | ServicePaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ServicePaymentCreateManyBookingInputEnvelope
    set?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    disconnect?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    delete?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    connect?: ServicePaymentWhereUniqueInput | ServicePaymentWhereUniqueInput[]
    update?: ServicePaymentUpdateWithWhereUniqueWithoutBookingInput | ServicePaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ServicePaymentUpdateManyWithWhereWithoutBookingInput | ServicePaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ServicePaymentScalarWhereInput | ServicePaymentScalarWhereInput[]
  }

  export type ServiceStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ServiceStatusHistoryCreateWithoutBookingInput, ServiceStatusHistoryUncheckedCreateWithoutBookingInput> | ServiceStatusHistoryCreateWithoutBookingInput[] | ServiceStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ServiceStatusHistoryCreateOrConnectWithoutBookingInput | ServiceStatusHistoryCreateOrConnectWithoutBookingInput[]
    upsert?: ServiceStatusHistoryUpsertWithWhereUniqueWithoutBookingInput | ServiceStatusHistoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ServiceStatusHistoryCreateManyBookingInputEnvelope
    set?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    disconnect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    delete?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    connect?: ServiceStatusHistoryWhereUniqueInput | ServiceStatusHistoryWhereUniqueInput[]
    update?: ServiceStatusHistoryUpdateWithWhereUniqueWithoutBookingInput | ServiceStatusHistoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ServiceStatusHistoryUpdateManyWithWhereWithoutBookingInput | ServiceStatusHistoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[]
  }

  export type ServiceBookingCreateNestedOneWithoutItemsInput = {
    create?: XOR<ServiceBookingCreateWithoutItemsInput, ServiceBookingUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutItemsInput
    connect?: ServiceBookingWhereUniqueInput
  }

  export type ServiceItemCreateNestedOneWithoutBookingItemsInput = {
    create?: XOR<ServiceItemCreateWithoutBookingItemsInput, ServiceItemUncheckedCreateWithoutBookingItemsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutBookingItemsInput
    connect?: ServiceItemWhereUniqueInput
  }

  export type ServiceBookingUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutItemsInput, ServiceBookingUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutItemsInput
    upsert?: ServiceBookingUpsertWithoutItemsInput
    connect?: ServiceBookingWhereUniqueInput
    update?: XOR<XOR<ServiceBookingUpdateToOneWithWhereWithoutItemsInput, ServiceBookingUpdateWithoutItemsInput>, ServiceBookingUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceItemUpdateOneRequiredWithoutBookingItemsNestedInput = {
    create?: XOR<ServiceItemCreateWithoutBookingItemsInput, ServiceItemUncheckedCreateWithoutBookingItemsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutBookingItemsInput
    upsert?: ServiceItemUpsertWithoutBookingItemsInput
    connect?: ServiceItemWhereUniqueInput
    update?: XOR<XOR<ServiceItemUpdateToOneWithWhereWithoutBookingItemsInput, ServiceItemUpdateWithoutBookingItemsInput>, ServiceItemUncheckedUpdateWithoutBookingItemsInput>
  }

  export type TechnicianCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<TechnicianCreateWithoutSchedulesInput, TechnicianUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutSchedulesInput
    connect?: TechnicianWhereUniqueInput
  }

  export type TechnicianUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<TechnicianCreateWithoutSchedulesInput, TechnicianUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: TechnicianCreateOrConnectWithoutSchedulesInput
    upsert?: TechnicianUpsertWithoutSchedulesInput
    connect?: TechnicianWhereUniqueInput
    update?: XOR<XOR<TechnicianUpdateToOneWithWhereWithoutSchedulesInput, TechnicianUpdateWithoutSchedulesInput>, TechnicianUncheckedUpdateWithoutSchedulesInput>
  }

  export type ServiceBookingCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ServiceBookingCreateWithoutHistoryInput, ServiceBookingUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutHistoryInput
    connect?: ServiceBookingWhereUniqueInput
  }

  export type ServiceBookingUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutHistoryInput, ServiceBookingUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutHistoryInput
    upsert?: ServiceBookingUpsertWithoutHistoryInput
    connect?: ServiceBookingWhereUniqueInput
    update?: XOR<XOR<ServiceBookingUpdateToOneWithWhereWithoutHistoryInput, ServiceBookingUpdateWithoutHistoryInput>, ServiceBookingUncheckedUpdateWithoutHistoryInput>
  }

  export type ServiceBookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ServiceBookingCreateWithoutPaymentsInput, ServiceBookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutPaymentsInput
    connect?: ServiceBookingWhereUniqueInput
  }

  export type ServiceBookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ServiceBookingCreateWithoutPaymentsInput, ServiceBookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ServiceBookingCreateOrConnectWithoutPaymentsInput
    upsert?: ServiceBookingUpsertWithoutPaymentsInput
    connect?: ServiceBookingWhereUniqueInput
    update?: XOR<XOR<ServiceBookingUpdateToOneWithWhereWithoutPaymentsInput, ServiceBookingUpdateWithoutPaymentsInput>, ServiceBookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutLoyaltyAccountInput = {
    create?: XOR<UserCreateWithoutLoyaltyAccountInput, UserUncheckedCreateWithoutLoyaltyAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoyaltyAccountInput
    connect?: UserWhereUniqueInput
  }

  export type PointTransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<PointTransactionCreateWithoutAccountInput, PointTransactionUncheckedCreateWithoutAccountInput> | PointTransactionCreateWithoutAccountInput[] | PointTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutAccountInput | PointTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: PointTransactionCreateManyAccountInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type RedemptionHistoryCreateNestedManyWithoutAccountInput = {
    create?: XOR<RedemptionHistoryCreateWithoutAccountInput, RedemptionHistoryUncheckedCreateWithoutAccountInput> | RedemptionHistoryCreateWithoutAccountInput[] | RedemptionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutAccountInput | RedemptionHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: RedemptionHistoryCreateManyAccountInputEnvelope
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
  }

  export type PointTransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PointTransactionCreateWithoutAccountInput, PointTransactionUncheckedCreateWithoutAccountInput> | PointTransactionCreateWithoutAccountInput[] | PointTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutAccountInput | PointTransactionCreateOrConnectWithoutAccountInput[]
    createMany?: PointTransactionCreateManyAccountInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type RedemptionHistoryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<RedemptionHistoryCreateWithoutAccountInput, RedemptionHistoryUncheckedCreateWithoutAccountInput> | RedemptionHistoryCreateWithoutAccountInput[] | RedemptionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutAccountInput | RedemptionHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: RedemptionHistoryCreateManyAccountInputEnvelope
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLoyaltyAccountNestedInput = {
    create?: XOR<UserCreateWithoutLoyaltyAccountInput, UserUncheckedCreateWithoutLoyaltyAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoyaltyAccountInput
    upsert?: UserUpsertWithoutLoyaltyAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoyaltyAccountInput, UserUpdateWithoutLoyaltyAccountInput>, UserUncheckedUpdateWithoutLoyaltyAccountInput>
  }

  export type PointTransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PointTransactionCreateWithoutAccountInput, PointTransactionUncheckedCreateWithoutAccountInput> | PointTransactionCreateWithoutAccountInput[] | PointTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutAccountInput | PointTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutAccountInput | PointTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PointTransactionCreateManyAccountInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutAccountInput | PointTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutAccountInput | PointTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type RedemptionHistoryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RedemptionHistoryCreateWithoutAccountInput, RedemptionHistoryUncheckedCreateWithoutAccountInput> | RedemptionHistoryCreateWithoutAccountInput[] | RedemptionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutAccountInput | RedemptionHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: RedemptionHistoryUpsertWithWhereUniqueWithoutAccountInput | RedemptionHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RedemptionHistoryCreateManyAccountInputEnvelope
    set?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    disconnect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    delete?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    update?: RedemptionHistoryUpdateWithWhereUniqueWithoutAccountInput | RedemptionHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RedemptionHistoryUpdateManyWithWhereWithoutAccountInput | RedemptionHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RedemptionHistoryScalarWhereInput | RedemptionHistoryScalarWhereInput[]
  }

  export type PointTransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PointTransactionCreateWithoutAccountInput, PointTransactionUncheckedCreateWithoutAccountInput> | PointTransactionCreateWithoutAccountInput[] | PointTransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutAccountInput | PointTransactionCreateOrConnectWithoutAccountInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutAccountInput | PointTransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PointTransactionCreateManyAccountInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutAccountInput | PointTransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutAccountInput | PointTransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type RedemptionHistoryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RedemptionHistoryCreateWithoutAccountInput, RedemptionHistoryUncheckedCreateWithoutAccountInput> | RedemptionHistoryCreateWithoutAccountInput[] | RedemptionHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutAccountInput | RedemptionHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: RedemptionHistoryUpsertWithWhereUniqueWithoutAccountInput | RedemptionHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RedemptionHistoryCreateManyAccountInputEnvelope
    set?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    disconnect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    delete?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    update?: RedemptionHistoryUpdateWithWhereUniqueWithoutAccountInput | RedemptionHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RedemptionHistoryUpdateManyWithWhereWithoutAccountInput | RedemptionHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RedemptionHistoryScalarWhereInput | RedemptionHistoryScalarWhereInput[]
  }

  export type LoyaltyAccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LoyaltyAccountCreateWithoutTransactionsInput, LoyaltyAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutTransactionsInput
    connect?: LoyaltyAccountWhereUniqueInput
  }

  export type LoyaltyAccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LoyaltyAccountCreateWithoutTransactionsInput, LoyaltyAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutTransactionsInput
    upsert?: LoyaltyAccountUpsertWithoutTransactionsInput
    connect?: LoyaltyAccountWhereUniqueInput
    update?: XOR<XOR<LoyaltyAccountUpdateToOneWithWhereWithoutTransactionsInput, LoyaltyAccountUpdateWithoutTransactionsInput>, LoyaltyAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type LoyaltyAccountCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<LoyaltyAccountCreateWithoutRedemptionsInput, LoyaltyAccountUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutRedemptionsInput
    connect?: LoyaltyAccountWhereUniqueInput
  }

  export type LoyaltyRewardCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<LoyaltyRewardCreateWithoutRedemptionsInput, LoyaltyRewardUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: LoyaltyRewardCreateOrConnectWithoutRedemptionsInput
    connect?: LoyaltyRewardWhereUniqueInput
  }

  export type LoyaltyAccountUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<LoyaltyAccountCreateWithoutRedemptionsInput, LoyaltyAccountUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: LoyaltyAccountCreateOrConnectWithoutRedemptionsInput
    upsert?: LoyaltyAccountUpsertWithoutRedemptionsInput
    connect?: LoyaltyAccountWhereUniqueInput
    update?: XOR<XOR<LoyaltyAccountUpdateToOneWithWhereWithoutRedemptionsInput, LoyaltyAccountUpdateWithoutRedemptionsInput>, LoyaltyAccountUncheckedUpdateWithoutRedemptionsInput>
  }

  export type LoyaltyRewardUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<LoyaltyRewardCreateWithoutRedemptionsInput, LoyaltyRewardUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: LoyaltyRewardCreateOrConnectWithoutRedemptionsInput
    upsert?: LoyaltyRewardUpsertWithoutRedemptionsInput
    connect?: LoyaltyRewardWhereUniqueInput
    update?: XOR<XOR<LoyaltyRewardUpdateToOneWithWhereWithoutRedemptionsInput, LoyaltyRewardUpdateWithoutRedemptionsInput>, LoyaltyRewardUncheckedUpdateWithoutRedemptionsInput>
  }

  export type RedemptionHistoryCreateNestedManyWithoutRewardInput = {
    create?: XOR<RedemptionHistoryCreateWithoutRewardInput, RedemptionHistoryUncheckedCreateWithoutRewardInput> | RedemptionHistoryCreateWithoutRewardInput[] | RedemptionHistoryUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutRewardInput | RedemptionHistoryCreateOrConnectWithoutRewardInput[]
    createMany?: RedemptionHistoryCreateManyRewardInputEnvelope
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
  }

  export type RedemptionHistoryUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<RedemptionHistoryCreateWithoutRewardInput, RedemptionHistoryUncheckedCreateWithoutRewardInput> | RedemptionHistoryCreateWithoutRewardInput[] | RedemptionHistoryUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutRewardInput | RedemptionHistoryCreateOrConnectWithoutRewardInput[]
    createMany?: RedemptionHistoryCreateManyRewardInputEnvelope
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
  }

  export type RedemptionHistoryUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RedemptionHistoryCreateWithoutRewardInput, RedemptionHistoryUncheckedCreateWithoutRewardInput> | RedemptionHistoryCreateWithoutRewardInput[] | RedemptionHistoryUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutRewardInput | RedemptionHistoryCreateOrConnectWithoutRewardInput[]
    upsert?: RedemptionHistoryUpsertWithWhereUniqueWithoutRewardInput | RedemptionHistoryUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RedemptionHistoryCreateManyRewardInputEnvelope
    set?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    disconnect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    delete?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    update?: RedemptionHistoryUpdateWithWhereUniqueWithoutRewardInput | RedemptionHistoryUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RedemptionHistoryUpdateManyWithWhereWithoutRewardInput | RedemptionHistoryUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RedemptionHistoryScalarWhereInput | RedemptionHistoryScalarWhereInput[]
  }

  export type RedemptionHistoryUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<RedemptionHistoryCreateWithoutRewardInput, RedemptionHistoryUncheckedCreateWithoutRewardInput> | RedemptionHistoryCreateWithoutRewardInput[] | RedemptionHistoryUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: RedemptionHistoryCreateOrConnectWithoutRewardInput | RedemptionHistoryCreateOrConnectWithoutRewardInput[]
    upsert?: RedemptionHistoryUpsertWithWhereUniqueWithoutRewardInput | RedemptionHistoryUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: RedemptionHistoryCreateManyRewardInputEnvelope
    set?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    disconnect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    delete?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    connect?: RedemptionHistoryWhereUniqueInput | RedemptionHistoryWhereUniqueInput[]
    update?: RedemptionHistoryUpdateWithWhereUniqueWithoutRewardInput | RedemptionHistoryUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: RedemptionHistoryUpdateManyWithWhereWithoutRewardInput | RedemptionHistoryUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: RedemptionHistoryScalarWhereInput | RedemptionHistoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutKnowledgeEntriesInput = {
    create?: XOR<ProductCreateWithoutKnowledgeEntriesInput, ProductUncheckedCreateWithoutKnowledgeEntriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutKnowledgeEntriesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneWithoutKnowledgeEntriesNestedInput = {
    create?: XOR<ProductCreateWithoutKnowledgeEntriesInput, ProductUncheckedCreateWithoutKnowledgeEntriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutKnowledgeEntriesInput
    upsert?: ProductUpsertWithoutKnowledgeEntriesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutKnowledgeEntriesInput, ProductUpdateWithoutKnowledgeEntriesInput>, ProductUncheckedUpdateWithoutKnowledgeEntriesInput>
  }

  export type OrderCreateNestedOneWithoutPaymentIntentsInput = {
    create?: XOR<OrderCreateWithoutPaymentIntentsInput, OrderUncheckedCreateWithoutPaymentIntentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentIntentsInput
    connect?: OrderWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutIntentInput = {
    create?: XOR<PaymentCreateWithoutIntentInput, PaymentUncheckedCreateWithoutIntentInput> | PaymentCreateWithoutIntentInput[] | PaymentUncheckedCreateWithoutIntentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutIntentInput | PaymentCreateOrConnectWithoutIntentInput[]
    createMany?: PaymentCreateManyIntentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutIntentInput = {
    create?: XOR<PaymentCreateWithoutIntentInput, PaymentUncheckedCreateWithoutIntentInput> | PaymentCreateWithoutIntentInput[] | PaymentUncheckedCreateWithoutIntentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutIntentInput | PaymentCreateOrConnectWithoutIntentInput[]
    createMany?: PaymentCreateManyIntentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutPaymentIntentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentIntentsInput, OrderUncheckedCreateWithoutPaymentIntentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentIntentsInput
    upsert?: OrderUpsertWithoutPaymentIntentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentIntentsInput, OrderUpdateWithoutPaymentIntentsInput>, OrderUncheckedUpdateWithoutPaymentIntentsInput>
  }

  export type PaymentUpdateManyWithoutIntentNestedInput = {
    create?: XOR<PaymentCreateWithoutIntentInput, PaymentUncheckedCreateWithoutIntentInput> | PaymentCreateWithoutIntentInput[] | PaymentUncheckedCreateWithoutIntentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutIntentInput | PaymentCreateOrConnectWithoutIntentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutIntentInput | PaymentUpsertWithWhereUniqueWithoutIntentInput[]
    createMany?: PaymentCreateManyIntentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutIntentInput | PaymentUpdateWithWhereUniqueWithoutIntentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutIntentInput | PaymentUpdateManyWithWhereWithoutIntentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutIntentNestedInput = {
    create?: XOR<PaymentCreateWithoutIntentInput, PaymentUncheckedCreateWithoutIntentInput> | PaymentCreateWithoutIntentInput[] | PaymentUncheckedCreateWithoutIntentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutIntentInput | PaymentCreateOrConnectWithoutIntentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutIntentInput | PaymentUpsertWithWhereUniqueWithoutIntentInput[]
    createMany?: PaymentCreateManyIntentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutIntentInput | PaymentUpdateWithWhereUniqueWithoutIntentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutIntentInput | PaymentUpdateManyWithWhereWithoutIntentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type CampaignClickCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignClickCreateWithoutCampaignInput, CampaignClickUncheckedCreateWithoutCampaignInput> | CampaignClickCreateWithoutCampaignInput[] | CampaignClickUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignClickCreateOrConnectWithoutCampaignInput | CampaignClickCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignClickCreateManyCampaignInputEnvelope
    connect?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
  }

  export type CampaignOpenCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignOpenCreateWithoutCampaignInput, CampaignOpenUncheckedCreateWithoutCampaignInput> | CampaignOpenCreateWithoutCampaignInput[] | CampaignOpenUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOpenCreateOrConnectWithoutCampaignInput | CampaignOpenCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignOpenCreateManyCampaignInputEnvelope
    connect?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
  }

  export type CampaignRecipientCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
  }

  export type EmailLogCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailLogCreateWithoutCampaignInput, EmailLogUncheckedCreateWithoutCampaignInput> | EmailLogCreateWithoutCampaignInput[] | EmailLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutCampaignInput | EmailLogCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailLogCreateManyCampaignInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type CampaignClickUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignClickCreateWithoutCampaignInput, CampaignClickUncheckedCreateWithoutCampaignInput> | CampaignClickCreateWithoutCampaignInput[] | CampaignClickUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignClickCreateOrConnectWithoutCampaignInput | CampaignClickCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignClickCreateManyCampaignInputEnvelope
    connect?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
  }

  export type CampaignOpenUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignOpenCreateWithoutCampaignInput, CampaignOpenUncheckedCreateWithoutCampaignInput> | CampaignOpenCreateWithoutCampaignInput[] | CampaignOpenUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOpenCreateOrConnectWithoutCampaignInput | CampaignOpenCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignOpenCreateManyCampaignInputEnvelope
    connect?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
  }

  export type CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
  }

  export type EmailLogUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EmailLogCreateWithoutCampaignInput, EmailLogUncheckedCreateWithoutCampaignInput> | EmailLogCreateWithoutCampaignInput[] | EmailLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutCampaignInput | EmailLogCreateOrConnectWithoutCampaignInput[]
    createMany?: EmailLogCreateManyCampaignInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type EnumCampaignTypeFieldUpdateOperationsInput = {
    set?: $Enums.CampaignType
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type CampaignClickUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignClickCreateWithoutCampaignInput, CampaignClickUncheckedCreateWithoutCampaignInput> | CampaignClickCreateWithoutCampaignInput[] | CampaignClickUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignClickCreateOrConnectWithoutCampaignInput | CampaignClickCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignClickUpsertWithWhereUniqueWithoutCampaignInput | CampaignClickUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignClickCreateManyCampaignInputEnvelope
    set?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    disconnect?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    delete?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    connect?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    update?: CampaignClickUpdateWithWhereUniqueWithoutCampaignInput | CampaignClickUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignClickUpdateManyWithWhereWithoutCampaignInput | CampaignClickUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignClickScalarWhereInput | CampaignClickScalarWhereInput[]
  }

  export type CampaignOpenUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignOpenCreateWithoutCampaignInput, CampaignOpenUncheckedCreateWithoutCampaignInput> | CampaignOpenCreateWithoutCampaignInput[] | CampaignOpenUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOpenCreateOrConnectWithoutCampaignInput | CampaignOpenCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignOpenUpsertWithWhereUniqueWithoutCampaignInput | CampaignOpenUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignOpenCreateManyCampaignInputEnvelope
    set?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    disconnect?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    delete?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    connect?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    update?: CampaignOpenUpdateWithWhereUniqueWithoutCampaignInput | CampaignOpenUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignOpenUpdateManyWithWhereWithoutCampaignInput | CampaignOpenUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignOpenScalarWhereInput | CampaignOpenScalarWhereInput[]
  }

  export type CampaignRecipientUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    set?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    disconnect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    delete?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    update?: CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignRecipientUpdateManyWithWhereWithoutCampaignInput | CampaignRecipientUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
  }

  export type EmailLogUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailLogCreateWithoutCampaignInput, EmailLogUncheckedCreateWithoutCampaignInput> | EmailLogCreateWithoutCampaignInput[] | EmailLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutCampaignInput | EmailLogCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutCampaignInput | EmailLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailLogCreateManyCampaignInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutCampaignInput | EmailLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutCampaignInput | EmailLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type CampaignClickUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignClickCreateWithoutCampaignInput, CampaignClickUncheckedCreateWithoutCampaignInput> | CampaignClickCreateWithoutCampaignInput[] | CampaignClickUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignClickCreateOrConnectWithoutCampaignInput | CampaignClickCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignClickUpsertWithWhereUniqueWithoutCampaignInput | CampaignClickUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignClickCreateManyCampaignInputEnvelope
    set?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    disconnect?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    delete?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    connect?: CampaignClickWhereUniqueInput | CampaignClickWhereUniqueInput[]
    update?: CampaignClickUpdateWithWhereUniqueWithoutCampaignInput | CampaignClickUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignClickUpdateManyWithWhereWithoutCampaignInput | CampaignClickUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignClickScalarWhereInput | CampaignClickScalarWhereInput[]
  }

  export type CampaignOpenUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignOpenCreateWithoutCampaignInput, CampaignOpenUncheckedCreateWithoutCampaignInput> | CampaignOpenCreateWithoutCampaignInput[] | CampaignOpenUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignOpenCreateOrConnectWithoutCampaignInput | CampaignOpenCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignOpenUpsertWithWhereUniqueWithoutCampaignInput | CampaignOpenUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignOpenCreateManyCampaignInputEnvelope
    set?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    disconnect?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    delete?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    connect?: CampaignOpenWhereUniqueInput | CampaignOpenWhereUniqueInput[]
    update?: CampaignOpenUpdateWithWhereUniqueWithoutCampaignInput | CampaignOpenUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignOpenUpdateManyWithWhereWithoutCampaignInput | CampaignOpenUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignOpenScalarWhereInput | CampaignOpenScalarWhereInput[]
  }

  export type CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput> | CampaignRecipientCreateWithoutCampaignInput[] | CampaignRecipientUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignRecipientCreateOrConnectWithoutCampaignInput | CampaignRecipientCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignRecipientCreateManyCampaignInputEnvelope
    set?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    disconnect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    delete?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    connect?: CampaignRecipientWhereUniqueInput | CampaignRecipientWhereUniqueInput[]
    update?: CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput | CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignRecipientUpdateManyWithWhereWithoutCampaignInput | CampaignRecipientUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
  }

  export type EmailLogUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EmailLogCreateWithoutCampaignInput, EmailLogUncheckedCreateWithoutCampaignInput> | EmailLogCreateWithoutCampaignInput[] | EmailLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutCampaignInput | EmailLogCreateOrConnectWithoutCampaignInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutCampaignInput | EmailLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EmailLogCreateManyCampaignInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutCampaignInput | EmailLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutCampaignInput | EmailLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRecipientsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutRecipientsInput
    upsert?: CampaignUpsertWithoutRecipientsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutRecipientsInput, CampaignUpdateWithoutRecipientsInput>, CampaignUncheckedUpdateWithoutRecipientsInput>
  }

  export type CampaignCreateNestedOneWithoutOpensInput = {
    create?: XOR<CampaignCreateWithoutOpensInput, CampaignUncheckedCreateWithoutOpensInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOpensInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutOpensNestedInput = {
    create?: XOR<CampaignCreateWithoutOpensInput, CampaignUncheckedCreateWithoutOpensInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOpensInput
    upsert?: CampaignUpsertWithoutOpensInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutOpensInput, CampaignUpdateWithoutOpensInput>, CampaignUncheckedUpdateWithoutOpensInput>
  }

  export type CampaignCreateNestedOneWithoutClicksInput = {
    create?: XOR<CampaignCreateWithoutClicksInput, CampaignUncheckedCreateWithoutClicksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutClicksInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutClicksNestedInput = {
    create?: XOR<CampaignCreateWithoutClicksInput, CampaignUncheckedCreateWithoutClicksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutClicksInput
    upsert?: CampaignUpsertWithoutClicksInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutClicksInput, CampaignUpdateWithoutClicksInput>, CampaignUncheckedUpdateWithoutClicksInput>
  }

  export type CampaignCreateNestedOneWithoutEmailLogsInput = {
    create?: XOR<CampaignCreateWithoutEmailLogsInput, CampaignUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailLogsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneWithoutEmailLogsNestedInput = {
    create?: XOR<CampaignCreateWithoutEmailLogsInput, CampaignUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEmailLogsInput
    upsert?: CampaignUpsertWithoutEmailLogsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEmailLogsInput, CampaignUpdateWithoutEmailLogsInput>, CampaignUncheckedUpdateWithoutEmailLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumCampaignTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeFilter<$PrismaModel> | $Enums.CampaignType
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignType | EnumCampaignTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignType[] | ListEnumCampaignTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignTypeFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    method?: string | null
    url?: string | null
    statusCode?: number | null
    duration?: number | null
    category?: string
    severity?: string
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    method?: string | null
    url?: string | null
    statusCode?: number | null
    duration?: number | null
    category?: string
    severity?: string
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartCreateManyUserInputEnvelope = {
    data: CartCreateManyUserInput | CartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerQuestionCreateWithoutUserInput = {
    id?: string
    question: string
    category?: string | null
    satisfaction?: number | null
    timestamp?: Date | string
  }

  export type CustomerQuestionUncheckedCreateWithoutUserInput = {
    id?: string
    question: string
    category?: string | null
    satisfaction?: number | null
    timestamp?: Date | string
  }

  export type CustomerQuestionCreateOrConnectWithoutUserInput = {
    where: CustomerQuestionWhereUniqueInput
    create: XOR<CustomerQuestionCreateWithoutUserInput, CustomerQuestionUncheckedCreateWithoutUserInput>
  }

  export type CustomerQuestionCreateManyUserInputEnvelope = {
    data: CustomerQuestionCreateManyUserInput | CustomerQuestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutUserInput = {
    id?: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryMovementInput
  }

  export type InventoryMovementUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput>
  }

  export type InventoryMovementCreateManyUserInputEnvelope = {
    data: InventoryMovementCreateManyUserInput | InventoryMovementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyAccountCreateWithoutUserInput = {
    id?: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: PointTransactionCreateNestedManyWithoutAccountInput
    redemptions?: RedemptionHistoryCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountUncheckedCreateWithoutUserInput = {
    id?: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutAccountInput
    redemptions?: RedemptionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountCreateOrConnectWithoutUserInput = {
    where: LoyaltyAccountWhereUniqueInput
    create: XOR<LoyaltyAccountCreateWithoutUserInput, LoyaltyAccountUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    orderNo: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    orderNo: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportCreateNestedManyWithoutReviewInput
    votes?: ProductReviewVoteCreateNestedManyWithoutReviewInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ProductReviewUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportUncheckedCreateNestedManyWithoutReviewInput
    votes?: ProductReviewVoteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput>
  }

  export type ProductReviewCreateManyUserInputEnvelope = {
    data: ProductReviewCreateManyUserInput | ProductReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductViewCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    duration?: number | null
    product: ProductCreateNestedOneWithoutViewsInput
  }

  export type ProductViewUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    timestamp?: Date | string
    duration?: number | null
  }

  export type ProductViewCreateOrConnectWithoutUserInput = {
    where: ProductViewWhereUniqueInput
    create: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput>
  }

  export type ProductViewCreateManyUserInputEnvelope = {
    data: ProductViewCreateManyUserInput | ProductViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    client?: string | null
    clientLogo?: string | null
    category?: string | null
    technologies?: string | null
    features?: string | null
    images?: string | null
    thumbnailImage?: string | null
    coverImage?: string | null
    youtubeVideoId?: string | null
    youtubeVideoUrl?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    liveUrl?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: string | null
    teamSize?: number | null
    budget?: string | null
    status?: string
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: number
    viewCount?: number
    tags?: string | null
    testimonial?: string | null
    results?: string | null
    challenges?: string | null
    solutions?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    structuredData?: string | null
    canonicalUrl?: string | null
    content?: string | null
    galleryImages?: string | null
    clientLogoUrl?: string | null
    projectDate?: Date | string | null
    completionDate?: Date | string | null
    featured?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    client?: string | null
    clientLogo?: string | null
    category?: string | null
    technologies?: string | null
    features?: string | null
    images?: string | null
    thumbnailImage?: string | null
    coverImage?: string | null
    youtubeVideoId?: string | null
    youtubeVideoUrl?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    liveUrl?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: string | null
    teamSize?: number | null
    budget?: string | null
    status?: string
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: number
    viewCount?: number
    tags?: string | null
    testimonial?: string | null
    results?: string | null
    challenges?: string | null
    solutions?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    structuredData?: string | null
    canonicalUrl?: string | null
    content?: string | null
    galleryImages?: string | null
    clientLogoUrl?: string | null
    projectDate?: Date | string | null
    completionDate?: Date | string | null
    featured?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchQueryCreateWithoutUserInput = {
    id?: string
    query: string
    timestamp?: Date | string
  }

  export type SearchQueryUncheckedCreateWithoutUserInput = {
    id?: string
    query: string
    timestamp?: Date | string
  }

  export type SearchQueryCreateOrConnectWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    create: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput>
  }

  export type SearchQueryCreateManyUserInputEnvelope = {
    data: SearchQueryCreateManyUserInput | SearchQueryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBookingCreateWithoutUserInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemCreateNestedManyWithoutBookingInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    technician?: TechnicianCreateNestedOneWithoutBookingsInput
    payments?: ServicePaymentCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemUncheckedCreateNestedManyWithoutBookingInput
    payments?: ServicePaymentUncheckedCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingCreateOrConnectWithoutUserInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput>
  }

  export type ServiceBookingCreateManyUserInputEnvelope = {
    data: ServiceBookingCreateManyUserInput | ServiceBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceViewCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    duration?: number | null
    service: ServiceCreateNestedOneWithoutViewsInput
  }

  export type ServiceViewUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    timestamp?: Date | string
    duration?: number | null
  }

  export type ServiceViewCreateOrConnectWithoutUserInput = {
    where: ServiceViewWhereUniqueInput
    create: XOR<ServiceViewCreateWithoutUserInput, ServiceViewUncheckedCreateWithoutUserInput>
  }

  export type ServiceViewCreateManyUserInputEnvelope = {
    data: ServiceViewCreateManyUserInput | ServiceViewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutWishlistItemsInput
  }

  export type WishlistItemUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput>
  }

  export type WishlistItemCreateManyUserInputEnvelope = {
    data: WishlistItemCreateManyUserInput | WishlistItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    resource?: StringNullableFilter<"ActivityLog"> | string | null
    resourceId?: StringNullableFilter<"ActivityLog"> | string | null
    details?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    method?: StringNullableFilter<"ActivityLog"> | string | null
    url?: StringNullableFilter<"ActivityLog"> | string | null
    statusCode?: IntNullableFilter<"ActivityLog"> | number | null
    duration?: IntNullableFilter<"ActivityLog"> | number | null
    category?: StringFilter<"ActivityLog"> | string
    severity?: StringFilter<"ActivityLog"> | string
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutUserInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringNullableFilter<"Cart"> | string | null
    guestId?: StringNullableFilter<"Cart"> | string | null
    status?: StringFilter<"Cart"> | string
    expiresAt?: DateTimeNullableFilter<"Cart"> | Date | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type CustomerQuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: CustomerQuestionWhereUniqueInput
    update: XOR<CustomerQuestionUpdateWithoutUserInput, CustomerQuestionUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerQuestionCreateWithoutUserInput, CustomerQuestionUncheckedCreateWithoutUserInput>
  }

  export type CustomerQuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: CustomerQuestionWhereUniqueInput
    data: XOR<CustomerQuestionUpdateWithoutUserInput, CustomerQuestionUncheckedUpdateWithoutUserInput>
  }

  export type CustomerQuestionUpdateManyWithWhereWithoutUserInput = {
    where: CustomerQuestionScalarWhereInput
    data: XOR<CustomerQuestionUpdateManyMutationInput, CustomerQuestionUncheckedUpdateManyWithoutUserInput>
  }

  export type CustomerQuestionScalarWhereInput = {
    AND?: CustomerQuestionScalarWhereInput | CustomerQuestionScalarWhereInput[]
    OR?: CustomerQuestionScalarWhereInput[]
    NOT?: CustomerQuestionScalarWhereInput | CustomerQuestionScalarWhereInput[]
    id?: StringFilter<"CustomerQuestion"> | string
    userId?: StringNullableFilter<"CustomerQuestion"> | string | null
    question?: StringFilter<"CustomerQuestion"> | string
    category?: StringNullableFilter<"CustomerQuestion"> | string | null
    satisfaction?: IntNullableFilter<"CustomerQuestion"> | number | null
    timestamp?: DateTimeFilter<"CustomerQuestion"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutUserInput, InventoryMovementUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutUserInput, InventoryMovementUncheckedUpdateWithoutUserInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutUserInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    productId?: StringFilter<"InventoryMovement"> | string
    type?: StringFilter<"InventoryMovement"> | string
    quantity?: IntFilter<"InventoryMovement"> | number
    previousStock?: IntFilter<"InventoryMovement"> | number
    newStock?: IntFilter<"InventoryMovement"> | number
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceId?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableFilter<"InventoryMovement"> | string | null
    userId?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
  }

  export type LoyaltyAccountUpsertWithoutUserInput = {
    update: XOR<LoyaltyAccountUpdateWithoutUserInput, LoyaltyAccountUncheckedUpdateWithoutUserInput>
    create: XOR<LoyaltyAccountCreateWithoutUserInput, LoyaltyAccountUncheckedCreateWithoutUserInput>
    where?: LoyaltyAccountWhereInput
  }

  export type LoyaltyAccountUpdateToOneWithWhereWithoutUserInput = {
    where?: LoyaltyAccountWhereInput
    data: XOR<LoyaltyAccountUpdateWithoutUserInput, LoyaltyAccountUncheckedUpdateWithoutUserInput>
  }

  export type LoyaltyAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: PointTransactionUpdateManyWithoutAccountNestedInput
    redemptions?: RedemptionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type LoyaltyAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: PointTransactionUncheckedUpdateManyWithoutAccountNestedInput
    redemptions?: RedemptionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNo?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    subtotalCents?: IntFilter<"Order"> | number
    discountCents?: IntFilter<"Order"> | number
    shippingCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    shippingCoordinates?: StringNullableFilter<"Order"> | string | null
    promotionCode?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutUserInput, ProductReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutUserInput, ProductReviewUncheckedUpdateWithoutUserInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutUserInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductReviewScalarWhereInput = {
    AND?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
    OR?: ProductReviewScalarWhereInput[]
    NOT?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
    id?: StringFilter<"ProductReview"> | string
    userId?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    title?: StringNullableFilter<"ProductReview"> | string | null
    comment?: StringNullableFilter<"ProductReview"> | string | null
    isVerified?: BoolFilter<"ProductReview"> | boolean
    status?: EnumReviewStatusFilter<"ProductReview"> | $Enums.ReviewStatus
    upvotes?: IntFilter<"ProductReview"> | number
    downvotes?: IntFilter<"ProductReview"> | number
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string
  }

  export type ProductViewUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductViewWhereUniqueInput
    update: XOR<ProductViewUpdateWithoutUserInput, ProductViewUncheckedUpdateWithoutUserInput>
    create: XOR<ProductViewCreateWithoutUserInput, ProductViewUncheckedCreateWithoutUserInput>
  }

  export type ProductViewUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductViewWhereUniqueInput
    data: XOR<ProductViewUpdateWithoutUserInput, ProductViewUncheckedUpdateWithoutUserInput>
  }

  export type ProductViewUpdateManyWithWhereWithoutUserInput = {
    where: ProductViewScalarWhereInput
    data: XOR<ProductViewUpdateManyMutationInput, ProductViewUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductViewScalarWhereInput = {
    AND?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
    OR?: ProductViewScalarWhereInput[]
    NOT?: ProductViewScalarWhereInput | ProductViewScalarWhereInput[]
    id?: StringFilter<"ProductView"> | string
    productId?: StringFilter<"ProductView"> | string
    userId?: StringNullableFilter<"ProductView"> | string | null
    timestamp?: DateTimeFilter<"ProductView"> | Date | string
    duration?: IntNullableFilter<"ProductView"> | number | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    shortDescription?: StringNullableFilter<"Project"> | string | null
    client?: StringNullableFilter<"Project"> | string | null
    clientLogo?: StringNullableFilter<"Project"> | string | null
    category?: StringNullableFilter<"Project"> | string | null
    technologies?: StringNullableFilter<"Project"> | string | null
    features?: StringNullableFilter<"Project"> | string | null
    images?: StringNullableFilter<"Project"> | string | null
    thumbnailImage?: StringNullableFilter<"Project"> | string | null
    coverImage?: StringNullableFilter<"Project"> | string | null
    youtubeVideoId?: StringNullableFilter<"Project"> | string | null
    youtubeVideoUrl?: StringNullableFilter<"Project"> | string | null
    demoUrl?: StringNullableFilter<"Project"> | string | null
    githubUrl?: StringNullableFilter<"Project"> | string | null
    liveUrl?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    duration?: StringNullableFilter<"Project"> | string | null
    teamSize?: IntNullableFilter<"Project"> | number | null
    budget?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    isActive?: BoolFilter<"Project"> | boolean
    isFeatured?: BoolFilter<"Project"> | boolean
    displayOrder?: IntFilter<"Project"> | number
    viewCount?: IntFilter<"Project"> | number
    userId?: StringFilter<"Project"> | string
    tags?: StringNullableFilter<"Project"> | string | null
    testimonial?: StringNullableFilter<"Project"> | string | null
    results?: StringNullableFilter<"Project"> | string | null
    challenges?: StringNullableFilter<"Project"> | string | null
    solutions?: StringNullableFilter<"Project"> | string | null
    metaTitle?: StringNullableFilter<"Project"> | string | null
    metaDescription?: StringNullableFilter<"Project"> | string | null
    metaKeywords?: StringNullableFilter<"Project"> | string | null
    ogTitle?: StringNullableFilter<"Project"> | string | null
    ogDescription?: StringNullableFilter<"Project"> | string | null
    ogImage?: StringNullableFilter<"Project"> | string | null
    structuredData?: StringNullableFilter<"Project"> | string | null
    canonicalUrl?: StringNullableFilter<"Project"> | string | null
    content?: StringNullableFilter<"Project"> | string | null
    galleryImages?: StringNullableFilter<"Project"> | string | null
    clientLogoUrl?: StringNullableFilter<"Project"> | string | null
    projectDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    completionDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    featured?: BoolFilter<"Project"> | boolean
    isDeleted?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type SearchQueryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    update: XOR<SearchQueryUpdateWithoutUserInput, SearchQueryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput>
  }

  export type SearchQueryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    data: XOR<SearchQueryUpdateWithoutUserInput, SearchQueryUncheckedUpdateWithoutUserInput>
  }

  export type SearchQueryUpdateManyWithWhereWithoutUserInput = {
    where: SearchQueryScalarWhereInput
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchQueryScalarWhereInput = {
    AND?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
    OR?: SearchQueryScalarWhereInput[]
    NOT?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
    id?: StringFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    userId?: StringNullableFilter<"SearchQuery"> | string | null
    timestamp?: DateTimeFilter<"SearchQuery"> | Date | string
  }

  export type ServiceBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceBookingWhereUniqueInput
    update: XOR<ServiceBookingUpdateWithoutUserInput, ServiceBookingUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceBookingCreateWithoutUserInput, ServiceBookingUncheckedCreateWithoutUserInput>
  }

  export type ServiceBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceBookingWhereUniqueInput
    data: XOR<ServiceBookingUpdateWithoutUserInput, ServiceBookingUncheckedUpdateWithoutUserInput>
  }

  export type ServiceBookingUpdateManyWithWhereWithoutUserInput = {
    where: ServiceBookingScalarWhereInput
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceBookingScalarWhereInput = {
    AND?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
    OR?: ServiceBookingScalarWhereInput[]
    NOT?: ServiceBookingScalarWhereInput | ServiceBookingScalarWhereInput[]
    id?: StringFilter<"ServiceBooking"> | string
    userId?: StringFilter<"ServiceBooking"> | string
    serviceId?: StringFilter<"ServiceBooking"> | string
    technicianId?: StringNullableFilter<"ServiceBooking"> | string | null
    status?: StringFilter<"ServiceBooking"> | string
    scheduledAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    scheduledTime?: StringNullableFilter<"ServiceBooking"> | string | null
    completedAt?: DateTimeNullableFilter<"ServiceBooking"> | Date | string | null
    notes?: StringNullableFilter<"ServiceBooking"> | string | null
    estimatedCosts?: IntNullableFilter<"ServiceBooking"> | number | null
    actualCosts?: IntNullableFilter<"ServiceBooking"> | number | null
    createdAt?: DateTimeFilter<"ServiceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceBooking"> | Date | string
  }

  export type ServiceViewUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceViewWhereUniqueInput
    update: XOR<ServiceViewUpdateWithoutUserInput, ServiceViewUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceViewCreateWithoutUserInput, ServiceViewUncheckedCreateWithoutUserInput>
  }

  export type ServiceViewUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceViewWhereUniqueInput
    data: XOR<ServiceViewUpdateWithoutUserInput, ServiceViewUncheckedUpdateWithoutUserInput>
  }

  export type ServiceViewUpdateManyWithWhereWithoutUserInput = {
    where: ServiceViewScalarWhereInput
    data: XOR<ServiceViewUpdateManyMutationInput, ServiceViewUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceViewScalarWhereInput = {
    AND?: ServiceViewScalarWhereInput | ServiceViewScalarWhereInput[]
    OR?: ServiceViewScalarWhereInput[]
    NOT?: ServiceViewScalarWhereInput | ServiceViewScalarWhereInput[]
    id?: StringFilter<"ServiceView"> | string
    serviceId?: StringFilter<"ServiceView"> | string
    userId?: StringNullableFilter<"ServiceView"> | string | null
    timestamp?: DateTimeFilter<"ServiceView"> | Date | string
    duration?: IntNullableFilter<"ServiceView"> | number | null
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutUserInput, WishlistItemUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutUserInput, WishlistItemUncheckedUpdateWithoutUserInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutUserInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutUserInput>
  }

  export type WishlistItemScalarWhereInput = {
    AND?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    OR?: WishlistItemScalarWhereInput[]
    NOT?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutProductInput = {
    id?: string
    stock?: number
    reserved?: number
    lowStockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: string
    stock?: number
    reserved?: number
    lowStockThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryAlertCreateWithoutProductInput = {
    id?: string
    type: string
    message: string
    threshold?: number | null
    currentStock: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAlertUncheckedCreateWithoutProductInput = {
    id?: string
    type: string
    message: string
    threshold?: number | null
    currentStock: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAlertCreateOrConnectWithoutProductInput = {
    where: InventoryAlertWhereUniqueInput
    create: XOR<InventoryAlertCreateWithoutProductInput, InventoryAlertUncheckedCreateWithoutProductInput>
  }

  export type InventoryAlertCreateManyProductInputEnvelope = {
    data: InventoryAlertCreateManyProductInput | InventoryAlertCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutProductInput = {
    id?: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    notes?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutProductInput = {
    id?: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    userId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutProductInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput>
  }

  export type InventoryMovementCreateManyProductInputEnvelope = {
    data: InventoryMovementCreateManyProductInput | InventoryMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseEntryCreateWithoutProductInput = {
    id?: string
    kind: string
    title: string
    content: string
    tags?: string | null
    embedding?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseEntryUncheckedCreateWithoutProductInput = {
    id?: string
    kind: string
    title: string
    content: string
    tags?: string | null
    embedding?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseEntryCreateOrConnectWithoutProductInput = {
    where: KnowledgeBaseEntryWhereUniqueInput
    create: XOR<KnowledgeBaseEntryCreateWithoutProductInput, KnowledgeBaseEntryUncheckedCreateWithoutProductInput>
  }

  export type KnowledgeBaseEntryCreateManyProductInputEnvelope = {
    data: KnowledgeBaseEntryCreateManyProductInput | KnowledgeBaseEntryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductReviewCreateWithoutProductInput = {
    id?: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportCreateNestedManyWithoutReviewInput
    votes?: ProductReviewVoteCreateNestedManyWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ProductReviewUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportUncheckedCreateNestedManyWithoutReviewInput
    votes?: ProductReviewVoteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewCreateManyProductInputEnvelope = {
    data: ProductReviewCreateManyProductInput | ProductReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductViewCreateWithoutProductInput = {
    id?: string
    timestamp?: Date | string
    duration?: number | null
    user?: UserCreateNestedOneWithoutProductViewsInput
  }

  export type ProductViewUncheckedCreateWithoutProductInput = {
    id?: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type ProductViewCreateOrConnectWithoutProductInput = {
    where: ProductViewWhereUniqueInput
    create: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput>
  }

  export type ProductViewCreateManyProductInputEnvelope = {
    data: ProductViewCreateManyProductInput | ProductViewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type WishlistItemCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWishlistItemsInput
  }

  export type WishlistItemUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemCreateManyProductInputEnvelope = {
    data: WishlistItemCreateManyProductInput | WishlistItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    price?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type InventoryUpsertWithoutProductInput = {
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutProductInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    reserved?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    reserved?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAlertUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryAlertWhereUniqueInput
    update: XOR<InventoryAlertUpdateWithoutProductInput, InventoryAlertUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryAlertCreateWithoutProductInput, InventoryAlertUncheckedCreateWithoutProductInput>
  }

  export type InventoryAlertUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryAlertWhereUniqueInput
    data: XOR<InventoryAlertUpdateWithoutProductInput, InventoryAlertUncheckedUpdateWithoutProductInput>
  }

  export type InventoryAlertUpdateManyWithWhereWithoutProductInput = {
    where: InventoryAlertScalarWhereInput
    data: XOR<InventoryAlertUpdateManyMutationInput, InventoryAlertUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryAlertScalarWhereInput = {
    AND?: InventoryAlertScalarWhereInput | InventoryAlertScalarWhereInput[]
    OR?: InventoryAlertScalarWhereInput[]
    NOT?: InventoryAlertScalarWhereInput | InventoryAlertScalarWhereInput[]
    id?: StringFilter<"InventoryAlert"> | string
    productId?: StringFilter<"InventoryAlert"> | string
    type?: StringFilter<"InventoryAlert"> | string
    message?: StringFilter<"InventoryAlert"> | string
    threshold?: IntNullableFilter<"InventoryAlert"> | number | null
    currentStock?: IntFilter<"InventoryAlert"> | number
    isResolved?: BoolFilter<"InventoryAlert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"InventoryAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"InventoryAlert"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAlert"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutProductInput, InventoryMovementUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutProductInput, InventoryMovementUncheckedUpdateWithoutProductInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutProductInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type KnowledgeBaseEntryUpsertWithWhereUniqueWithoutProductInput = {
    where: KnowledgeBaseEntryWhereUniqueInput
    update: XOR<KnowledgeBaseEntryUpdateWithoutProductInput, KnowledgeBaseEntryUncheckedUpdateWithoutProductInput>
    create: XOR<KnowledgeBaseEntryCreateWithoutProductInput, KnowledgeBaseEntryUncheckedCreateWithoutProductInput>
  }

  export type KnowledgeBaseEntryUpdateWithWhereUniqueWithoutProductInput = {
    where: KnowledgeBaseEntryWhereUniqueInput
    data: XOR<KnowledgeBaseEntryUpdateWithoutProductInput, KnowledgeBaseEntryUncheckedUpdateWithoutProductInput>
  }

  export type KnowledgeBaseEntryUpdateManyWithWhereWithoutProductInput = {
    where: KnowledgeBaseEntryScalarWhereInput
    data: XOR<KnowledgeBaseEntryUpdateManyMutationInput, KnowledgeBaseEntryUncheckedUpdateManyWithoutProductInput>
  }

  export type KnowledgeBaseEntryScalarWhereInput = {
    AND?: KnowledgeBaseEntryScalarWhereInput | KnowledgeBaseEntryScalarWhereInput[]
    OR?: KnowledgeBaseEntryScalarWhereInput[]
    NOT?: KnowledgeBaseEntryScalarWhereInput | KnowledgeBaseEntryScalarWhereInput[]
    id?: StringFilter<"KnowledgeBaseEntry"> | string
    kind?: StringFilter<"KnowledgeBaseEntry"> | string
    title?: StringFilter<"KnowledgeBaseEntry"> | string
    content?: StringFilter<"KnowledgeBaseEntry"> | string
    productId?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    tags?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    embedding?: StringNullableFilter<"KnowledgeBaseEntry"> | string | null
    isActive?: BoolFilter<"KnowledgeBaseEntry"> | boolean
    createdAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseEntry"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: IntFilter<"OrderItem"> | number
    name?: StringNullableFilter<"OrderItem"> | string | null
    unitPrice?: IntNullableFilter<"OrderItem"> | number | null
    imageUrl?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutProductInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductViewUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductViewWhereUniqueInput
    update: XOR<ProductViewUpdateWithoutProductInput, ProductViewUncheckedUpdateWithoutProductInput>
    create: XOR<ProductViewCreateWithoutProductInput, ProductViewUncheckedCreateWithoutProductInput>
  }

  export type ProductViewUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductViewWhereUniqueInput
    data: XOR<ProductViewUpdateWithoutProductInput, ProductViewUncheckedUpdateWithoutProductInput>
  }

  export type ProductViewUpdateManyWithWhereWithoutProductInput = {
    where: ProductViewScalarWhereInput
    data: XOR<ProductViewUpdateManyMutationInput, ProductViewUncheckedUpdateManyWithoutProductInput>
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutProductInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    parentId?: StringNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    canonicalUrl?: StringNullableFilter<"Category"> | string | null
    description?: StringNullableFilter<"Category"> | string | null
    imageUrl?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    metaKeywords?: StringNullableFilter<"Category"> | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    shortDescription?: StringNullableFilter<"Product"> | string | null
    priceCents?: IntFilter<"Product"> | number
    originalPriceCents?: IntNullableFilter<"Product"> | number | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    brand?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    specifications?: StringNullableFilter<"Product"> | string | null
    features?: StringNullableFilter<"Product"> | string | null
    warranty?: StringNullableFilter<"Product"> | string | null
    weight?: FloatNullableFilter<"Product"> | number | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    stockQuantity?: IntFilter<"Product"> | number
    minOrderQuantity?: IntFilter<"Product"> | number
    maxOrderQuantity?: IntNullableFilter<"Product"> | number | null
    maxStock?: IntNullableFilter<"Product"> | number | null
    tags?: StringNullableFilter<"Product"> | string | null
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDescription?: StringNullableFilter<"Product"> | string | null
    metaKeywords?: StringNullableFilter<"Product"> | string | null
    canonicalUrl?: StringNullableFilter<"Product"> | string | null
    featured?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    isDeleted?: BoolFilter<"Product"> | boolean
    viewCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCartsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type UserUpsertWithoutCartsInput = {
    update: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
  }

  export type UserUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CartCreateWithoutItemsInput = {
    id?: string
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string
    userId?: string | null
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutCartItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
  }

  export type CartUpsertWithoutItemsInput = {
    update: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
  }

  export type CartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemsInput = {
    update: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type PaymentIntentCreateWithoutOrderInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutIntentInput
  }

  export type PaymentIntentUncheckedCreateWithoutOrderInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutIntentInput
  }

  export type PaymentIntentCreateOrConnectWithoutOrderInput = {
    where: PaymentIntentWhereUniqueInput
    create: XOR<PaymentIntentCreateWithoutOrderInput, PaymentIntentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentIntentCreateManyOrderInputEnvelope = {
    data: PaymentIntentCreateManyOrderInput | PaymentIntentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intent?: PaymentIntentCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    intentId?: string | null
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentIntentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentIntentWhereUniqueInput
    update: XOR<PaymentIntentUpdateWithoutOrderInput, PaymentIntentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentIntentCreateWithoutOrderInput, PaymentIntentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentIntentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentIntentWhereUniqueInput
    data: XOR<PaymentIntentUpdateWithoutOrderInput, PaymentIntentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentIntentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentIntentScalarWhereInput
    data: XOR<PaymentIntentUpdateManyMutationInput, PaymentIntentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentIntentScalarWhereInput = {
    AND?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
    OR?: PaymentIntentScalarWhereInput[]
    NOT?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
    id?: StringFilter<"PaymentIntent"> | string
    orderId?: StringFilter<"PaymentIntent"> | string
    provider?: StringFilter<"PaymentIntent"> | string
    amountCents?: IntFilter<"PaymentIntent"> | number
    status?: StringFilter<"PaymentIntent"> | string
    clientSecret?: StringNullableFilter<"PaymentIntent"> | string | null
    returnUrl?: StringNullableFilter<"PaymentIntent"> | string | null
    metadata?: StringNullableFilter<"PaymentIntent"> | string | null
    createdAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentIntent"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    intentId?: StringNullableFilter<"Payment"> | string | null
    provider?: StringFilter<"Payment"> | string
    amountCents?: IntFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    orderNo: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNo: string
    userId: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PaymentIntentCreateWithoutPaymentsInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentIntentsInput
  }

  export type PaymentIntentUncheckedCreateWithoutPaymentsInput = {
    id?: string
    orderId: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentIntentCreateOrConnectWithoutPaymentsInput = {
    where: PaymentIntentWhereUniqueInput
    create: XOR<PaymentIntentCreateWithoutPaymentsInput, PaymentIntentUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    orderNo: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    orderNo: string
    userId: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type RefundCreateWithoutPaymentInput = {
    id?: string
    amountCents: number
    reason?: string | null
    status?: string
    providerRefundId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errorMessage?: string | null
  }

  export type RefundUncheckedCreateWithoutPaymentInput = {
    id?: string
    amountCents: number
    reason?: string | null
    status?: string
    providerRefundId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errorMessage?: string | null
  }

  export type RefundCreateOrConnectWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundCreateManyPaymentInputEnvelope = {
    data: RefundCreateManyPaymentInput | RefundCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentIntentUpsertWithoutPaymentsInput = {
    update: XOR<PaymentIntentUpdateWithoutPaymentsInput, PaymentIntentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentIntentCreateWithoutPaymentsInput, PaymentIntentUncheckedCreateWithoutPaymentsInput>
    where?: PaymentIntentWhereInput
  }

  export type PaymentIntentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PaymentIntentWhereInput
    data: XOR<PaymentIntentUpdateWithoutPaymentsInput, PaymentIntentUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentIntentUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentIntentsNestedInput
  }

  export type PaymentIntentUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RefundUpsertWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    update: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundUpdateWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    data: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundUpdateManyWithWhereWithoutPaymentInput = {
    where: RefundScalarWhereInput
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutPaymentInput>
  }

  export type RefundScalarWhereInput = {
    AND?: RefundScalarWhereInput | RefundScalarWhereInput[]
    OR?: RefundScalarWhereInput[]
    NOT?: RefundScalarWhereInput | RefundScalarWhereInput[]
    id?: StringFilter<"Refund"> | string
    paymentId?: StringFilter<"Refund"> | string
    amountCents?: IntFilter<"Refund"> | number
    reason?: StringNullableFilter<"Refund"> | string | null
    status?: StringFilter<"Refund"> | string
    providerRefundId?: StringNullableFilter<"Refund"> | string | null
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    errorMessage?: StringNullableFilter<"Refund"> | string | null
  }

  export type PaymentCreateWithoutRefundsInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intent?: PaymentIntentCreateNestedOneWithoutPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutRefundsInput = {
    id?: string
    orderId: string
    intentId?: string | null
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutRefundsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
  }

  export type PaymentUpsertWithoutRefundsInput = {
    update: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutRefundsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intent?: PaymentIntentUpdateOneWithoutPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    intentId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateWithoutServiceTypeInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingCreateNestedManyWithoutServiceInput
    items?: ServiceItemCreateNestedManyWithoutServiceInput
    views?: ServiceViewCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceTypeInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutServiceInput
    items?: ServiceItemUncheckedCreateNestedManyWithoutServiceInput
    views?: ServiceViewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceTypeInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceTypeInput, ServiceUncheckedCreateWithoutServiceTypeInput>
  }

  export type ServiceCreateManyServiceTypeInputEnvelope = {
    data: ServiceCreateManyServiceTypeInput | ServiceCreateManyServiceTypeInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutServiceTypeInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutServiceTypeInput, ServiceUncheckedUpdateWithoutServiceTypeInput>
    create: XOR<ServiceCreateWithoutServiceTypeInput, ServiceUncheckedCreateWithoutServiceTypeInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutServiceTypeInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutServiceTypeInput, ServiceUncheckedUpdateWithoutServiceTypeInput>
  }

  export type ServiceUpdateManyWithWhereWithoutServiceTypeInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServiceTypeInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    shortDescription?: StringNullableFilter<"Service"> | string | null
    basePriceCents?: IntFilter<"Service"> | number
    price?: IntFilter<"Service"> | number
    minPrice?: IntNullableFilter<"Service"> | number | null
    maxPrice?: IntNullableFilter<"Service"> | number | null
    priceType?: StringFilter<"Service"> | string
    duration?: IntFilter<"Service"> | number
    typeId?: StringNullableFilter<"Service"> | string | null
    images?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    isFeatured?: BoolFilter<"Service"> | boolean
    seoTitle?: StringNullableFilter<"Service"> | string | null
    seoDescription?: StringNullableFilter<"Service"> | string | null
    type?: StringNullableFilter<"Service"> | string | null
    tags?: StringNullableFilter<"Service"> | string | null
    features?: StringNullableFilter<"Service"> | string | null
    requirements?: StringNullableFilter<"Service"> | string | null
    metadata?: StringNullableFilter<"Service"> | string | null
    viewCount?: IntFilter<"Service"> | number
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type ServiceBookingCreateWithoutServiceInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemCreateNestedManyWithoutBookingInput
    technician?: TechnicianCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingInput
    payments?: ServicePaymentCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemUncheckedCreateNestedManyWithoutBookingInput
    payments?: ServicePaymentUncheckedCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingCreateOrConnectWithoutServiceInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBookingCreateManyServiceInputEnvelope = {
    data: ServiceBookingCreateManyServiceInput | ServiceBookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceItemCreateWithoutServiceInput = {
    id?: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
    bookingItems?: ServiceBookingItemCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
    bookingItems?: ServiceBookingItemUncheckedCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemCreateOrConnectWithoutServiceInput = {
    where: ServiceItemWhereUniqueInput
    create: XOR<ServiceItemCreateWithoutServiceInput, ServiceItemUncheckedCreateWithoutServiceInput>
  }

  export type ServiceItemCreateManyServiceInputEnvelope = {
    data: ServiceItemCreateManyServiceInput | ServiceItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceViewCreateWithoutServiceInput = {
    id?: string
    timestamp?: Date | string
    duration?: number | null
    user?: UserCreateNestedOneWithoutServiceViewsInput
  }

  export type ServiceViewUncheckedCreateWithoutServiceInput = {
    id?: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type ServiceViewCreateOrConnectWithoutServiceInput = {
    where: ServiceViewWhereUniqueInput
    create: XOR<ServiceViewCreateWithoutServiceInput, ServiceViewUncheckedCreateWithoutServiceInput>
  }

  export type ServiceViewCreateManyServiceInputEnvelope = {
    data: ServiceViewCreateManyServiceInput | ServiceViewCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTypeCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTypeUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTypeCreateOrConnectWithoutServicesInput = {
    where: ServiceTypeWhereUniqueInput
    create: XOR<ServiceTypeCreateWithoutServicesInput, ServiceTypeUncheckedCreateWithoutServicesInput>
  }

  export type ServiceBookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceBookingWhereUniqueInput
    update: XOR<ServiceBookingUpdateWithoutServiceInput, ServiceBookingUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceBookingCreateWithoutServiceInput, ServiceBookingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceBookingWhereUniqueInput
    data: XOR<ServiceBookingUpdateWithoutServiceInput, ServiceBookingUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceBookingUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceBookingScalarWhereInput
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceItemWhereUniqueInput
    update: XOR<ServiceItemUpdateWithoutServiceInput, ServiceItemUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceItemCreateWithoutServiceInput, ServiceItemUncheckedCreateWithoutServiceInput>
  }

  export type ServiceItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceItemWhereUniqueInput
    data: XOR<ServiceItemUpdateWithoutServiceInput, ServiceItemUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceItemUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceItemScalarWhereInput
    data: XOR<ServiceItemUpdateManyMutationInput, ServiceItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceItemScalarWhereInput = {
    AND?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
    OR?: ServiceItemScalarWhereInput[]
    NOT?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
    id?: StringFilter<"ServiceItem"> | string
    serviceId?: StringFilter<"ServiceItem"> | string
    name?: StringFilter<"ServiceItem"> | string
    price?: IntFilter<"ServiceItem"> | number
    quantity?: IntFilter<"ServiceItem"> | number
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
  }

  export type ServiceViewUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceViewWhereUniqueInput
    update: XOR<ServiceViewUpdateWithoutServiceInput, ServiceViewUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceViewCreateWithoutServiceInput, ServiceViewUncheckedCreateWithoutServiceInput>
  }

  export type ServiceViewUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceViewWhereUniqueInput
    data: XOR<ServiceViewUpdateWithoutServiceInput, ServiceViewUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceViewUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceViewScalarWhereInput
    data: XOR<ServiceViewUpdateManyMutationInput, ServiceViewUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceTypeUpsertWithoutServicesInput = {
    update: XOR<ServiceTypeUpdateWithoutServicesInput, ServiceTypeUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceTypeCreateWithoutServicesInput, ServiceTypeUncheckedCreateWithoutServicesInput>
    where?: ServiceTypeWhereInput
  }

  export type ServiceTypeUpdateToOneWithWhereWithoutServicesInput = {
    where?: ServiceTypeWhereInput
    data: XOR<ServiceTypeUpdateWithoutServicesInput, ServiceTypeUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceTypeUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTypeUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutInventoryInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
  }

  export type ProductUpsertWithoutInventoryInput = {
    update: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutInventoryMovementInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryMovementInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryMovementInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryMovementInput, ProductUncheckedCreateWithoutInventoryMovementInput>
  }

  export type UserCreateWithoutInventoryMovementsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type ProductUpsertWithoutInventoryMovementInput = {
    update: XOR<ProductUpdateWithoutInventoryMovementInput, ProductUncheckedUpdateWithoutInventoryMovementInput>
    create: XOR<ProductCreateWithoutInventoryMovementInput, ProductUncheckedCreateWithoutInventoryMovementInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryMovementInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryMovementInput, ProductUncheckedUpdateWithoutInventoryMovementInput>
  }

  export type ProductUpdateWithoutInventoryMovementInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryMovementInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutInventoryMovementsInput = {
    update: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type UserUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutInventoryAlertInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryAlertInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryAlertInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryAlertInput, ProductUncheckedCreateWithoutInventoryAlertInput>
  }

  export type ProductUpsertWithoutInventoryAlertInput = {
    update: XOR<ProductUpdateWithoutInventoryAlertInput, ProductUncheckedUpdateWithoutInventoryAlertInput>
    create: XOR<ProductCreateWithoutInventoryAlertInput, ProductUncheckedCreateWithoutInventoryAlertInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryAlertInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryAlertInput, ProductUncheckedUpdateWithoutInventoryAlertInput>
  }

  export type ProductUpdateWithoutInventoryAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutWishlistItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutWishlistItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWishlistItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
  }

  export type UserCreateWithoutWishlistItemsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishlistItemsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishlistItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
  }

  export type ProductUpsertWithoutWishlistItemsInput = {
    update: XOR<ProductUpdateWithoutWishlistItemsInput, ProductUncheckedUpdateWithoutWishlistItemsInput>
    create: XOR<ProductCreateWithoutWishlistItemsInput, ProductUncheckedCreateWithoutWishlistItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWishlistItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWishlistItemsInput, ProductUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type ProductUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutWishlistItemsInput = {
    update: XOR<UserUpdateWithoutWishlistItemsInput, UserUncheckedUpdateWithoutWishlistItemsInput>
    create: XOR<UserCreateWithoutWishlistItemsInput, UserUncheckedCreateWithoutWishlistItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishlistItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishlistItemsInput, UserUncheckedUpdateWithoutWishlistItemsInput>
  }

  export type UserUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductReviewReportCreateWithoutReviewInput = {
    id?: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ProductReviewReportUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ProductReviewReportCreateOrConnectWithoutReviewInput = {
    where: ProductReviewReportWhereUniqueInput
    create: XOR<ProductReviewReportCreateWithoutReviewInput, ProductReviewReportUncheckedCreateWithoutReviewInput>
  }

  export type ProductReviewReportCreateManyReviewInputEnvelope = {
    data: ProductReviewReportCreateManyReviewInput | ProductReviewReportCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ProductReviewVoteCreateWithoutReviewInput = {
    id?: string
    userId: string
    isUpvote?: boolean
    createdAt?: Date | string
  }

  export type ProductReviewVoteUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    isUpvote?: boolean
    createdAt?: Date | string
  }

  export type ProductReviewVoteCreateOrConnectWithoutReviewInput = {
    where: ProductReviewVoteWhereUniqueInput
    create: XOR<ProductReviewVoteCreateWithoutReviewInput, ProductReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ProductReviewVoteCreateManyReviewInputEnvelope = {
    data: ProductReviewVoteCreateManyReviewInput | ProductReviewVoteCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProductReviewReportUpsertWithWhereUniqueWithoutReviewInput = {
    where: ProductReviewReportWhereUniqueInput
    update: XOR<ProductReviewReportUpdateWithoutReviewInput, ProductReviewReportUncheckedUpdateWithoutReviewInput>
    create: XOR<ProductReviewReportCreateWithoutReviewInput, ProductReviewReportUncheckedCreateWithoutReviewInput>
  }

  export type ProductReviewReportUpdateWithWhereUniqueWithoutReviewInput = {
    where: ProductReviewReportWhereUniqueInput
    data: XOR<ProductReviewReportUpdateWithoutReviewInput, ProductReviewReportUncheckedUpdateWithoutReviewInput>
  }

  export type ProductReviewReportUpdateManyWithWhereWithoutReviewInput = {
    where: ProductReviewReportScalarWhereInput
    data: XOR<ProductReviewReportUpdateManyMutationInput, ProductReviewReportUncheckedUpdateManyWithoutReviewInput>
  }

  export type ProductReviewReportScalarWhereInput = {
    AND?: ProductReviewReportScalarWhereInput | ProductReviewReportScalarWhereInput[]
    OR?: ProductReviewReportScalarWhereInput[]
    NOT?: ProductReviewReportScalarWhereInput | ProductReviewReportScalarWhereInput[]
    id?: StringFilter<"ProductReviewReport"> | string
    reviewId?: StringFilter<"ProductReviewReport"> | string
    userId?: StringFilter<"ProductReviewReport"> | string
    reason?: StringFilter<"ProductReviewReport"> | string
    createdAt?: DateTimeFilter<"ProductReviewReport"> | Date | string
  }

  export type ProductReviewVoteUpsertWithWhereUniqueWithoutReviewInput = {
    where: ProductReviewVoteWhereUniqueInput
    update: XOR<ProductReviewVoteUpdateWithoutReviewInput, ProductReviewVoteUncheckedUpdateWithoutReviewInput>
    create: XOR<ProductReviewVoteCreateWithoutReviewInput, ProductReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ProductReviewVoteUpdateWithWhereUniqueWithoutReviewInput = {
    where: ProductReviewVoteWhereUniqueInput
    data: XOR<ProductReviewVoteUpdateWithoutReviewInput, ProductReviewVoteUncheckedUpdateWithoutReviewInput>
  }

  export type ProductReviewVoteUpdateManyWithWhereWithoutReviewInput = {
    where: ProductReviewVoteScalarWhereInput
    data: XOR<ProductReviewVoteUpdateManyMutationInput, ProductReviewVoteUncheckedUpdateManyWithoutReviewInput>
  }

  export type ProductReviewVoteScalarWhereInput = {
    AND?: ProductReviewVoteScalarWhereInput | ProductReviewVoteScalarWhereInput[]
    OR?: ProductReviewVoteScalarWhereInput[]
    NOT?: ProductReviewVoteScalarWhereInput | ProductReviewVoteScalarWhereInput[]
    id?: StringFilter<"ProductReviewVote"> | string
    reviewId?: StringFilter<"ProductReviewVote"> | string
    userId?: StringFilter<"ProductReviewVote"> | string
    isUpvote?: BoolFilter<"ProductReviewVote"> | boolean
    createdAt?: DateTimeFilter<"ProductReviewVote"> | Date | string
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductReviewCreateWithoutVotesInput = {
    id?: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportCreateNestedManyWithoutReviewInput
    product: ProductCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ProductReviewUncheckedCreateWithoutVotesInput = {
    id?: string
    userId: string
    productId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ProductReviewReportUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutVotesInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
  }

  export type ProductReviewUpsertWithoutVotesInput = {
    update: XOR<ProductReviewUpdateWithoutVotesInput, ProductReviewUncheckedUpdateWithoutVotesInput>
    create: XOR<ProductReviewCreateWithoutVotesInput, ProductReviewUncheckedCreateWithoutVotesInput>
    where?: ProductReviewWhereInput
  }

  export type ProductReviewUpdateToOneWithWhereWithoutVotesInput = {
    where?: ProductReviewWhereInput
    data: XOR<ProductReviewUpdateWithoutVotesInput, ProductReviewUncheckedUpdateWithoutVotesInput>
  }

  export type ProductReviewUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUpdateManyWithoutReviewNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewCreateWithoutReportsInput = {
    id?: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ProductReviewVoteCreateNestedManyWithoutReviewInput
    product: ProductCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ProductReviewUncheckedCreateWithoutReportsInput = {
    id?: string
    userId: string
    productId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ProductReviewVoteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ProductReviewCreateOrConnectWithoutReportsInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
  }

  export type ProductReviewUpsertWithoutReportsInput = {
    update: XOR<ProductReviewUpdateWithoutReportsInput, ProductReviewUncheckedUpdateWithoutReportsInput>
    create: XOR<ProductReviewCreateWithoutReportsInput, ProductReviewUncheckedCreateWithoutReportsInput>
    where?: ProductReviewWhereInput
  }

  export type ProductReviewUpdateToOneWithWhereWithoutReportsInput = {
    where?: ProductReviewWhereInput
    data: XOR<ProductReviewUpdateWithoutReportsInput, ProductReviewUncheckedUpdateWithoutReportsInput>
  }

  export type ProductReviewUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ProductReviewVoteUpdateManyWithoutReviewNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ProductReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserCreateWithoutSearchQueriesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSearchQueriesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSearchQueriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchQueriesInput, UserUncheckedCreateWithoutSearchQueriesInput>
  }

  export type UserUpsertWithoutSearchQueriesInput = {
    update: XOR<UserUpdateWithoutSearchQueriesInput, UserUncheckedUpdateWithoutSearchQueriesInput>
    create: XOR<UserCreateWithoutSearchQueriesInput, UserUncheckedCreateWithoutSearchQueriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchQueriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchQueriesInput, UserUncheckedUpdateWithoutSearchQueriesInput>
  }

  export type UserUpdateWithoutSearchQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutViewsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutViewsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutViewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
  }

  export type UserCreateWithoutProductViewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductViewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
  }

  export type ProductUpsertWithoutViewsInput = {
    update: XOR<ProductUpdateWithoutViewsInput, ProductUncheckedUpdateWithoutViewsInput>
    create: XOR<ProductCreateWithoutViewsInput, ProductUncheckedCreateWithoutViewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutViewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutViewsInput, ProductUncheckedUpdateWithoutViewsInput>
  }

  export type ProductUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutProductViewsInput = {
    update: XOR<UserUpdateWithoutProductViewsInput, UserUncheckedUpdateWithoutProductViewsInput>
    create: XOR<UserCreateWithoutProductViewsInput, UserUncheckedCreateWithoutProductViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductViewsInput, UserUncheckedUpdateWithoutProductViewsInput>
  }

  export type UserUpdateWithoutProductViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceCreateWithoutViewsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingCreateNestedManyWithoutServiceInput
    items?: ServiceItemCreateNestedManyWithoutServiceInput
    serviceType?: ServiceTypeCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutViewsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    typeId?: string | null
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutServiceInput
    items?: ServiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutViewsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutViewsInput, ServiceUncheckedCreateWithoutViewsInput>
  }

  export type UserCreateWithoutServiceViewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceViewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceViewsInput, UserUncheckedCreateWithoutServiceViewsInput>
  }

  export type ServiceUpsertWithoutViewsInput = {
    update: XOR<ServiceUpdateWithoutViewsInput, ServiceUncheckedUpdateWithoutViewsInput>
    create: XOR<ServiceCreateWithoutViewsInput, ServiceUncheckedCreateWithoutViewsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutViewsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutViewsInput, ServiceUncheckedUpdateWithoutViewsInput>
  }

  export type ServiceUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUpdateManyWithoutServiceNestedInput
    items?: ServiceItemUpdateManyWithoutServiceNestedInput
    serviceType?: ServiceTypeUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput
    items?: ServiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutServiceViewsInput = {
    update: XOR<UserUpdateWithoutServiceViewsInput, UserUncheckedUpdateWithoutServiceViewsInput>
    create: XOR<UserCreateWithoutServiceViewsInput, UserUncheckedCreateWithoutServiceViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceViewsInput, UserUncheckedUpdateWithoutServiceViewsInput>
  }

  export type UserUpdateWithoutServiceViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutQuestionsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
  }

  export type UserUpsertWithoutQuestionsInput = {
    update: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
    create: XOR<UserCreateWithoutQuestionsInput, UserUncheckedCreateWithoutQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestionsInput, UserUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceBookingCreateWithoutTechnicianInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemCreateNestedManyWithoutBookingInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingInput
    payments?: ServicePaymentCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUncheckedCreateWithoutTechnicianInput = {
    id?: string
    userId: string
    serviceId: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemUncheckedCreateNestedManyWithoutBookingInput
    payments?: ServicePaymentUncheckedCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingCreateOrConnectWithoutTechnicianInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutTechnicianInput, ServiceBookingUncheckedCreateWithoutTechnicianInput>
  }

  export type ServiceBookingCreateManyTechnicianInputEnvelope = {
    data: ServiceBookingCreateManyTechnicianInput | ServiceBookingCreateManyTechnicianInput[]
    skipDuplicates?: boolean
  }

  export type TechnicianScheduleCreateWithoutTechnicianInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type TechnicianScheduleUncheckedCreateWithoutTechnicianInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type TechnicianScheduleCreateOrConnectWithoutTechnicianInput = {
    where: TechnicianScheduleWhereUniqueInput
    create: XOR<TechnicianScheduleCreateWithoutTechnicianInput, TechnicianScheduleUncheckedCreateWithoutTechnicianInput>
  }

  export type TechnicianScheduleCreateManyTechnicianInputEnvelope = {
    data: TechnicianScheduleCreateManyTechnicianInput | TechnicianScheduleCreateManyTechnicianInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBookingUpsertWithWhereUniqueWithoutTechnicianInput = {
    where: ServiceBookingWhereUniqueInput
    update: XOR<ServiceBookingUpdateWithoutTechnicianInput, ServiceBookingUncheckedUpdateWithoutTechnicianInput>
    create: XOR<ServiceBookingCreateWithoutTechnicianInput, ServiceBookingUncheckedCreateWithoutTechnicianInput>
  }

  export type ServiceBookingUpdateWithWhereUniqueWithoutTechnicianInput = {
    where: ServiceBookingWhereUniqueInput
    data: XOR<ServiceBookingUpdateWithoutTechnicianInput, ServiceBookingUncheckedUpdateWithoutTechnicianInput>
  }

  export type ServiceBookingUpdateManyWithWhereWithoutTechnicianInput = {
    where: ServiceBookingScalarWhereInput
    data: XOR<ServiceBookingUpdateManyMutationInput, ServiceBookingUncheckedUpdateManyWithoutTechnicianInput>
  }

  export type TechnicianScheduleUpsertWithWhereUniqueWithoutTechnicianInput = {
    where: TechnicianScheduleWhereUniqueInput
    update: XOR<TechnicianScheduleUpdateWithoutTechnicianInput, TechnicianScheduleUncheckedUpdateWithoutTechnicianInput>
    create: XOR<TechnicianScheduleCreateWithoutTechnicianInput, TechnicianScheduleUncheckedCreateWithoutTechnicianInput>
  }

  export type TechnicianScheduleUpdateWithWhereUniqueWithoutTechnicianInput = {
    where: TechnicianScheduleWhereUniqueInput
    data: XOR<TechnicianScheduleUpdateWithoutTechnicianInput, TechnicianScheduleUncheckedUpdateWithoutTechnicianInput>
  }

  export type TechnicianScheduleUpdateManyWithWhereWithoutTechnicianInput = {
    where: TechnicianScheduleScalarWhereInput
    data: XOR<TechnicianScheduleUpdateManyMutationInput, TechnicianScheduleUncheckedUpdateManyWithoutTechnicianInput>
  }

  export type TechnicianScheduleScalarWhereInput = {
    AND?: TechnicianScheduleScalarWhereInput | TechnicianScheduleScalarWhereInput[]
    OR?: TechnicianScheduleScalarWhereInput[]
    NOT?: TechnicianScheduleScalarWhereInput | TechnicianScheduleScalarWhereInput[]
    id?: StringFilter<"TechnicianSchedule"> | string
    technicianId?: StringFilter<"TechnicianSchedule"> | string
    date?: DateTimeFilter<"TechnicianSchedule"> | Date | string
    startTime?: StringFilter<"TechnicianSchedule"> | string
    endTime?: StringFilter<"TechnicianSchedule"> | string
    isAvailable?: BoolFilter<"TechnicianSchedule"> | boolean
    createdAt?: DateTimeFilter<"TechnicianSchedule"> | Date | string
  }

  export type ServiceBookingItemCreateWithoutServiceItemInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    booking: ServiceBookingCreateNestedOneWithoutItemsInput
  }

  export type ServiceBookingItemUncheckedCreateWithoutServiceItemInput = {
    id?: string
    bookingId: string
    quantity: number
    price: number
    createdAt?: Date | string
  }

  export type ServiceBookingItemCreateOrConnectWithoutServiceItemInput = {
    where: ServiceBookingItemWhereUniqueInput
    create: XOR<ServiceBookingItemCreateWithoutServiceItemInput, ServiceBookingItemUncheckedCreateWithoutServiceItemInput>
  }

  export type ServiceBookingItemCreateManyServiceItemInputEnvelope = {
    data: ServiceBookingItemCreateManyServiceItemInput | ServiceBookingItemCreateManyServiceItemInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingCreateNestedManyWithoutServiceInput
    views?: ServiceViewCreateNestedManyWithoutServiceInput
    serviceType?: ServiceTypeCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutItemsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    typeId?: string | null
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutServiceInput
    views?: ServiceViewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutItemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutItemsInput, ServiceUncheckedCreateWithoutItemsInput>
  }

  export type ServiceBookingItemUpsertWithWhereUniqueWithoutServiceItemInput = {
    where: ServiceBookingItemWhereUniqueInput
    update: XOR<ServiceBookingItemUpdateWithoutServiceItemInput, ServiceBookingItemUncheckedUpdateWithoutServiceItemInput>
    create: XOR<ServiceBookingItemCreateWithoutServiceItemInput, ServiceBookingItemUncheckedCreateWithoutServiceItemInput>
  }

  export type ServiceBookingItemUpdateWithWhereUniqueWithoutServiceItemInput = {
    where: ServiceBookingItemWhereUniqueInput
    data: XOR<ServiceBookingItemUpdateWithoutServiceItemInput, ServiceBookingItemUncheckedUpdateWithoutServiceItemInput>
  }

  export type ServiceBookingItemUpdateManyWithWhereWithoutServiceItemInput = {
    where: ServiceBookingItemScalarWhereInput
    data: XOR<ServiceBookingItemUpdateManyMutationInput, ServiceBookingItemUncheckedUpdateManyWithoutServiceItemInput>
  }

  export type ServiceBookingItemScalarWhereInput = {
    AND?: ServiceBookingItemScalarWhereInput | ServiceBookingItemScalarWhereInput[]
    OR?: ServiceBookingItemScalarWhereInput[]
    NOT?: ServiceBookingItemScalarWhereInput | ServiceBookingItemScalarWhereInput[]
    id?: StringFilter<"ServiceBookingItem"> | string
    bookingId?: StringFilter<"ServiceBookingItem"> | string
    serviceItemId?: StringFilter<"ServiceBookingItem"> | string
    quantity?: IntFilter<"ServiceBookingItem"> | number
    price?: IntFilter<"ServiceBookingItem"> | number
    createdAt?: DateTimeFilter<"ServiceBookingItem"> | Date | string
  }

  export type ServiceUpsertWithoutItemsInput = {
    update: XOR<ServiceUpdateWithoutItemsInput, ServiceUncheckedUpdateWithoutItemsInput>
    create: XOR<ServiceCreateWithoutItemsInput, ServiceUncheckedCreateWithoutItemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutItemsInput, ServiceUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUpdateManyWithoutServiceNestedInput
    serviceType?: ServiceTypeUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceBookingItemCreateWithoutBookingInput = {
    id?: string
    quantity: number
    price: number
    createdAt?: Date | string
    serviceItem: ServiceItemCreateNestedOneWithoutBookingItemsInput
  }

  export type ServiceBookingItemUncheckedCreateWithoutBookingInput = {
    id?: string
    serviceItemId: string
    quantity: number
    price: number
    createdAt?: Date | string
  }

  export type ServiceBookingItemCreateOrConnectWithoutBookingInput = {
    where: ServiceBookingItemWhereUniqueInput
    create: XOR<ServiceBookingItemCreateWithoutBookingInput, ServiceBookingItemUncheckedCreateWithoutBookingInput>
  }

  export type ServiceBookingItemCreateManyBookingInputEnvelope = {
    data: ServiceBookingItemCreateManyBookingInput | ServiceBookingItemCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutBookingsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceItemCreateNestedManyWithoutServiceInput
    views?: ServiceViewCreateNestedManyWithoutServiceInput
    serviceType?: ServiceTypeCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    typeId?: string | null
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceItemUncheckedCreateNestedManyWithoutServiceInput
    views?: ServiceViewUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type TechnicianCreateWithoutBookingsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    specialties?: string | null
    isActive?: boolean
    createdAt?: Date | string
    schedules?: TechnicianScheduleCreateNestedManyWithoutTechnicianInput
  }

  export type TechnicianUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    specialties?: string | null
    isActive?: boolean
    createdAt?: Date | string
    schedules?: TechnicianScheduleUncheckedCreateNestedManyWithoutTechnicianInput
  }

  export type TechnicianCreateOrConnectWithoutBookingsInput = {
    where: TechnicianWhereUniqueInput
    create: XOR<TechnicianCreateWithoutBookingsInput, TechnicianUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutServiceBookingInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServiceBookingInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServiceBookingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceBookingInput, UserUncheckedCreateWithoutServiceBookingInput>
  }

  export type ServicePaymentCreateWithoutBookingInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServicePaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServicePaymentCreateOrConnectWithoutBookingInput = {
    where: ServicePaymentWhereUniqueInput
    create: XOR<ServicePaymentCreateWithoutBookingInput, ServicePaymentUncheckedCreateWithoutBookingInput>
  }

  export type ServicePaymentCreateManyBookingInputEnvelope = {
    data: ServicePaymentCreateManyBookingInput | ServicePaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ServiceStatusHistoryCreateWithoutBookingInput = {
    id?: string
    status: string
    newStatus: string
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceStatusHistoryUncheckedCreateWithoutBookingInput = {
    id?: string
    status: string
    newStatus: string
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceStatusHistoryCreateOrConnectWithoutBookingInput = {
    where: ServiceStatusHistoryWhereUniqueInput
    create: XOR<ServiceStatusHistoryCreateWithoutBookingInput, ServiceStatusHistoryUncheckedCreateWithoutBookingInput>
  }

  export type ServiceStatusHistoryCreateManyBookingInputEnvelope = {
    data: ServiceStatusHistoryCreateManyBookingInput | ServiceStatusHistoryCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBookingItemUpsertWithWhereUniqueWithoutBookingInput = {
    where: ServiceBookingItemWhereUniqueInput
    update: XOR<ServiceBookingItemUpdateWithoutBookingInput, ServiceBookingItemUncheckedUpdateWithoutBookingInput>
    create: XOR<ServiceBookingItemCreateWithoutBookingInput, ServiceBookingItemUncheckedCreateWithoutBookingInput>
  }

  export type ServiceBookingItemUpdateWithWhereUniqueWithoutBookingInput = {
    where: ServiceBookingItemWhereUniqueInput
    data: XOR<ServiceBookingItemUpdateWithoutBookingInput, ServiceBookingItemUncheckedUpdateWithoutBookingInput>
  }

  export type ServiceBookingItemUpdateManyWithWhereWithoutBookingInput = {
    where: ServiceBookingItemScalarWhereInput
    data: XOR<ServiceBookingItemUpdateManyMutationInput, ServiceBookingItemUncheckedUpdateManyWithoutBookingInput>
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceItemUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUpdateManyWithoutServiceNestedInput
    serviceType?: ServiceTypeUpdateOneWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceItemUncheckedUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type TechnicianUpsertWithoutBookingsInput = {
    update: XOR<TechnicianUpdateWithoutBookingsInput, TechnicianUncheckedUpdateWithoutBookingsInput>
    create: XOR<TechnicianCreateWithoutBookingsInput, TechnicianUncheckedCreateWithoutBookingsInput>
    where?: TechnicianWhereInput
  }

  export type TechnicianUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TechnicianWhereInput
    data: XOR<TechnicianUpdateWithoutBookingsInput, TechnicianUncheckedUpdateWithoutBookingsInput>
  }

  export type TechnicianUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: TechnicianScheduleUpdateManyWithoutTechnicianNestedInput
  }

  export type TechnicianUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: TechnicianScheduleUncheckedUpdateManyWithoutTechnicianNestedInput
  }

  export type UserUpsertWithoutServiceBookingInput = {
    update: XOR<UserUpdateWithoutServiceBookingInput, UserUncheckedUpdateWithoutServiceBookingInput>
    create: XOR<UserCreateWithoutServiceBookingInput, UserUncheckedCreateWithoutServiceBookingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceBookingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceBookingInput, UserUncheckedUpdateWithoutServiceBookingInput>
  }

  export type UserUpdateWithoutServiceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServicePaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: ServicePaymentWhereUniqueInput
    update: XOR<ServicePaymentUpdateWithoutBookingInput, ServicePaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<ServicePaymentCreateWithoutBookingInput, ServicePaymentUncheckedCreateWithoutBookingInput>
  }

  export type ServicePaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: ServicePaymentWhereUniqueInput
    data: XOR<ServicePaymentUpdateWithoutBookingInput, ServicePaymentUncheckedUpdateWithoutBookingInput>
  }

  export type ServicePaymentUpdateManyWithWhereWithoutBookingInput = {
    where: ServicePaymentScalarWhereInput
    data: XOR<ServicePaymentUpdateManyMutationInput, ServicePaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type ServicePaymentScalarWhereInput = {
    AND?: ServicePaymentScalarWhereInput | ServicePaymentScalarWhereInput[]
    OR?: ServicePaymentScalarWhereInput[]
    NOT?: ServicePaymentScalarWhereInput | ServicePaymentScalarWhereInput[]
    id?: StringFilter<"ServicePayment"> | string
    bookingId?: StringFilter<"ServicePayment"> | string
    provider?: StringFilter<"ServicePayment"> | string
    amountCents?: IntFilter<"ServicePayment"> | number
    status?: StringFilter<"ServicePayment"> | string
    transactionId?: StringNullableFilter<"ServicePayment"> | string | null
    paidAt?: DateTimeNullableFilter<"ServicePayment"> | Date | string | null
    createdAt?: DateTimeFilter<"ServicePayment"> | Date | string
  }

  export type ServiceStatusHistoryUpsertWithWhereUniqueWithoutBookingInput = {
    where: ServiceStatusHistoryWhereUniqueInput
    update: XOR<ServiceStatusHistoryUpdateWithoutBookingInput, ServiceStatusHistoryUncheckedUpdateWithoutBookingInput>
    create: XOR<ServiceStatusHistoryCreateWithoutBookingInput, ServiceStatusHistoryUncheckedCreateWithoutBookingInput>
  }

  export type ServiceStatusHistoryUpdateWithWhereUniqueWithoutBookingInput = {
    where: ServiceStatusHistoryWhereUniqueInput
    data: XOR<ServiceStatusHistoryUpdateWithoutBookingInput, ServiceStatusHistoryUncheckedUpdateWithoutBookingInput>
  }

  export type ServiceStatusHistoryUpdateManyWithWhereWithoutBookingInput = {
    where: ServiceStatusHistoryScalarWhereInput
    data: XOR<ServiceStatusHistoryUpdateManyMutationInput, ServiceStatusHistoryUncheckedUpdateManyWithoutBookingInput>
  }

  export type ServiceStatusHistoryScalarWhereInput = {
    AND?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[]
    OR?: ServiceStatusHistoryScalarWhereInput[]
    NOT?: ServiceStatusHistoryScalarWhereInput | ServiceStatusHistoryScalarWhereInput[]
    id?: StringFilter<"ServiceStatusHistory"> | string
    bookingId?: StringFilter<"ServiceStatusHistory"> | string
    status?: StringFilter<"ServiceStatusHistory"> | string
    newStatus?: StringFilter<"ServiceStatusHistory"> | string
    note?: StringNullableFilter<"ServiceStatusHistory"> | string | null
    changedBy?: StringNullableFilter<"ServiceStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"ServiceStatusHistory"> | Date | string
  }

  export type ServiceBookingCreateWithoutItemsInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutBookingsInput
    technician?: TechnicianCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingInput
    payments?: ServicePaymentCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    serviceId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: ServicePaymentUncheckedCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingCreateOrConnectWithoutItemsInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutItemsInput, ServiceBookingUncheckedCreateWithoutItemsInput>
  }

  export type ServiceItemCreateWithoutBookingItemsInput = {
    id?: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutItemsInput
  }

  export type ServiceItemUncheckedCreateWithoutBookingItemsInput = {
    id?: string
    serviceId: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
  }

  export type ServiceItemCreateOrConnectWithoutBookingItemsInput = {
    where: ServiceItemWhereUniqueInput
    create: XOR<ServiceItemCreateWithoutBookingItemsInput, ServiceItemUncheckedCreateWithoutBookingItemsInput>
  }

  export type ServiceBookingUpsertWithoutItemsInput = {
    update: XOR<ServiceBookingUpdateWithoutItemsInput, ServiceBookingUncheckedUpdateWithoutItemsInput>
    create: XOR<ServiceBookingCreateWithoutItemsInput, ServiceBookingUncheckedCreateWithoutItemsInput>
    where?: ServiceBookingWhereInput
  }

  export type ServiceBookingUpdateToOneWithWhereWithoutItemsInput = {
    where?: ServiceBookingWhereInput
    data: XOR<ServiceBookingUpdateWithoutItemsInput, ServiceBookingUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceBookingUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    technician?: TechnicianUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingNestedInput
    payments?: ServicePaymentUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: ServicePaymentUncheckedUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceItemUpsertWithoutBookingItemsInput = {
    update: XOR<ServiceItemUpdateWithoutBookingItemsInput, ServiceItemUncheckedUpdateWithoutBookingItemsInput>
    create: XOR<ServiceItemCreateWithoutBookingItemsInput, ServiceItemUncheckedCreateWithoutBookingItemsInput>
    where?: ServiceItemWhereInput
  }

  export type ServiceItemUpdateToOneWithWhereWithoutBookingItemsInput = {
    where?: ServiceItemWhereInput
    data: XOR<ServiceItemUpdateWithoutBookingItemsInput, ServiceItemUncheckedUpdateWithoutBookingItemsInput>
  }

  export type ServiceItemUpdateWithoutBookingItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ServiceItemUncheckedUpdateWithoutBookingItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianCreateWithoutSchedulesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    specialties?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bookings?: ServiceBookingCreateNestedManyWithoutTechnicianInput
  }

  export type TechnicianUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    specialties?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bookings?: ServiceBookingUncheckedCreateNestedManyWithoutTechnicianInput
  }

  export type TechnicianCreateOrConnectWithoutSchedulesInput = {
    where: TechnicianWhereUniqueInput
    create: XOR<TechnicianCreateWithoutSchedulesInput, TechnicianUncheckedCreateWithoutSchedulesInput>
  }

  export type TechnicianUpsertWithoutSchedulesInput = {
    update: XOR<TechnicianUpdateWithoutSchedulesInput, TechnicianUncheckedUpdateWithoutSchedulesInput>
    create: XOR<TechnicianCreateWithoutSchedulesInput, TechnicianUncheckedCreateWithoutSchedulesInput>
    where?: TechnicianWhereInput
  }

  export type TechnicianUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: TechnicianWhereInput
    data: XOR<TechnicianUpdateWithoutSchedulesInput, TechnicianUncheckedUpdateWithoutSchedulesInput>
  }

  export type TechnicianUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUpdateManyWithoutTechnicianNestedInput
  }

  export type TechnicianUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutTechnicianNestedInput
  }

  export type ServiceBookingCreateWithoutHistoryInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemCreateNestedManyWithoutBookingInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    technician?: TechnicianCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingInput
    payments?: ServicePaymentCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUncheckedCreateWithoutHistoryInput = {
    id?: string
    userId: string
    serviceId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemUncheckedCreateNestedManyWithoutBookingInput
    payments?: ServicePaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingCreateOrConnectWithoutHistoryInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutHistoryInput, ServiceBookingUncheckedCreateWithoutHistoryInput>
  }

  export type ServiceBookingUpsertWithoutHistoryInput = {
    update: XOR<ServiceBookingUpdateWithoutHistoryInput, ServiceBookingUncheckedUpdateWithoutHistoryInput>
    create: XOR<ServiceBookingCreateWithoutHistoryInput, ServiceBookingUncheckedCreateWithoutHistoryInput>
    where?: ServiceBookingWhereInput
  }

  export type ServiceBookingUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ServiceBookingWhereInput
    data: XOR<ServiceBookingUpdateWithoutHistoryInput, ServiceBookingUncheckedUpdateWithoutHistoryInput>
  }

  export type ServiceBookingUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUpdateManyWithoutBookingNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    technician?: TechnicianUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingNestedInput
    payments?: ServicePaymentUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUncheckedUpdateManyWithoutBookingNestedInput
    payments?: ServicePaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingCreateWithoutPaymentsInput = {
    id?: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemCreateNestedManyWithoutBookingInput
    service: ServiceCreateNestedOneWithoutBookingsInput
    technician?: TechnicianCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutServiceBookingInput
    history?: ServiceStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    serviceId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ServiceBookingItemUncheckedCreateNestedManyWithoutBookingInput
    history?: ServiceStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ServiceBookingCreateOrConnectWithoutPaymentsInput = {
    where: ServiceBookingWhereUniqueInput
    create: XOR<ServiceBookingCreateWithoutPaymentsInput, ServiceBookingUncheckedCreateWithoutPaymentsInput>
  }

  export type ServiceBookingUpsertWithoutPaymentsInput = {
    update: XOR<ServiceBookingUpdateWithoutPaymentsInput, ServiceBookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ServiceBookingCreateWithoutPaymentsInput, ServiceBookingUncheckedCreateWithoutPaymentsInput>
    where?: ServiceBookingWhereInput
  }

  export type ServiceBookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ServiceBookingWhereInput
    data: XOR<ServiceBookingUpdateWithoutPaymentsInput, ServiceBookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type ServiceBookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUpdateManyWithoutBookingNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    technician?: TechnicianUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingNestedInput
    history?: ServiceStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUncheckedUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserCreateWithoutLoyaltyAccountInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoyaltyAccountInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoyaltyAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoyaltyAccountInput, UserUncheckedCreateWithoutLoyaltyAccountInput>
  }

  export type PointTransactionCreateWithoutAccountInput = {
    id?: string
    amount: number
    type: string
    description?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PointTransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    amount: number
    type: string
    description?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PointTransactionCreateOrConnectWithoutAccountInput = {
    where: PointTransactionWhereUniqueInput
    create: XOR<PointTransactionCreateWithoutAccountInput, PointTransactionUncheckedCreateWithoutAccountInput>
  }

  export type PointTransactionCreateManyAccountInputEnvelope = {
    data: PointTransactionCreateManyAccountInput | PointTransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type RedemptionHistoryCreateWithoutAccountInput = {
    id?: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
    reward: LoyaltyRewardCreateNestedOneWithoutRedemptionsInput
  }

  export type RedemptionHistoryUncheckedCreateWithoutAccountInput = {
    id?: string
    rewardId: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
  }

  export type RedemptionHistoryCreateOrConnectWithoutAccountInput = {
    where: RedemptionHistoryWhereUniqueInput
    create: XOR<RedemptionHistoryCreateWithoutAccountInput, RedemptionHistoryUncheckedCreateWithoutAccountInput>
  }

  export type RedemptionHistoryCreateManyAccountInputEnvelope = {
    data: RedemptionHistoryCreateManyAccountInput | RedemptionHistoryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLoyaltyAccountInput = {
    update: XOR<UserUpdateWithoutLoyaltyAccountInput, UserUncheckedUpdateWithoutLoyaltyAccountInput>
    create: XOR<UserCreateWithoutLoyaltyAccountInput, UserUncheckedCreateWithoutLoyaltyAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoyaltyAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoyaltyAccountInput, UserUncheckedUpdateWithoutLoyaltyAccountInput>
  }

  export type UserUpdateWithoutLoyaltyAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoyaltyAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PointTransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: PointTransactionWhereUniqueInput
    update: XOR<PointTransactionUpdateWithoutAccountInput, PointTransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<PointTransactionCreateWithoutAccountInput, PointTransactionUncheckedCreateWithoutAccountInput>
  }

  export type PointTransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: PointTransactionWhereUniqueInput
    data: XOR<PointTransactionUpdateWithoutAccountInput, PointTransactionUncheckedUpdateWithoutAccountInput>
  }

  export type PointTransactionUpdateManyWithWhereWithoutAccountInput = {
    where: PointTransactionScalarWhereInput
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type PointTransactionScalarWhereInput = {
    AND?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    OR?: PointTransactionScalarWhereInput[]
    NOT?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    id?: StringFilter<"PointTransaction"> | string
    accountId?: StringFilter<"PointTransaction"> | string
    amount?: IntFilter<"PointTransaction"> | number
    type?: StringFilter<"PointTransaction"> | string
    description?: StringNullableFilter<"PointTransaction"> | string | null
    expiresAt?: DateTimeNullableFilter<"PointTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PointTransaction"> | Date | string
  }

  export type RedemptionHistoryUpsertWithWhereUniqueWithoutAccountInput = {
    where: RedemptionHistoryWhereUniqueInput
    update: XOR<RedemptionHistoryUpdateWithoutAccountInput, RedemptionHistoryUncheckedUpdateWithoutAccountInput>
    create: XOR<RedemptionHistoryCreateWithoutAccountInput, RedemptionHistoryUncheckedCreateWithoutAccountInput>
  }

  export type RedemptionHistoryUpdateWithWhereUniqueWithoutAccountInput = {
    where: RedemptionHistoryWhereUniqueInput
    data: XOR<RedemptionHistoryUpdateWithoutAccountInput, RedemptionHistoryUncheckedUpdateWithoutAccountInput>
  }

  export type RedemptionHistoryUpdateManyWithWhereWithoutAccountInput = {
    where: RedemptionHistoryScalarWhereInput
    data: XOR<RedemptionHistoryUpdateManyMutationInput, RedemptionHistoryUncheckedUpdateManyWithoutAccountInput>
  }

  export type RedemptionHistoryScalarWhereInput = {
    AND?: RedemptionHistoryScalarWhereInput | RedemptionHistoryScalarWhereInput[]
    OR?: RedemptionHistoryScalarWhereInput[]
    NOT?: RedemptionHistoryScalarWhereInput | RedemptionHistoryScalarWhereInput[]
    id?: StringFilter<"RedemptionHistory"> | string
    accountId?: StringFilter<"RedemptionHistory"> | string
    rewardId?: StringFilter<"RedemptionHistory"> | string
    pointsUsed?: IntFilter<"RedemptionHistory"> | number
    status?: StringFilter<"RedemptionHistory"> | string
    createdAt?: DateTimeFilter<"RedemptionHistory"> | Date | string
  }

  export type LoyaltyAccountCreateWithoutTransactionsInput = {
    id?: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLoyaltyAccountInput
    redemptions?: RedemptionHistoryCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: RedemptionHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountCreateOrConnectWithoutTransactionsInput = {
    where: LoyaltyAccountWhereUniqueInput
    create: XOR<LoyaltyAccountCreateWithoutTransactionsInput, LoyaltyAccountUncheckedCreateWithoutTransactionsInput>
  }

  export type LoyaltyAccountUpsertWithoutTransactionsInput = {
    update: XOR<LoyaltyAccountUpdateWithoutTransactionsInput, LoyaltyAccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LoyaltyAccountCreateWithoutTransactionsInput, LoyaltyAccountUncheckedCreateWithoutTransactionsInput>
    where?: LoyaltyAccountWhereInput
  }

  export type LoyaltyAccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LoyaltyAccountWhereInput
    data: XOR<LoyaltyAccountUpdateWithoutTransactionsInput, LoyaltyAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type LoyaltyAccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoyaltyAccountNestedInput
    redemptions?: RedemptionHistoryUpdateManyWithoutAccountNestedInput
  }

  export type LoyaltyAccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: RedemptionHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type LoyaltyAccountCreateWithoutRedemptionsInput = {
    id?: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLoyaltyAccountInput
    transactions?: PointTransactionCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    userId: string
    points?: number
    tier?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: PointTransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type LoyaltyAccountCreateOrConnectWithoutRedemptionsInput = {
    where: LoyaltyAccountWhereUniqueInput
    create: XOR<LoyaltyAccountCreateWithoutRedemptionsInput, LoyaltyAccountUncheckedCreateWithoutRedemptionsInput>
  }

  export type LoyaltyRewardCreateWithoutRedemptionsInput = {
    id?: string
    name: string
    description?: string | null
    pointsCost: number
    value: number
    type?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type LoyaltyRewardUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    name: string
    description?: string | null
    pointsCost: number
    value: number
    type?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type LoyaltyRewardCreateOrConnectWithoutRedemptionsInput = {
    where: LoyaltyRewardWhereUniqueInput
    create: XOR<LoyaltyRewardCreateWithoutRedemptionsInput, LoyaltyRewardUncheckedCreateWithoutRedemptionsInput>
  }

  export type LoyaltyAccountUpsertWithoutRedemptionsInput = {
    update: XOR<LoyaltyAccountUpdateWithoutRedemptionsInput, LoyaltyAccountUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<LoyaltyAccountCreateWithoutRedemptionsInput, LoyaltyAccountUncheckedCreateWithoutRedemptionsInput>
    where?: LoyaltyAccountWhereInput
  }

  export type LoyaltyAccountUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: LoyaltyAccountWhereInput
    data: XOR<LoyaltyAccountUpdateWithoutRedemptionsInput, LoyaltyAccountUncheckedUpdateWithoutRedemptionsInput>
  }

  export type LoyaltyAccountUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoyaltyAccountNestedInput
    transactions?: PointTransactionUpdateManyWithoutAccountNestedInput
  }

  export type LoyaltyAccountUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: PointTransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type LoyaltyRewardUpsertWithoutRedemptionsInput = {
    update: XOR<LoyaltyRewardUpdateWithoutRedemptionsInput, LoyaltyRewardUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<LoyaltyRewardCreateWithoutRedemptionsInput, LoyaltyRewardUncheckedCreateWithoutRedemptionsInput>
    where?: LoyaltyRewardWhereInput
  }

  export type LoyaltyRewardUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: LoyaltyRewardWhereInput
    data: XOR<LoyaltyRewardUpdateWithoutRedemptionsInput, LoyaltyRewardUncheckedUpdateWithoutRedemptionsInput>
  }

  export type LoyaltyRewardUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsCost?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyRewardUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsCost?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryCreateWithoutRewardInput = {
    id?: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
    account: LoyaltyAccountCreateNestedOneWithoutRedemptionsInput
  }

  export type RedemptionHistoryUncheckedCreateWithoutRewardInput = {
    id?: string
    accountId: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
  }

  export type RedemptionHistoryCreateOrConnectWithoutRewardInput = {
    where: RedemptionHistoryWhereUniqueInput
    create: XOR<RedemptionHistoryCreateWithoutRewardInput, RedemptionHistoryUncheckedCreateWithoutRewardInput>
  }

  export type RedemptionHistoryCreateManyRewardInputEnvelope = {
    data: RedemptionHistoryCreateManyRewardInput | RedemptionHistoryCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type RedemptionHistoryUpsertWithWhereUniqueWithoutRewardInput = {
    where: RedemptionHistoryWhereUniqueInput
    update: XOR<RedemptionHistoryUpdateWithoutRewardInput, RedemptionHistoryUncheckedUpdateWithoutRewardInput>
    create: XOR<RedemptionHistoryCreateWithoutRewardInput, RedemptionHistoryUncheckedCreateWithoutRewardInput>
  }

  export type RedemptionHistoryUpdateWithWhereUniqueWithoutRewardInput = {
    where: RedemptionHistoryWhereUniqueInput
    data: XOR<RedemptionHistoryUpdateWithoutRewardInput, RedemptionHistoryUncheckedUpdateWithoutRewardInput>
  }

  export type RedemptionHistoryUpdateManyWithWhereWithoutRewardInput = {
    where: RedemptionHistoryScalarWhereInput
    data: XOR<RedemptionHistoryUpdateManyMutationInput, RedemptionHistoryUncheckedUpdateManyWithoutRewardInput>
  }

  export type ProductCreateWithoutKnowledgeEntriesInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    inventory?: InventoryCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    reviews?: ProductReviewCreateNestedManyWithoutProductInput
    views?: ProductViewCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutKnowledgeEntriesInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    categoryId?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    inventory?: InventoryUncheckedCreateNestedOneWithoutProductInput
    InventoryAlert?: InventoryAlertUncheckedCreateNestedManyWithoutProductInput
    InventoryMovement?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    views?: ProductViewUncheckedCreateNestedManyWithoutProductInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutKnowledgeEntriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutKnowledgeEntriesInput, ProductUncheckedCreateWithoutKnowledgeEntriesInput>
  }

  export type ProductUpsertWithoutKnowledgeEntriesInput = {
    update: XOR<ProductUpdateWithoutKnowledgeEntriesInput, ProductUncheckedUpdateWithoutKnowledgeEntriesInput>
    create: XOR<ProductCreateWithoutKnowledgeEntriesInput, ProductUncheckedCreateWithoutKnowledgeEntriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutKnowledgeEntriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutKnowledgeEntriesInput, ProductUncheckedUpdateWithoutKnowledgeEntriesInput>
  }

  export type ProductUpdateWithoutKnowledgeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutKnowledgeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutPaymentIntentsInput = {
    id?: string
    orderNo: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentIntentsInput = {
    id?: string
    orderNo: string
    userId: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentIntentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentIntentsInput, OrderUncheckedCreateWithoutPaymentIntentsInput>
  }

  export type PaymentCreateWithoutIntentInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutIntentInput = {
    id?: string
    orderId: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutIntentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutIntentInput, PaymentUncheckedCreateWithoutIntentInput>
  }

  export type PaymentCreateManyIntentInputEnvelope = {
    data: PaymentCreateManyIntentInput | PaymentCreateManyIntentInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutPaymentIntentsInput = {
    update: XOR<OrderUpdateWithoutPaymentIntentsInput, OrderUncheckedUpdateWithoutPaymentIntentsInput>
    create: XOR<OrderCreateWithoutPaymentIntentsInput, OrderUncheckedCreateWithoutPaymentIntentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentIntentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentIntentsInput, OrderUncheckedUpdateWithoutPaymentIntentsInput>
  }

  export type OrderUpdateWithoutPaymentIntentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentIntentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutIntentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutIntentInput, PaymentUncheckedUpdateWithoutIntentInput>
    create: XOR<PaymentCreateWithoutIntentInput, PaymentUncheckedCreateWithoutIntentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutIntentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutIntentInput, PaymentUncheckedUpdateWithoutIntentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutIntentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutIntentInput>
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ProductReviewCreateNestedManyWithoutUserInput
    productViews?: ProductViewCreateNestedManyWithoutUserInput
    projects?: ProjectCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    questions?: CustomerQuestionUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    loyaltyAccount?: LoyaltyAccountUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    productViews?: ProductViewUncheckedCreateNestedManyWithoutUserInput
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    searchQueries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    ServiceBooking?: ServiceBookingUncheckedCreateNestedManyWithoutUserInput
    serviceViews?: ServiceViewUncheckedCreateNestedManyWithoutUserInput
    wishlistItems?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUpdateManyWithoutUserNestedInput
    projects?: ProjectUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    questions?: CustomerQuestionUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    loyaltyAccount?: LoyaltyAccountUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    productViews?: ProductViewUncheckedUpdateManyWithoutUserNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    searchQueries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    ServiceBooking?: ServiceBookingUncheckedUpdateManyWithoutUserNestedInput
    serviceViews?: ServiceViewUncheckedUpdateManyWithoutUserNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignClickCreateWithoutCampaignInput = {
    id?: string
    recipientEmail?: string | null
    url?: string | null
    createdAt?: Date | string
  }

  export type CampaignClickUncheckedCreateWithoutCampaignInput = {
    id?: string
    recipientEmail?: string | null
    url?: string | null
    createdAt?: Date | string
  }

  export type CampaignClickCreateOrConnectWithoutCampaignInput = {
    where: CampaignClickWhereUniqueInput
    create: XOR<CampaignClickCreateWithoutCampaignInput, CampaignClickUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignClickCreateManyCampaignInputEnvelope = {
    data: CampaignClickCreateManyCampaignInput | CampaignClickCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignOpenCreateWithoutCampaignInput = {
    id?: string
    recipientEmail?: string | null
    createdAt?: Date | string
  }

  export type CampaignOpenUncheckedCreateWithoutCampaignInput = {
    id?: string
    recipientEmail?: string | null
    createdAt?: Date | string
  }

  export type CampaignOpenCreateOrConnectWithoutCampaignInput = {
    where: CampaignOpenWhereUniqueInput
    create: XOR<CampaignOpenCreateWithoutCampaignInput, CampaignOpenUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignOpenCreateManyCampaignInputEnvelope = {
    data: CampaignOpenCreateManyCampaignInput | CampaignOpenCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignRecipientCreateWithoutCampaignInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
  }

  export type CampaignRecipientUncheckedCreateWithoutCampaignInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
  }

  export type CampaignRecipientCreateOrConnectWithoutCampaignInput = {
    where: CampaignRecipientWhereUniqueInput
    create: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignRecipientCreateManyCampaignInputEnvelope = {
    data: CampaignRecipientCreateManyCampaignInput | CampaignRecipientCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EmailLogCreateWithoutCampaignInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailLogUncheckedCreateWithoutCampaignInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmailLogCreateOrConnectWithoutCampaignInput = {
    where: EmailLogWhereUniqueInput
    create: XOR<EmailLogCreateWithoutCampaignInput, EmailLogUncheckedCreateWithoutCampaignInput>
  }

  export type EmailLogCreateManyCampaignInputEnvelope = {
    data: EmailLogCreateManyCampaignInput | EmailLogCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignClickUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignClickWhereUniqueInput
    update: XOR<CampaignClickUpdateWithoutCampaignInput, CampaignClickUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignClickCreateWithoutCampaignInput, CampaignClickUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignClickUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignClickWhereUniqueInput
    data: XOR<CampaignClickUpdateWithoutCampaignInput, CampaignClickUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignClickUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignClickScalarWhereInput
    data: XOR<CampaignClickUpdateManyMutationInput, CampaignClickUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignClickScalarWhereInput = {
    AND?: CampaignClickScalarWhereInput | CampaignClickScalarWhereInput[]
    OR?: CampaignClickScalarWhereInput[]
    NOT?: CampaignClickScalarWhereInput | CampaignClickScalarWhereInput[]
    id?: StringFilter<"CampaignClick"> | string
    campaignId?: StringFilter<"CampaignClick"> | string
    recipientEmail?: StringNullableFilter<"CampaignClick"> | string | null
    url?: StringNullableFilter<"CampaignClick"> | string | null
    createdAt?: DateTimeFilter<"CampaignClick"> | Date | string
  }

  export type CampaignOpenUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignOpenWhereUniqueInput
    update: XOR<CampaignOpenUpdateWithoutCampaignInput, CampaignOpenUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignOpenCreateWithoutCampaignInput, CampaignOpenUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignOpenUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignOpenWhereUniqueInput
    data: XOR<CampaignOpenUpdateWithoutCampaignInput, CampaignOpenUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignOpenUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignOpenScalarWhereInput
    data: XOR<CampaignOpenUpdateManyMutationInput, CampaignOpenUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignOpenScalarWhereInput = {
    AND?: CampaignOpenScalarWhereInput | CampaignOpenScalarWhereInput[]
    OR?: CampaignOpenScalarWhereInput[]
    NOT?: CampaignOpenScalarWhereInput | CampaignOpenScalarWhereInput[]
    id?: StringFilter<"CampaignOpen"> | string
    campaignId?: StringFilter<"CampaignOpen"> | string
    recipientEmail?: StringNullableFilter<"CampaignOpen"> | string | null
    createdAt?: DateTimeFilter<"CampaignOpen"> | Date | string
  }

  export type CampaignRecipientUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignRecipientWhereUniqueInput
    update: XOR<CampaignRecipientUpdateWithoutCampaignInput, CampaignRecipientUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignRecipientCreateWithoutCampaignInput, CampaignRecipientUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignRecipientUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignRecipientWhereUniqueInput
    data: XOR<CampaignRecipientUpdateWithoutCampaignInput, CampaignRecipientUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignRecipientUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignRecipientScalarWhereInput
    data: XOR<CampaignRecipientUpdateManyMutationInput, CampaignRecipientUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignRecipientScalarWhereInput = {
    AND?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
    OR?: CampaignRecipientScalarWhereInput[]
    NOT?: CampaignRecipientScalarWhereInput | CampaignRecipientScalarWhereInput[]
    id?: StringFilter<"CampaignRecipient"> | string
    campaignId?: StringFilter<"CampaignRecipient"> | string
    email?: StringFilter<"CampaignRecipient"> | string
    name?: StringNullableFilter<"CampaignRecipient"> | string | null
    createdAt?: DateTimeFilter<"CampaignRecipient"> | Date | string
  }

  export type EmailLogUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EmailLogWhereUniqueInput
    update: XOR<EmailLogUpdateWithoutCampaignInput, EmailLogUncheckedUpdateWithoutCampaignInput>
    create: XOR<EmailLogCreateWithoutCampaignInput, EmailLogUncheckedCreateWithoutCampaignInput>
  }

  export type EmailLogUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EmailLogWhereUniqueInput
    data: XOR<EmailLogUpdateWithoutCampaignInput, EmailLogUncheckedUpdateWithoutCampaignInput>
  }

  export type EmailLogUpdateManyWithWhereWithoutCampaignInput = {
    where: EmailLogScalarWhereInput
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EmailLogScalarWhereInput = {
    AND?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    OR?: EmailLogScalarWhereInput[]
    NOT?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    campaignId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    status?: StringFilter<"EmailLog"> | string
    error?: StringNullableFilter<"EmailLog"> | string | null
    sentAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
  }

  export type CampaignCreateWithoutRecipientsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickCreateNestedManyWithoutCampaignInput
    opens?: CampaignOpenCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutRecipientsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickUncheckedCreateNestedManyWithoutCampaignInput
    opens?: CampaignOpenUncheckedCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutRecipientsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
  }

  export type CampaignUpsertWithoutRecipientsInput = {
    update: XOR<CampaignUpdateWithoutRecipientsInput, CampaignUncheckedUpdateWithoutRecipientsInput>
    create: XOR<CampaignCreateWithoutRecipientsInput, CampaignUncheckedCreateWithoutRecipientsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutRecipientsInput, CampaignUncheckedUpdateWithoutRecipientsInput>
  }

  export type CampaignUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUpdateManyWithoutCampaignNestedInput
    opens?: CampaignOpenUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUncheckedUpdateManyWithoutCampaignNestedInput
    opens?: CampaignOpenUncheckedUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutOpensInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOpensInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickUncheckedCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOpensInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOpensInput, CampaignUncheckedCreateWithoutOpensInput>
  }

  export type CampaignUpsertWithoutOpensInput = {
    update: XOR<CampaignUpdateWithoutOpensInput, CampaignUncheckedUpdateWithoutOpensInput>
    create: XOR<CampaignCreateWithoutOpensInput, CampaignUncheckedCreateWithoutOpensInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutOpensInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutOpensInput, CampaignUncheckedUpdateWithoutOpensInput>
  }

  export type CampaignUpdateWithoutOpensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutOpensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUncheckedUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutClicksInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opens?: CampaignOpenCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutClicksInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opens?: CampaignOpenUncheckedCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutClicksInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutClicksInput, CampaignUncheckedCreateWithoutClicksInput>
  }

  export type CampaignUpsertWithoutClicksInput = {
    update: XOR<CampaignUpdateWithoutClicksInput, CampaignUncheckedUpdateWithoutClicksInput>
    create: XOR<CampaignCreateWithoutClicksInput, CampaignUncheckedCreateWithoutClicksInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutClicksInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutClicksInput, CampaignUncheckedUpdateWithoutClicksInput>
  }

  export type CampaignUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: CampaignOpenUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: CampaignOpenUncheckedUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutEmailLogsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickCreateNestedManyWithoutCampaignInput
    opens?: CampaignOpenCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutEmailLogsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.CampaignType
    status?: $Enums.CampaignStatus
    targetAudience?: string | null
    discountPercent?: number | null
    discountAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: CampaignClickUncheckedCreateNestedManyWithoutCampaignInput
    opens?: CampaignOpenUncheckedCreateNestedManyWithoutCampaignInput
    recipients?: CampaignRecipientUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEmailLogsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEmailLogsInput, CampaignUncheckedCreateWithoutEmailLogsInput>
  }

  export type CampaignUpsertWithoutEmailLogsInput = {
    update: XOR<CampaignUpdateWithoutEmailLogsInput, CampaignUncheckedUpdateWithoutEmailLogsInput>
    create: XOR<CampaignCreateWithoutEmailLogsInput, CampaignUncheckedCreateWithoutEmailLogsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEmailLogsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEmailLogsInput, CampaignUncheckedUpdateWithoutEmailLogsInput>
  }

  export type CampaignUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUpdateManyWithoutCampaignNestedInput
    opens?: CampaignOpenUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCampaignTypeFieldUpdateOperationsInput | $Enums.CampaignType
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: NullableIntFieldUpdateOperationsInput | number | null
    discountAmount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: CampaignClickUncheckedUpdateManyWithoutCampaignNestedInput
    opens?: CampaignOpenUncheckedUpdateManyWithoutCampaignNestedInput
    recipients?: CampaignRecipientUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    method?: string | null
    url?: string | null
    statusCode?: number | null
    duration?: number | null
    category?: string
    severity?: string
    createdAt?: Date | string
  }

  export type CartCreateManyUserInput = {
    id?: string
    guestId?: string | null
    status?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerQuestionCreateManyUserInput = {
    id?: string
    question: string
    category?: string | null
    satisfaction?: number | null
    timestamp?: Date | string
  }

  export type InventoryMovementCreateManyUserInput = {
    id?: string
    productId: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    orderNo: string
    subtotalCents?: number
    discountCents?: number
    shippingCents?: number
    totalCents: number
    status?: string
    shippingAddress?: string | null
    shippingCoordinates?: string | null
    promotionCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductReviewCreateManyUserInput = {
    id?: string
    productId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductViewCreateManyUserInput = {
    id?: string
    productId: string
    timestamp?: Date | string
    duration?: number | null
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    client?: string | null
    clientLogo?: string | null
    category?: string | null
    technologies?: string | null
    features?: string | null
    images?: string | null
    thumbnailImage?: string | null
    coverImage?: string | null
    youtubeVideoId?: string | null
    youtubeVideoUrl?: string | null
    demoUrl?: string | null
    githubUrl?: string | null
    liveUrl?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: string | null
    teamSize?: number | null
    budget?: string | null
    status?: string
    isActive?: boolean
    isFeatured?: boolean
    displayOrder?: number
    viewCount?: number
    tags?: string | null
    testimonial?: string | null
    results?: string | null
    challenges?: string | null
    solutions?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    ogTitle?: string | null
    ogDescription?: string | null
    ogImage?: string | null
    structuredData?: string | null
    canonicalUrl?: string | null
    content?: string | null
    galleryImages?: string | null
    clientLogoUrl?: string | null
    projectDate?: Date | string | null
    completionDate?: Date | string | null
    featured?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchQueryCreateManyUserInput = {
    id?: string
    query: string
    timestamp?: Date | string
  }

  export type ServiceBookingCreateManyUserInput = {
    id?: string
    serviceId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceViewCreateManyUserInput = {
    id?: string
    serviceId: string
    timestamp?: Date | string
    duration?: number | null
  }

  export type WishlistItemCreateManyUserInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerQuestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerQuestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerQuestionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryMovementNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    shippingCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    shippingCoordinates?: NullableStringFieldUpdateOperationsInput | string | null
    promotionCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUpdateManyWithoutReviewNestedInput
    votes?: ProductReviewVoteUpdateManyWithoutReviewNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ProductReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    product?: ProductUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ProductViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    technologies?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: NullableStringFieldUpdateOperationsInput | string | null
    solutions?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    structuredData?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    projectDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    technologies?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: NullableStringFieldUpdateOperationsInput | string | null
    solutions?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    structuredData?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    projectDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    client?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    technologies?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    testimonial?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: NullableStringFieldUpdateOperationsInput | string | null
    solutions?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    ogTitle?: NullableStringFieldUpdateOperationsInput | string | null
    ogDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    structuredData?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    galleryImages?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    projectDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUpdateManyWithoutBookingNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    technician?: TechnicianUpdateOneWithoutBookingsNestedInput
    payments?: ServicePaymentUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUncheckedUpdateManyWithoutBookingNestedInput
    payments?: ServicePaymentUncheckedUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceViewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    service?: ServiceUpdateOneRequiredWithoutViewsNestedInput
  }

  export type ServiceViewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceViewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WishlistItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutWishlistItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAlertCreateManyProductInput = {
    id?: string
    type: string
    message: string
    threshold?: number | null
    currentStock: number
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryMovementCreateManyProductInput = {
    id?: string
    type: string
    quantity: number
    previousStock: number
    newStock: number
    reason?: string | null
    referenceId?: string | null
    referenceType?: string | null
    userId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type KnowledgeBaseEntryCreateManyProductInput = {
    id?: string
    kind: string
    title: string
    content: string
    tags?: string | null
    embedding?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductReviewCreateManyProductInput = {
    id?: string
    userId: string
    rating: number
    title?: string | null
    comment?: string | null
    isVerified?: boolean
    status?: $Enums.ReviewStatus
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductViewCreateManyProductInput = {
    id?: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type WishlistItemCreateManyProductInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAlertUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    currentStock?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAlertUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    currentStock?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAlertUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    currentStock?: IntFieldUpdateOperationsInput | number
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    previousStock?: IntFieldUpdateOperationsInput | number
    newStock?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseEntryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    embedding?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUpdateManyWithoutReviewNestedInput
    votes?: ProductReviewVoteUpdateManyWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ProductReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ProductReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductViewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneWithoutProductViewsNestedInput
  }

  export type ProductViewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductViewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WishlistItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWishlistItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    canonicalUrl?: string | null
    description?: string | null
    imageUrl?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    metaTitle?: string | null
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    priceCents: number
    originalPriceCents?: number | null
    imageUrl?: string | null
    images?: string | null
    brand?: string | null
    model?: string | null
    sku?: string | null
    specifications?: string | null
    features?: string | null
    warranty?: string | null
    weight?: number | null
    dimensions?: string | null
    stockQuantity?: number
    minOrderQuantity?: number
    maxOrderQuantity?: number | null
    maxStock?: number | null
    tags?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    canonicalUrl?: string | null
    featured?: boolean
    isActive?: boolean
    isDeleted?: boolean
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    inventory?: InventoryUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUpdateManyWithoutProductNestedInput
    views?: ProductViewUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    inventory?: InventoryUncheckedUpdateOneWithoutProductNestedInput
    InventoryAlert?: InventoryAlertUncheckedUpdateManyWithoutProductNestedInput
    InventoryMovement?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    knowledgeEntries?: KnowledgeBaseEntryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    views?: ProductViewUncheckedUpdateManyWithoutProductNestedInput
    wishlistItems?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    originalPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    warranty?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minOrderQuantity?: IntFieldUpdateOperationsInput | number
    maxOrderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxStock?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    quantity: number
    price: number
    name?: string | null
    unitPrice?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentIntentCreateManyOrderInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    clientSecret?: string | null
    returnUrl?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    intentId?: string | null
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutIntentNestedInput
  }

  export type PaymentIntentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutIntentNestedInput
  }

  export type PaymentIntentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intent?: PaymentIntentUpdateOneWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    intentId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    intentId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyPaymentInput = {
    id?: string
    amountCents: number
    reason?: string | null
    status?: string
    providerRefundId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    errorMessage?: string | null
  }

  export type RefundUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreateManyServiceTypeInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    shortDescription?: string | null
    basePriceCents?: number
    price?: number
    minPrice?: number | null
    maxPrice?: number | null
    priceType?: string
    duration: number
    images?: string | null
    isActive?: boolean
    isFeatured?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    type?: string | null
    tags?: string | null
    features?: string | null
    requirements?: string | null
    metadata?: string | null
    viewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutServiceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUpdateManyWithoutServiceNestedInput
    items?: ServiceItemUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ServiceBookingUncheckedUpdateManyWithoutServiceNestedInput
    items?: ServiceItemUncheckedUpdateManyWithoutServiceNestedInput
    views?: ServiceViewUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServiceTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    basePriceCents?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    priceType?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingCreateManyServiceInput = {
    id?: string
    userId: string
    technicianId?: string | null
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceItemCreateManyServiceInput = {
    id?: string
    name: string
    price: number
    quantity: number
    createdAt?: Date | string
  }

  export type ServiceViewCreateManyServiceInput = {
    id?: string
    userId?: string | null
    timestamp?: Date | string
    duration?: number | null
  }

  export type ServiceBookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUpdateManyWithoutBookingNestedInput
    technician?: TechnicianUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingNestedInput
    payments?: ServicePaymentUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUncheckedUpdateManyWithoutBookingNestedInput
    payments?: ServicePaymentUncheckedUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingItems?: ServiceBookingItemUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingItems?: ServiceBookingItemUncheckedUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceViewUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneWithoutServiceViewsNestedInput
  }

  export type ServiceViewUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceViewUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductReviewReportCreateManyReviewInput = {
    id?: string
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ProductReviewVoteCreateManyReviewInput = {
    id?: string
    userId: string
    isUpvote?: boolean
    createdAt?: Date | string
  }

  export type ProductReviewReportUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewReportUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewReportUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewVoteUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewVoteUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReviewVoteUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUpvote?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingCreateManyTechnicianInput = {
    id?: string
    userId: string
    serviceId: string
    status?: string
    scheduledAt?: Date | string | null
    scheduledTime?: string | null
    completedAt?: Date | string | null
    notes?: string | null
    estimatedCosts?: number | null
    actualCosts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicianScheduleCreateManyTechnicianInput = {
    id?: string
    date: Date | string
    startTime: string
    endTime: string
    isAvailable?: boolean
    createdAt?: Date | string
  }

  export type ServiceBookingUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUpdateManyWithoutBookingNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutServiceBookingNestedInput
    payments?: ServicePaymentUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ServiceBookingItemUncheckedUpdateManyWithoutBookingNestedInput
    payments?: ServicePaymentUncheckedUpdateManyWithoutBookingNestedInput
    history?: ServiceStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceBookingUncheckedUpdateManyWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCosts?: NullableIntFieldUpdateOperationsInput | number | null
    actualCosts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianScheduleUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianScheduleUncheckedUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianScheduleUncheckedUpdateManyWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingItemCreateManyServiceItemInput = {
    id?: string
    bookingId: string
    quantity: number
    price: number
    createdAt?: Date | string
  }

  export type ServiceBookingItemUpdateWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: ServiceBookingUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ServiceBookingItemUncheckedUpdateWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingItemUncheckedUpdateManyWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingItemCreateManyBookingInput = {
    id?: string
    serviceItemId: string
    quantity: number
    price: number
    createdAt?: Date | string
  }

  export type ServicePaymentCreateManyBookingInput = {
    id?: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceStatusHistoryCreateManyBookingInput = {
    id?: string
    status: string
    newStatus: string
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceBookingItemUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceItem?: ServiceItemUpdateOneRequiredWithoutBookingItemsNestedInput
  }

  export type ServiceBookingItemUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceBookingItemUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusHistoryUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusHistoryUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusHistoryUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionCreateManyAccountInput = {
    id?: string
    amount: number
    type: string
    description?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RedemptionHistoryCreateManyAccountInput = {
    id?: string
    rewardId: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
  }

  export type PointTransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reward?: LoyaltyRewardUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type RedemptionHistoryUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    rewardId?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryCreateManyRewardInput = {
    id?: string
    accountId: string
    pointsUsed: number
    status?: string
    createdAt?: Date | string
  }

  export type RedemptionHistoryUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: LoyaltyAccountUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type RedemptionHistoryUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedemptionHistoryUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    pointsUsed?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyIntentInput = {
    id?: string
    orderId: string
    provider: string
    amountCents: number
    status?: string
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutIntentInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutIntentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutIntentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignClickCreateManyCampaignInput = {
    id?: string
    recipientEmail?: string | null
    url?: string | null
    createdAt?: Date | string
  }

  export type CampaignOpenCreateManyCampaignInput = {
    id?: string
    recipientEmail?: string | null
    createdAt?: Date | string
  }

  export type CampaignRecipientCreateManyCampaignInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
  }

  export type EmailLogCreateManyCampaignInput = {
    id?: string
    recipientEmail: string
    subject: string
    status: string
    error?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CampaignClickUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignClickUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignClickUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOpenUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOpenUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignOpenUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignRecipientUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CartCountOutputTypeDefaultArgs instead
     */
    export type CartCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CartCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentCountOutputTypeDefaultArgs instead
     */
    export type PaymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceTypeCountOutputTypeDefaultArgs instead
     */
    export type ServiceTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductReviewCountOutputTypeDefaultArgs instead
     */
    export type ProductReviewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductReviewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicianCountOutputTypeDefaultArgs instead
     */
    export type TechnicianCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicianCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceItemCountOutputTypeDefaultArgs instead
     */
    export type ServiceItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceBookingCountOutputTypeDefaultArgs instead
     */
    export type ServiceBookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceBookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoyaltyAccountCountOutputTypeDefaultArgs instead
     */
    export type LoyaltyAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoyaltyAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoyaltyRewardCountOutputTypeDefaultArgs instead
     */
    export type LoyaltyRewardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoyaltyRewardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentIntentCountOutputTypeDefaultArgs instead
     */
    export type PaymentIntentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentIntentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CartDefaultArgs instead
     */
    export type CartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CartItemDefaultArgs instead
     */
    export type CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CartItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefundDefaultArgs instead
     */
    export type RefundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceTypeDefaultArgs instead
     */
    export type ServiceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryDefaultArgs instead
     */
    export type InventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryMovementDefaultArgs instead
     */
    export type InventoryMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryAlertDefaultArgs instead
     */
    export type InventoryAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryReportDefaultArgs instead
     */
    export type InventoryReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WishlistItemDefaultArgs instead
     */
    export type WishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WishlistItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductReviewDefaultArgs instead
     */
    export type ProductReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductReviewVoteDefaultArgs instead
     */
    export type ProductReviewVoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductReviewVoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductReviewReportDefaultArgs instead
     */
    export type ProductReviewReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductReviewReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageDefaultArgs instead
     */
    export type PageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SearchQueryDefaultArgs instead
     */
    export type SearchQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SearchQueryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductViewDefaultArgs instead
     */
    export type ProductViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceViewDefaultArgs instead
     */
    export type ServiceViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerQuestionDefaultArgs instead
     */
    export type CustomerQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicianDefaultArgs instead
     */
    export type TechnicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceItemDefaultArgs instead
     */
    export type ServiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceBookingDefaultArgs instead
     */
    export type ServiceBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceBookingItemDefaultArgs instead
     */
    export type ServiceBookingItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceBookingItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TechnicianScheduleDefaultArgs instead
     */
    export type TechnicianScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TechnicianScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceStatusHistoryDefaultArgs instead
     */
    export type ServiceStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceStatusHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicePaymentDefaultArgs instead
     */
    export type ServicePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicePaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionDefaultArgs instead
     */
    export type PromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BannerDefaultArgs instead
     */
    export type BannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigDefaultArgs instead
     */
    export type SystemConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoyaltyAccountDefaultArgs instead
     */
    export type LoyaltyAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoyaltyAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointTransactionDefaultArgs instead
     */
    export type PointTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RedemptionHistoryDefaultArgs instead
     */
    export type RedemptionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RedemptionHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoyaltyRewardDefaultArgs instead
     */
    export type LoyaltyRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoyaltyRewardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDefaultArgs instead
     */
    export type WebhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeBaseEntryDefaultArgs instead
     */
    export type KnowledgeBaseEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeBaseEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentIntentDefaultArgs instead
     */
    export type PaymentIntentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentIntentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignRecipientDefaultArgs instead
     */
    export type CampaignRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignRecipientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignOpenDefaultArgs instead
     */
    export type CampaignOpenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignOpenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignClickDefaultArgs instead
     */
    export type CampaignClickArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignClickDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailLogDefaultArgs instead
     */
    export type EmailLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contact_messagesDefaultArgs instead
     */
    export type contact_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contact_messagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use site_settingsDefaultArgs instead
     */
    export type site_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = site_settingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use softwareDefaultArgs instead
     */
    export type softwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = softwareDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}