#!/usr/bin/env node

/**
 * Audio TÃ i Lá»™c - Type Generator Script
 * Tá»± Ä‘á»™ng generate TypeScript types tá»« API responses
 */

const fs = require('fs');
const path = require('path');

class TypeGenerator {
  constructor() {
    this.types = new Map();
    this.outputDir = path.join(__dirname, '..', 'src', 'types', 'generated');
  }

  // Create output directory
  ensureOutputDir() {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }

  // Generate TypeScript interface from JSON object
  generateInterface(name, obj, level = 0) {
    const indent = '  '.repeat(level);
    let interfaceStr = `${indent}export interface ${name} {\n`;

    for (const [key, value] of Object.entries(obj)) {
      const optional = !value ? '?' : '';
      const type = this.inferType(value, level + 1);
      interfaceStr += `${indent}  ${key}${optional}: ${type};\n`;
    }

    interfaceStr += `${indent}}\n\n`;
    return interfaceStr;
  }

  // Infer TypeScript type from JavaScript value
  inferType(value, level = 0) {
    if (value === null || value === undefined) return 'any';

    const type = typeof value;

    switch (type) {
      case 'string':
        return 'string';
      case 'number':
        return Number.isInteger(value) ? 'number' : 'number';
      case 'boolean':
        return 'boolean';
      case 'object':
        if (Array.isArray(value)) {
          if (value.length === 0) return 'any[]';
          const itemType = this.inferType(value[0], level);
          return `${itemType}[]`;
        } else {
          // Generate nested interface
          const interfaceName = `Nested${level}`;
          const interfaceStr = this.generateInterface(interfaceName, value, level);
          this.types.set(interfaceName, interfaceStr);
          return interfaceName;
        }
      default:
        return 'any';
    }
  }

  // Generate types from API response samples
  generateFromAPIResponses(responses) {
    let output = '// Auto-generated types from API responses\n';
    output += '// Generated by scripts/generate-types.js\n\n';

    for (const [endpoint, response] of Object.entries(responses)) {
      const typeName = this.endpointToTypeName(endpoint);
      const interfaceStr = this.generateInterface(typeName, response);
      output += interfaceStr;
    }

    // Add nested types
    for (const [name, interfaceStr] of this.types) {
      output += interfaceStr;
    }

    return output;
  }

  // Convert endpoint to TypeScript type name
  endpointToTypeName(endpoint) {
    return endpoint
      .replace(/^\//, '') // Remove leading slash
      .replace(/\/api\/v1\//, '') // Remove API prefix
      .replace(/\//g, '') // Remove slashes
      .replace(/s$/, '') // Remove plural 's'
      .replace(/^(.)/, (match) => match.toUpperCase()); // Capitalize first letter
  }

  // Sample API responses for Audio TÃ i Lá»™c
  getSampleResponses() {
    return {
      '/api/v1/catalog/products': {
        id: 'sample-id',
        slug: 'dan-karaoke-gia-dinh',
        name: 'DÃ n Karaoke Gia ÄÃ¬nh',
        description: 'DÃ n karaoke hoÃ n chá»‰nh cho gia Ä‘Ã¬nh',
        priceCents: 29990000,
        categoryId: 'category-id',
        featured: true,
        imageUrl: '/images/products/karaoke.jpg',
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z'
      },

      '/api/v1/catalog/categories': {
        id: 'category-id',
        name: 'DÃ n Karaoke',
        slug: 'dan-karaoke',
        isActive: true,
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z'
      },

      '/api/v1/catalog/services': {
        id: 'service-id',
        slug: 'lap-dat-karaoke',
        name: 'Dá»‹ch Vá»¥ Láº¯p Äáº·t Karaoke',
        description: 'Láº¯p Ä‘áº·t chuyÃªn nghiá»‡p há»‡ thá»‘ng karaoke',
        basePriceCents: 5000000,
        price: 5000000,
        duration: 240,
        isActive: true,
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z'
      },

      '/api/v1/orders': {
        id: 'order-id',
        orderNo: 'ATL001',
        userId: 'user-id',
        totalCents: 29990000,
        status: 'PENDING',
        shippingAddress: '123 ÄÆ°á»ng ABC, Quáº­n 1, TP.HCM',
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z'
      },

      '/api/v1/users': {
        id: 'user-id',
        email: 'user@example.com',
        name: 'Nguyá»…n VÄƒn A',
        phone: '0123456789',
        role: 'USER',
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z'
      }
    };
  }

  // Generate and save types
  async generate() {
    this.ensureOutputDir();

    const responses = this.getSampleResponses();
    const typesContent = this.generateFromAPIResponses(responses);

    const outputPath = path.join(this.outputDir, 'api-types.ts');
    fs.writeFileSync(outputPath, typesContent);

    console.log('âœ… Generated API types at:', outputPath);
    console.log('\nðŸ“‹ Generated types:');
    console.log(Object.keys(responses).map(endpoint => `  - ${this.endpointToTypeName(endpoint)}`).join('\n'));

    // Generate index file
    const indexContent = `// Auto-generated index file
export * from './api-types';
`;
    fs.writeFileSync(path.join(this.outputDir, 'index.ts'), indexContent);

    console.log('âœ… Generated index file');
  }
}

// Run if called directly
if (require.main === module) {
  const generator = new TypeGenerator();
  generator.generate().catch(console.error);
}

module.exports = TypeGenerator;
